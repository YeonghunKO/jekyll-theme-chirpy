[ { "title": "애플 웹사이트 만들기 시작! - HTML구조짜기", "url": "/posts/apple1/", "categories": "Javascript, apple", "tags": "sticky", "date": "2021-07-24 00:00:00 +0900", "snippet": "1. 애플 웹사이트인프런에서 신기한 강의를 발견함. 애플 공식웹에서 구현한 기능, 즉 스크롤 값에 따라서 글자와 사진이 커졌다 줄어들었다 사라졌다하는 기능을 가르치는 강의를 발견했다.구매한지는 4개월이상 된거 같은데 자바스크립트 기초 문법좀 더 다지고, 알고리즘 공부하느라고 최근에 듣기 시작했다. 근데, 너무 재밌다.어려운건 없다. 알고리즘 공부를 해서 그런가 웬만한 로직과 문법은 이해가 된다. 다만, 접근법이 참 신기해서 배울점이 많다.그래서 하나하나 세세하게 구현하는 과정을 서술하지는 않을 것이다. 배우던 도중에 새로알게된 사실이나, 알고있었지만 나중에 유용하게 사용될것 같은 지식만 간단하게 설명하고 넘어가려고 한다.2. HTML global / local nav로 네이밍을 했다. 움직이는 그림을 하나로 관리할 수 있게 scroll-section 이라는 클래스로 통합하였다. 또한, 각각의 웹사이트내에서 움직이는 그림이 4가지 영역으로 나뉘어져 있다. 따라서 section에 숫자를 부여하고 id를 할당하여 4개를 개별적으로 관리할 수 있게 만들었다. &amp;lt;section class=&quot;scroll-section&quot; id=&quot;scroll-section-0&quot;&amp;gt;&amp;lt;/section&amp;gt;&amp;lt;section class=&quot;scroll-section&quot; id=&quot;scroll-section-1&quot;&amp;gt;&amp;lt;/section&amp;gt;&amp;lt;section class=&quot;scroll-section&quot; id=&quot;scroll-section-2&quot;&amp;gt;&amp;lt;/section&amp;gt;&amp;lt;section class=&quot;scroll-section&quot; id=&quot;scroll-section-3&quot;&amp;gt;&amp;lt;/section&amp;gt; 글자가 올라가지 않고 사진에 붙어있는 글자에 sticky-elem이라고 네이밍함. sticky elem도 각자 가져와서 써야하므로 a,b,c,d class를 지정해서 세분화함. &amp;lt;section class=&quot;scroll-section&quot; id=&quot;scroll-section-0&quot;&amp;gt; &amp;lt;h1&amp;gt;AirMug Pro&amp;lt;/h1&amp;gt; &amp;lt;div class=&quot;sticky-elem main-message a&quot;&amp;gt; &amp;lt;p&amp;gt;하와이 용암에서 추출한 &amp;lt;br /&amp;gt;천연 주황빛깔의 최고급 세라믹&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;sticky-elem main-message b&quot;&amp;gt; &amp;lt;p&amp;gt; 음료의 맛을 200% 살려주는 &amp;lt;br /&amp;gt; 맛 강화 기능 &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;sticky-elem main-message c&quot;&amp;gt; &amp;lt;p&amp;gt; 잡고있는듯 아닌 듯한 &amp;lt;br /&amp;gt; 인체공학적 손잡이 &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;sticky-elem main-message d&quot;&amp;gt; &amp;lt;p&amp;gt; 말그대로 보면 볼 수록 빠져드는 &amp;lt;br /&amp;gt; 은은한 매력 &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/section&amp;gt; 보통 div로 감싸는 경우는 말그대로 하나로 묶어서 쉽게 정렬하기 위함이기도 하고, 한꺼번에 변화를 적용하기 위함이기도 하다.사실 html은 별거 없다. 다음은 css를 살펴보자!" }, { "title": "to do list - list 순서 유지", "url": "/posts/vanila14/", "categories": "Javascript, todo-list", "tags": "beforeunload, jquery", "date": "2021-03-06 00:00:00 +0900", "snippet": "1. jquery 코드 옮기기드래그 기능을 구현했었는데 그 위치가 새로고침되어도 유지가 되는 기능은 구현하지 못했었다.(어쩌면 못한게 아니라 안한건지도..) 그러다고 우연히 드래그위치가 유지되는 기능을 구현한 다른사람의 코드를 보게되었고 적용했다.우선 html에 있는 jquery 코드가 눈에 거슬렸다. 따라서 todoo.js로 이동시켜주었다.function dragEnable() { var script = document.createElement(&quot;script&quot;); script.innerHTML = ` $(function () { $(&#39;#js_pending&#39;).sortable({ axis: &#39;y&#39;, revert: true, scroll: true, placeholder: &#39;sortable-placeholder&#39;, start: function (event, ui) { ui.placeholder.html(ui.item.html()); }, }); $(&#39;#js_finished&#39;).sortable({ axis: &#39;y&#39;, revert: true, scroll: true, placeholder: &#39;sortable-placeholder&#39;, start: function (event, ui) { ui.placeholder.html(ui.item.html()); }, }); }); `; document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);}&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot; /&amp;gt; &amp;lt;title&amp;gt;JUST F**KING DO IT&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script src=&quot;https://code.jquery.com/ui/1.12.1/jquery-ui.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;body&amp;gt; ...&amp;lt;/body&amp;gt;jqeury 소스는 그대로 남겨두고 script 코드만 옮겼다. 이제 드래그 위치를 유지하는 기능을 구현해보겠다.2. 드래그 위치 기억다른 사람의 코드를 보았는데, 사실 다 이해한건 아니다. 아니 20%정도밖에 이해못했다. 그러나 그 원리는 이해했다. 바로 드래그가 끝난 다음 localstorage에 저장되는 array를 수정하여 다시 저장한다는 것이다.그래서, 생각해보았다. 로직은 이렇다.1 지금 paint된 ul의 list를 array로 뽑아낸다음 각각의 리스트와 그에 해당하는 인덱스를 받아온다.2 ul array를 순회하면서 list와 인덱스와 LS에 저장된 array에 있는 list와 인덱스를 비교한다.3 비교해서 인덱스가 서로 다르면 지금 paint된 인덱스위치로 옮긴다.4 예를들어서 A 라는 list가 3번째에 paint되어있는데 LS상에는 1번째라면 3번쨰에 있는 애를 지우고 첫번째에 옮기고 1번째에 있는 애를 지우고 3번째로 옮긴다.그런데 이렇게 로직을 짜면 일일이 새로 굴러들어온 돌, 그리고 기존에 박혀있는 돌의 위치를 조정해줘야한다. 너무 복잡해질것같았다. 따라서 로직을 다시 짰다.1 새로운 array를 만든다.2 ul array를 순회하면서 list와 인덱스와 LS에 저장된 array에 있는 list와 인덱스를 비교한다.3 순회하면서 해당 list와 array에 저장된 list가 같으면 그 list를 불러와서 새로운 array에 해당 list를 paint상의 인덱스위치에 저장한다.4 새로운 array를 기존 array에 덮어씌운다음 LS에 저장한다.이렇게 짜면 버그가 날 가능성도 줄어들고 코드도 깔끔해질것 같았다. 그리고 이 모든과정은 TO-DO-LIST가 종료되기 전에 딱 한 번 이뤄지면 좋다고 생각했다. 드래그 할때마다 이 과정이 일어나면 성능에 문제가 생길거라도 판단했기때문.(beforeunload 가 떠올랐다!!)그럼 코드를 짜보자.3. 구현하기!function newArrayReturned(htmlList, arrayTask) { // 새로운 array를 만든다. let editedpendingTask = []; // ul array를 순회하면서 list의 인덱스와 LS에 저장된 array에 있는 list와 인덱스를 비교한다. htmlList.childNodes.forEach((child, childIdx) =&amp;gt; { let childIden = child.id; arrayTask.map((pendingEle) =&amp;gt; { // 순회하면서 해당 list와 array에 저장된 list가 같으면 그 list를 불러와서 새로운 array에 해당 list를 paint상의 인덱스위치에 저장한다. if (childIden === pendingEle.id) { editedpendingTask.splice(childIdx, 0, pendingEle); } }); }); return editedpendingTask;}function pendingListOrderModified(htmlList, arrayTask) { let editedpendingTask = newArrayReturned(htmlList, arrayTask); // 새로운 array를 기존 array에 덮어씌운다음 LS에 저장한다. pendingTask = editedpendingTask;}function finishedListOrderModified(htmlList, arrayTask) { let editedFinishedTask = newArrayReturned(htmlList, arrayTask); finishedTask = editedFinishedTask;}window.addEventListener(&quot;beforeunload&quot;, () =&amp;gt; { pendingListOrderModified(pendingList, pendingTask); finishedListOrderModified(finishedList, finishedTask); saveState();});좋은 개발자가 되려면 항상 코드를 작성한뒤에 ‘더 성능면에서, 가독성면에서 개선할 방법은 없을까?’ 를 끊임 없이 고민하고 의심해야한다. 그래서 pendingListOrderModified와 fisnishedListOrderModified 를 합칠 방법이 없을까를 고민했다. arrayTask = editedFinishedTask; 라고 하면 되지 않을까라고 생각했다. 그렇게 했는데 아무 반응이 없었다. parameter로 전달받은 것은 결국 가상으로 인식하는건가 싶었다.일단 여기까지다! 끊임없이 개선해나가서 매우 기쁘다:))" }, { "title": "새로 배운 문법", "url": "/posts/carrot11/", "categories": "Javascript, carrot-game", "tags": "", "date": "2021-02-26 00:00:00 +0900", "snippet": "1. 새로 배운 문법요번에 나름 새로 배운 문법이 많아서 정리해두려고 한다. 굳이 자세하게 설명하진 않겠다. 검색하면 다 나오니깐 말이다.1-1. array와 관련된 문법 pop()array의 마지막 원소를 제거한 array를 리턴한다. sort()알파벳 순서, 또는 숫자 순서대로 array를 분류한다. default는 오름차순이다.그러나 default sort를 사용하면 숫자를 분류할때 맨앞자리만 놓고 분류하므로 실제 숫자의 크기대로 비교하지 않는다. 이때는 sort안에 분류함수를 pass해줘야한다. 아래처럼 말이다. reduce()pass한 함수대로 array를 계산하며 단일 값을 리턴함1-2. mutationObserver이름 그대로 변동사항을 감지하는 api이다. html 태그의 속성, 자식태그, 텍스트 등 의 변동사항을 감지한다." }, { "title": "폭죽 다듬기", "url": "/posts/carrot10/", "categories": "Javascript, carrot-game", "tags": "canvas", "date": "2021-02-26 00:00:00 +0900", "snippet": "1. 폭죽이 서서히 없어지게 하기일단 애니메이션이 한 번 실행되면 cancel될때까지 1초에 60번 실행된다. 따라서 서서히 없애려면 explode 안에 num이라는 변수를 만들고 실행될때마다 추가되도록 한다. 그럼 num이 100단위로 커질때 마다 폭죽 array안에 있는 스파크를 하나씩 줄이면 되지 않을까? 라는 생각을 했다.fireworks.jslet num = 0;function explode() { num++; switch (num) { case 100: fireworks.length = 8; break; case 250: fireworks.length = 5; break; case 300: fireworks.length = 3; break; case 350: fireworks.length = 1; break; case 400: fireworks.length = 0; break; }}완성!그리고 애니메이션을 취소하려면 어떻게 해야할까? explode안에 있는 animation을 전역변수에 담고 explode밖에서 cancelanimation함수에다가 그 변수를 넣으면 된다는 것을 발견했다.그럼 이제 거의 다 되었다. 그럼 전의 글에서 짰던 로직대로 실제 구현해보자2. 폭죽 로직 구현fireworks.jsvar fireworkId;function explode() { fireworkId = window.requestAnimationFrame(explode);}export default function startFireworks() { canvas.style.zIndex = 2; makeFireworks(); fireworkId = window.requestAnimationFrame(explode); setTimeout(stop, 7000); console.log(&quot;startfire&quot;);}function stop() { window.cancelAnimationFrame(fireworkId); canvas.style.zIndex = -3;}시간이 지나면서 폭죽의 갯수는 줄어든다. 그게 대략 7초정도 걸린다. 따라서 setTimeout으로 7초뒤에 애니메이션을 종료하도록 했다.그리고 startFireworks()를 recordToggle.js 안에서 new record / first record 안에다가 추가해주면 완성된다!정말 너무너무 뿌듯하고 희열이 폭죽처럼 터진다. 감개무량하다. 결국 뚫어냈다. 나 자신을 믿을 수 있다. 이게 코딩을 하는 이유중 하나라고 생각한다.구현하면서도 지적 호기심이 충족되면서 재밌었고 모든 버그를 해결하고 다 완성했을때의 성취감도 매우 크다. 천직인가보다 ㅋㅋㅋcarrot-game-advanced" }, { "title": "신기록을 알아차리기 그리고 폭죽터뜨리기", "url": "/posts/carrot9/", "categories": "Javascript, carrot-game", "tags": "mutaionObserver", "date": "2021-02-25 00:00:00 +0900", "snippet": "1. 신기록 갱신우선 신기록을 갱신할때마다 알려줘야한다. 그 기능을 구현하고 폭죽을 구현해보자. 그럼 알고리즘을 어떻게 짜면 될까?맨처음엔 어떻게 생각했냐면 html 에 first ranking 의 innerHtml이 바뀔때 마다 알려주는 API가 없을까 라고 검색하던 도중 발견한게 하나 있다. 바로 MutationObserver 라는 API이다. 근데 사실은, paint함수때문에 게임이 최초 실행될때마다 , 또는 게임이 끝날때 마다 first ranking이 다시 새로쓰여지기 때문에 매번 trigger 될것이다. 따라서 의미 없다.(그래도 유용하게 쓰일지 몰라 나중에 새로알게된 문법에 정리하려고 한다.)그럼 알고리즘을 짜야한다. 어떻게 짜야할까?1. 게임을 다 완료한 순간 걸리는 시간을 계산(new record 라고 하자).2. 이전에 1등했던 기록을 가져옴(old record 라고 하자)).3. new record - old record 가 0보다 작으면 신기록이라고 하면 된다.4. 혹시 처음 기록을 쓰는 경우 innerHtml = ‘‘라고 가정하면 된다.2. 기능 구현하기recordToggle.js updateRecord() { this.timeRecord = this.aggregateRecord(); this._compareRecord(this.timeRecord); this._firstRankingDetector(this.timeRecord); this._paintRecord(this.recordList); this._saveRecord(); } _firstRankingDetector(record) { let firstRankingNumberOnly = this.firstRankingSpan.innerHTML.substring( 5, 7 ); let difference = record - firstRankingNumberOnly; if (this.firstRankingSpan.innerHTML === &#39;&#39;) { console.log(&#39;first record!&#39;); startFireworks(); sound.playfireworksSound(); } else if (difference &amp;gt; 0) { console.log(&#39;not that special&#39;); } else if (difference === 0) { console.log(&#39;same record&#39;); } else if (difference &amp;lt; 0) { console.log(&#39;new record&#39;); startFireworks(); sound.playfireworksSound(); } }first record / new record 에서 폭죽이 터지도록 했다. 그럼 폭죽을 구현해보자.3. 폭죽구현폭죽은 내가 구현하지 못하니 검색을 통해 이미 구현되어있는 것을 가져오기로 했다. 그러던중 좋은것을 발견하였다. 코드도 길지않았고 간단했다.fireworks.jsconst max_fireworks = 10, max_sparks = 10;let canvas = document.getElementById(&quot;myCanvas&quot;);let context = canvas.getContext(&quot;2d&quot;);var fireworkId;let num = 0;context.canvas.width = window.innerWidth;context.canvas.height = window.innerHeight - 5;let fireworks = [];function makeFireworks() { num = 0; for (let i = 0; i &amp;lt; max_fireworks; i++) { let firework = { sparks: [], }; for (let n = 0; n &amp;lt; max_sparks; n++) { let spark = { vx: Math.random() * 5 + 0.5, vy: Math.random() * 5 + 0.5, weight: Math.random() * 0.3 + 0.03, red: Math.floor(Math.random() * 199), green: Math.floor(Math.random() * 199), blue: Math.floor(Math.random() * 199), }; if (Math.random() &amp;gt; 0.5) spark.vx = -spark.vx; if (Math.random() &amp;gt; 0.5) spark.vy = -spark.vy; firework.sparks.push(spark); } fireworks.push(firework); resetFirework(firework); }}function resetFirework(firework) { firework.x = Math.floor(Math.random() * canvas.width); firework.y = canvas.height; firework.age = 0; firework.phase = &quot;fly&quot;;}function explode() { num++; context.clearRect(0, 0, canvas.width, canvas.height); fireworks.forEach((firework, index) =&amp;gt; { if (firework.phase == &quot;explode&quot;) { firework.sparks.forEach((spark) =&amp;gt; { for (let i = 0; i &amp;lt; 10; i++) { let trailAge = firework.age + i; let x = firework.x + spark.vx * trailAge; let y = firework.y + spark.vy * trailAge + spark.weight * trailAge * spark.weight * trailAge; let r = Math.floor(spark.red * 2); let g = Math.floor(spark.green * 2); let b = Math.floor(spark.blue * 2); context.beginPath(); context.fillStyle = &quot;rgba(&quot; + r + &quot;,&quot; + g + &quot;,&quot; + b + &quot;,1)&quot;; context.rect(x, y, 4, 4); context.fill(); } }); firework.age++; if (firework.age &amp;gt; 100 &amp;amp;&amp;amp; Math.random() &amp;lt; 0.05) { resetFirework(firework); } } else { firework.y = firework.y - 10; for (let spark = 0; spark &amp;lt; 15; spark++) { context.beginPath(); context.fillStyle = &quot;rgba(&quot; + index * 50 + &quot;,&quot; + spark * 17 + &quot;,0,1)&quot;; context.rect( firework.x + Math.random() * spark - spark / 2, firework.y + spark * 4, 4, 4 ); context.fill(); } if (Math.random() &amp;lt; 0.001 || firework.y &amp;lt; 200) firework.phase = &quot;explode&quot;; } }); fireworkId = window.requestAnimationFrame(explode);}makeFireworks();fireworkId = window.requestAnimationFrame(explode);캔버스로 구현했다. 굉장히 복잡해보이지만 원리는 간단하다. 일단 makefireworks로 폭죽 스파크를 랜덤으로 만든다. 그리고 explode로 그것을 1초에 60번 표시하면서 애니메이션을 구현해낸다. 폭죽의 갯수와 스파크의 갯수도 조절할 수 있고 색깔또한 조절할 수 있다. 그리고 캔버스의 크기는 css로 조절할 수 없다. 따라서 화면에 꽉차게 하기 위해서 width / height를 위와 같이 window api를 이용해서 지정해줬다. 반응형이다 히히그럼 html에 myCanvas를 추가하고 css로 z-index를 조절해주자.&amp;lt;canvas id=&quot;myCanvas&quot;&amp;gt;&amp;lt;/canvas&amp;gt;#myCanvas { position: absolute; z-index: -3;}그리고 fireworks를 조금 손봐야한다. 폭죽이 시작되서 중지되기 까지 로직을 짜봤다.1. 폭죽이 시작되면 z-index가 커지면서 표시가 되게 해야한다.2. 시간이 지나면서 서서히 없어져야하고 다 없어지면 애니메이션이 중지가 되어야한다.3. 중지가 되면 z-index가 낮아지면서 게임을 클릭가능하게 해야한다.폭죽을 수정하는건 다음글에서:)" }, { "title": "기록 기능 구현", "url": "/posts/carrot8/", "categories": "Javascript, carrot-game", "tags": "선언형 방식", "date": "2021-02-25 00:00:00 +0900", "snippet": "1. 기록 기능 구현 알고리즘기록 기능은 의외로 복잡했다. 마지막 stage까지 갔을때 총 몇초 걸렸느냐를 측정해서 순위를 매기고 toggle에 띄우려고 했다.알고리즘은 아래와 같이 짰다.1. 우선 다음 차시로 넘어갈때마다 게임이 끝났을때 타이머를 가져온다.2. 가져올때마다 slice해서 숫자만 가져오고 agg란 array에 담는다.3. 그 array에 있는 모든 숫자를 더해 최종 걸린 시간을 구한다.4. 최종시간을 가져와서 record란 array에 담는다.5. 비교해서 분류하고 순위를 정한다.6. 순위를 표시한다.7. 저장하고 agg array를 초기화시킨다.8. 시작할때 저장한 기록을 가져와서 표시한다.그리고 현재 기록이 이전기록중에 똑같을때 추가하면 안되고, 기록이 3개까지만 표시되야하기 때문에 4개이상되면 표시되지 않도록해야한다.2. 실제 구현하기우선 엘리님 처럼 필요할 것 같은 함수를 updateRecord에 쭉 적어본다.recordToggle.jsexport class RecordToggle { constructor() { this._restoreRecordStorage(); this._loadRecord(); } updateRecord() { this.timeRecord = this.aggregateRecord(); this._compareRecord(this.timeRecord); this._paintRecord(this.recordList); this._saveRecord(); } _getTime() { return this.timeDisplay.innerHTML; } aggregateRecord() { this.timeRecord = this._getTime(); const modifiedCurrentValue = this.gameDuration - this.timeRecord.slice(-2); this.recordBoxtoAgg.push(modifiedCurrentValue); return this.recordBoxtoAgg.reduce((a, b) =&amp;gt; { return a + b; }, 0); } _compareRecord(recordTime) { for (var i = 0; i &amp;lt; this.recordList.length; i++) { if (recordTime === this.recordList[i] || recordTime === NaN) { return; } } this.recordList.push(recordTime); // compare function passed to sort the array in ascending order this.recordList.sort((a, b) =&amp;gt; a - b); if (this.recordList.length &amp;gt; 3) { // remove the last element of the array this.recordList.pop(); } } _paintRecord(recordList) { this.fromSecondSpan.innerHTML = &quot;&quot;; recordList.forEach((record, index) =&amp;gt; { const span = document.createElement(&quot;span&quot;); if (record === null) { return; } switch (index) { case 0: this.firstRankingSpan.innerHTML = `1st: ${record} sec`; break; case 1: span.innerHTML = `2nd: ${record} sec`; break; case 2: span.innerHTML = `3rd: ${record} sec`; break; default: throw Error(&quot;not valid index&quot;); } this.fromSecondSpan.appendChild(span); }); } _saveRecord() { localStorage.setItem(this.RECORD_LS, JSON.stringify(this.recordList)); this.recordBoxtoAgg = []; } _loadRecord() { this._paintRecord(this.recordList); } _restoreRecordStorage() { this.recordList = JSON.parse(localStorage.getItem(this.RECORD_LS)) || []; }}그리고 gameControl에 추가해준다. 어디에 추가해줘야 할까? 바로 모든 게임이 다 끝났을때 이 함수가 실행되어야 할것이므로 level = final stage 일때 추가해줘야한다. 그리고 매 차시 이길때 마다 기록이 쌓여야한다.gameControl.jscountCarrotFunc() { const carrotCount = this.field.carrotCount.length; if (carrotCount &amp;lt; 1) { if (this.level === 4) { this.finish(FinishReason.finalStageWin); this.levelInitalized(); // this.recordToggle.aggregateRecord(); // update에서 aggregateRecord() 선언할때 이미 실행되므로 여기서 굳이 실행할 필요없음 this.recordToggle.updateRecord(); } else { this.recordToggle.aggregateRecord(); } }}이렇게 되면 이제 마지막 차수를 완료할때마다 기록이 분류되면서 저장되어 표시될 것이다. 자 그럼 이제 신기록이 갱신될때 마다 특별한 이벤트를 발생하도록 해보자." }, { "title": "다음 레벨 구현", "url": "/posts/carrot7/", "categories": "Javascript, carrot-game", "tags": "", "date": "2021-02-25 00:00:00 +0900", "snippet": "1. 다음 레벨 구현어떻게 하면 다음 레벨로 넘어갈 수 있을까? 내가 생각한 알고리즘은 이거다. 게임에서 이길때마다, 아이템의 갯수를 증가시킨다. 그리고 게임을 하나 더 만들어서 증가된 아이콘을 새로운 게임에 pass한다음 실행한다.그래서 이런식으로 코드를 적었다.let Stage = 1;const gameStarter = (level) =&amp;gt; { const IconCount = level * 2; const Duration = level + 4; const game = new GameBuilder() // .iconCount(IconCount) .gameDuration(Duration) .build(); finishBannerFunc(game); return game;};gameStarter(Stage);function finishBannerFunc(game) { game.onFinishBannerEvent((reason) =&amp;gt; { finishBanner.hideNextStageBtn(); switch (reason) { case FinishReason.win: finishBanner.show(&quot;win&quot;); sound.playWinSound(); finishBanner.showNextStageBtn(); break; case FinishReason.bug: finishBanner.show(&quot;lose&quot;); break; case FinishReason.timeout: finishBanner.show(&quot;timeout&quot;); sound.playLoseSound(); break; case StopReason.start: finishBanner.hide(); break; case StopReason.pause: finishBanner.show(&quot;restart&quot;); break; default: throw new Error(&quot;unvalid reason&quot;); } }); finishBanner.setOnNextStageClick(gameStarter); finishBanner.setOnReplayClick(game.startFromTheVeryFirst);}최초 gameStarter는 stage = 1이다. 그리고 banner와 setclick 함수를 finishBannerFunc함수안에다 넣고 gameStarter 안에다가 넣었다. 이럼 어떻게 될까? 사실 replay 버튼은 문제없이 실행이 되었다. 그런데 nextclick 을 눌렀을때 아이템은 계속 증가된 채로 나왔다. 근데 문제는 타이머다. 일시정지를 누를때 타이머가 갑자기 중지가 된다. 그것도 ‘여러번’. 디버깅을 해보니깐. 다음 stage가 실행될때 그 전의 stage 모두 함께 실행된다는 것.다시말해, 2단계부터(1단계는 전혀 문제없다) pause를 누를때 level1에 있는 pause, icon 까지 눌러지고, level1에 있는 timer까지 작동한다는거다. level3으로 넘어가면 level1, leve2, level3 에 있는 pause 버튼과 아이콘이 모두 함께 작동한다.웬지 콜백지옥과 비슷한 구조라고 생각했다. 그래서 promise.then(game =&amp;gt; ‘그 다음 game’)으로 해결하려고 했는데 ‘그 다음 game’이 맨처음부터 바로 실행이 되었다. 시도는 좋았으나 promise는 게임을 순차적으로 만들어내기만 하지 내가 게임을 끝냈는지 알아차리지는 못했다.replay버튼은 전혀 문제가 없는 걸로 보아 replay에서 뭔가 답을 찾을 수 있을것 같긴 했지만 도무지 방법이 나오지 않았다. 그래서 4일간 온갖 방법을 시도해보다가 결국 못찾고 늘어져서 dreamcoding 슬랙에 도움을 요청했다. 그러나 아무도 도와주지 않았다. 당연하다. 나또한 이 그렇게 장황한 설명과 코드를 보면 도와줄 마음이 생길것 같지 않았다. 따라서 level up에 성공한 다른 분들을 슬랙에서 찾기 시작했고 다행히 발견하여 그 분께 메세지를 보내어 코드를 공유해줄 수 있냐고 물었다. 다행히 허락하셨고 코드를 봤는데 level up 방법은 너무나 간단하였다..새로운 문법을 적용하거나 복잡한 코드를 추가하지 않아도 되었다.새로운게임을 만들지말고 기존 게임만 가지고 가되 다음 버튼을 클릭할때 레벨을 하나 올리고 그 레벨에 따라서 display되는 icon의 수를 늘려주기만 하면 되는거였다. 하하 그래서 추가한 코드는 아래와 같다.2. 다음레벨 구현 코딩finishBanner.jsthis.nextStageBtn.addEventListener(&quot;click&quot;, () =&amp;gt; { game.levelUp(); this.onNextBtnClick &amp;amp;&amp;amp; this.onNextBtnClick(); this.hide();});일단 next버튼을 누르면 레벨이 올라가도록 했다.gameControl.jsclass Game { constructor(iconCount, gameDuration) { this.level = 1; } init(level) { if (level === 1) { this.field.displayAllIcon(this.iconCount); } if (level === 2) { this.field.displayAllIcon(this.iconCount + 2); } if (level === 3) { this.field.displayAllIcon(this.iconCount + 4); } if (level === 4) { this.field.displayAllIcon(this.iconCount + 6); } } startFromTheVeryFirst = () =&amp;gt; { this.init(this.level); }; levelUp() { ++this.level; } levelInitalized() { this.level = 1; } countCarrotFunc() { const carrotCount = this.field.carrotCount.length; if (carrotCount &amp;lt; 1) { if (this.level === 4) { this.finish(FinishReason.finalStageWin); } else { this.finish(FinishReason.win); this.countSpan.innerHTML = carrotCount; } } else { this.countSpan.innerHTML = carrotCount; } }}그리고 처음엔 레벨이 1이고 성공했을경우 레벨이 올라가면서 표시되는 아이템의 양도 많아지게했다. 또한 마지막 레벨에 도달했을때 완전히 끝내도록 했다.main.jsfinishBanner.setOnNextStageClick(game.startFromTheVeryFirst);finishBanner.setOnReplayClick(game.startFromTheVeryFirst);새로운 게임을 만들지 않고 하나의 게임을 만들고 시작버튼을 각각 부여하였다. 그래서 클릭될때마다 하나의 게임 클래스만 실행되기에 시계가 중복될 이유가 없다.잘된다!! 드뎌 해냈다. 그럼 이제 기록 기능을 구현해보자." }, { "title": "main.js에 게임 선언", "url": "/posts/carrot6/", "categories": "Javascript, carrot-game", "tags": "builder pattern, debugging", "date": "2021-02-24 00:00:00 +0900", "snippet": "1.main.js에 게임을 선언하기&quot;use strict&quot;;import { Game, FinishReason, StopReason } from &quot;./gameControl.js&quot;;import Banner from &quot;./finishBanner.js&quot;;import * as sound from &quot;./sound.js&quot;;const finishBanner = new Banner();const game = new Game(3, 10);game.onFinishBannerEvent((reason) =&amp;gt; { switch (reason) { case FinishReason.win: finishBanner.show(FinishReason.win); finishBanner.showNextStageBtn(); break; case FinishReason.bug: finishBanner.show(FinishReason.bug); break; case FinishReason.timeout: finishBanner.show(FinishReason.timeout); sound.playLoseSound(); break; case FinishReason.finalStageWin: finishBanner.show(FinishReason.finalStageWin); sound.playWinSound(); break; case StopReason.start: finishBanner.hide(); break; case StopReason.pause: finishBanner.show(StopReason.pause); break; default: throw new Error(&quot;unvalid reason&quot;); }});finishBanner.setOnReplayClick(game.startFromTheVeryFirst);game.finishBanner안에 함수를 보내준다. 그래서 게임이 멈췄을때 발생되는 모든 경우를 명시하는것이다. 그리고 replay버튼을 클릭했을때 game의 startFromTheVeryFirst메소드가 실행되어야 한다. 그래서 setOnReplayClick메소드를 이용해서 startFromTheVeryFirst메소드를 보내준다.이렇게 정리하면 main.js가 매우 깔끔해졌다. 그러나 1달뒤에 왔을때 이해가 가지않는 부분이 있을것이다. 바로 Game클래스에 들어가는 인자다. 3,10 이 무엇을 의미하는지 전혀 알 수가 없다. 이때 필요한것이 build pattern이다.2. build pattern 만들기gameControl.js 에서 build pattern을 만들자export class GameBuilder { iconCount(count) { this.count = count; return this; } gameDuration(duration) { this.duration = duration; return this; } build() { return new Game(this.count, this.duration); }}마치 fetch().then().then() 과 같은 효과를 낼 수 있다. 그래서 icon의 갯수와 game의 시간을 명시한뒤 build하면 아이콘의 갯수, 게임시간이 명확하게 표시될 것이다.main.jsconst game = new GameBuilder() // .iconCount(3) .gameDuration(10) .build();요렇게 하면 된다. 그럼 이제 진짜 모든 리팩토링 과정이 끝이 났다. 하지만 완전히 끝이 난것은 아니다. 바로 디버깅을 해야하고 성능도 개선해야한다.3. 디버깅 시간 초기화 실패리플레이버튼을 누르면 시간이 초기화되어야하는데 초기화되지않고 끝나버린 시점에서 시간이 시작된다는점이다. 이유는 gameduration의 값이 새로고침하지않는 이상 줄어든 값으로 그대로 남아있기 때문이다. 해결방법은 간단하다. main.js 에서 받아온 gameduration을 다른 변수에다가 또 저장하면 된다. startVeryFirst 메소드에다가 this.gameDuration = this.gameDurationRefresh(그 또 다른 변수); 라고 해주니 리플레이 할때마다 초기화 된다.4. 성능개선 프레임 심각하게 저하됨혹시 몰라서 performance에서 성능측정을 해봤는데 2~5프레임밖에 안나오는 것이다!! debugger를 통해서 문제는 timer에 있다는 걸 알아냈다. 바로 타이머를 실행할때마다 const timeDisplay가 만들어진다는 것이다. 그래서 timeDisplay는 constructor에 추가하였다. 그랬더니 프레임이 50까지 향상되었으나, 최초시작할때 살짝 버벅거리는 현상이 있었다.바로 –연산자를 따로 빼지않고 아예 update함수에 pass하니깐 그런 현상이 없어졌다.이로써 아주 말끔하게 작동이 되었고 완성하였다. 그러나 아직 아쉬움이 남는다. 기능을 좀 더 추가하고 싶다. 바로 아래의 기능들 말이다. 레벨 추가 기록 기능 및 신기록 갱신시 특별한 이벤트 발생이제 고생이 시작된다 ㅋㅋㅋㅋ 레벨을 추가하는 방법을 다음 글에서 살펴보자." }, { "title": "시작버튼 리팩토링(gameControl.js)", "url": "/posts/carrot5/", "categories": "Javascript, carrot-game", "tags": "freeze", "date": "2021-02-24 00:00:00 +0900", "snippet": "1. top_ui 리팩토링gameControl.js 파일&#39;use strict&#39;;import * as sound from &#39;./sound.js&#39;;import Field from &#39;./playField.js&#39;;export const FinishReason = Object.freeze({ win: &#39;win&#39;, bug: &#39;bug&#39;, timeout: &#39;timeout&#39;, finalStageWin: &#39;finally&#39;,});export const StopReason = Object.freeze({ start: &#39;start&#39;, pause: &#39;pause&#39;,});export class Game { constructor(iconCount, gameDuration) { this.iconCount = iconCount; this.gameDuration = gameDuration; this.gameDurationRefresh = gameDuration; this.playBtn = document.querySelector(&#39;.play_button&#39;); this.countSpan = document.querySelector(&#39;.count&#39;); this.stage = document.querySelector(&#39;.stage&#39;); this.clock = document.querySelector(&#39;.clock&#39;); this.timeDisplay = document.querySelector(&#39;.time_display&#39;); this.intervalId; this.veryFirstStart = true; this.field = new Field(); this.field.setIconClickEvent(this.fieldIconClick); this.playBtn.addEventListener(&#39;click&#39;, event =&amp;gt; { if (this.veryFirstStart) { this.startFromTheVeryFirst(); } else if (!this.veryFirstStart) { if (this.pressedBtn(event) === &#39;fa-play&#39;) { this.pauseToStart(StopReason.start); } else if (this.pressedBtn(event) === &#39;fa-pause&#39;) { this.startToPause(StopReason.pause); } } }); } // 여기도 바인딩? yep startFromTheVeryFirst = () =&amp;gt; { // 와..... 이거이거 오래걸렸다.refresh랑 pausetostart랑 시간타이머가 겹쳐서 계속 오류났는데 이렇게 해결했다. // 사실 기존에 time을 새로 설정했었는데 그걸 잘 생각했다면 이건 금방 생각해냈을텐데. // 새로운 신박한걸 생각하지 말고 기존에 있는것을 토대로 어떻게 다시 재구성할지 생각하자. this.veryFirstStart = false; this.gameDuration = this.gameDuration; this.startTimer(); this.showPlayBtn(); this.gameBtnChange(&#39;pause&#39;); this.field.displayAllIcon(this.iconCount); sound.playBgFromTheStart(); this.countCarrotFunc(); }; startToPause(reason) { this.gameBtnChange(&#39;play&#39;); sound.stopBgSound(); this.stopGameTimer(); this.onFinishBanner &amp;amp;&amp;amp; this.onFinishBanner(reason); } pauseToStart(reason) { this.gameBtnChange(&#39;pause&#39;); sound.playBgSound(); this.startTimer(); //pause에서 start로 넘어갈때는 duration을 초기화하면 안됨 this.onFinishBanner &amp;amp;&amp;amp; this.onFinishBanner(reason); } finish(reason) { this.hidePlayBtn(); this.stopGameTimer(); sound.stopBgSound(); this.onFinishBanner &amp;amp;&amp;amp; this.onFinishBanner(reason); } onFinishBannerEvent(func) { this.onFinishBanner = func; } // 여기도 바인딩? yep fieldIconClick = icon =&amp;gt; { if (icon === &#39;carrot&#39;) { this.countCarrotFunc(); } else if (icon === &#39;bug&#39;) { this.finish(FinishReason.bug); //여기서도 &#39;왜 배경음악중지가 없는데 배경음악이 중지될까?&#39; 라는 의문이 들면 이전 알고리즘으로 차근차근 올라가보자 } }; updateTimer(count) { // let minutes = Math.floor(count / 60); let seconds = count % 60; this.timeDisplay.textContent = `00:${ seconds &amp;gt;= 10 ? seconds : `0${seconds}` }`; } startTimer() { this.updateTimer(this.gameDuration); this.intervalId = setInterval(() =&amp;gt; { if (this.gameDuration &amp;lt;= 0) { this.finish(FinishReason.timeout); return; } else { this.updateTimer(--this.gameDuration); this.clockRing(this.gameDuration); } }, 1000); } stopGameTimer() { clearInterval(this.intervalId); this.stopClockRing(); } countCarrotFunc() { const carrotCount = this.field.carrotCount.length; if (carrotCount &amp;lt; 1) { this.finish(FinishReason.win); this.countSpan.innerHTML = carrotCount; } } else { this.countSpan.innerHTML = carrotCount; } } gameBtnChange(btn) { let button; switch (btn) { case StopReason.start: button = `&amp;lt;i class=&quot;fas fa-play&quot;&amp;gt;&amp;lt;/i&amp;gt;`; break; case StopReason.pause: button = `&amp;lt;i class=&quot;fas fa-pause&quot;&amp;gt;&amp;lt;/i&amp;gt;`; break; default: throw new Error(&#39;unvalid button&#39;); } this.playBtn.innerHTML = button; } showPlayBtn() { this.playBtn.style.visibility = &#39;visible&#39;; } hidePlayBtn() { this.playBtn.style.visibility = &#39;hidden&#39;; } pressedBtn(event) { const whichBtn = event.target.classList[1]; return whichBtn; }}top_ui와 관련된 모든 변수와 함수를 class안에 담았다. field 클래스를 불러와서 setIconClickEvent 함수에 this.fieldIconClick을 넘겨주었다. 넘겨줄때 역시 this는 자동으로 넘어가지 않으므로 arrow funciton 으로 만들어서 념겨주었다.그리고 맨처음 시작하는 함수 / 시작-&amp;gt;일시정지 함수/ 일시정시 -&amp;gt; 시작 함수/ 멈추는 함수 이렇게 나누었다. 그담에 finishReason, stopReason을 immutable한 객체로 만들었다. 말그대로 게임을 중지하는 함수에 string이 아닌 객체를 넘겨주어 직관성을 높이고 오타를 방지하기 위함이다.그럼 main.js에 최종적으로 게임함수를 만들어 보자." }, { "title": "playField,finsishBanner 리팩토링", "url": "/posts/carrot4/", "categories": "Javascript, carrot-game", "tags": "class, binding", "date": "2021-02-24 00:00:00 +0900", "snippet": "1. 함수하나당 하나의 기능만 수행지금 기존의 함수를 보면은 displayAll에서 carrotcount가 들어가 있고 startGame 함수에서도 게임을 시작하는것 뿐만 아니라 일시중지, 다시시작하는 기능까지 들어있다.또한 data.json을 이용해서 다량의 아이콘을 만들었는데 그럴필요없이 for문을 사용하면 된다.참!! 본격적으로 리팩토링을 시작하기 전에 기존의 함수를 다듬어야 한다. 바로 1함수1기능으로 다 만들고, 비효율적인 코드는 수정한다음 리팩토링을 진행해야한다는 뜻이다.2. 리팩토링2-1. popup먼저 popup부터 리팩토링해보도록 하겠다. 우선 main.js에서 popup에 관련된 함수만을 다 빼와서 finishBanner.js에 모아두자. 그리고 class안에 보관!export default class Banner { constructor() { this.finishBanner = document.querySelector(&quot;.popup&quot;); this.gameResult = this.finishBanner.querySelector(&quot;span&quot;); this.replayBtn = document.querySelector(&quot;.replay&quot;); this.nextStageBtn = document.querySelector(&quot;.next_stage&quot;); this.replayBtn.addEventListener(&quot;click&quot;, () =&amp;gt; { this.OnReplayClick &amp;amp;&amp;amp; this.OnReplayClick(); this.hide(); }); } setOnReplayClick(func) { this.OnReplayClick = func; } hide() { this.finishBanner.classList.add(&quot;non_display&quot;); } show(result) { this.finishBanner.classList.remove(&quot;non_display&quot;); let message; switch (result) { case &quot;win&quot;: message = &quot;you won! replay?🎉&quot;; break; case &quot;bug&quot;: message = &quot;You clicked the bug😝 wanna play again?&quot;; break; case &quot;timeout&quot;: message = `Time out..😅 Wanna play again?`; break; case &quot;restart&quot;: message = `Restart?`; break; case &quot;finally&quot;: message = &quot;Completed all stages🎉 going back to stage 1?&quot;; break; default: throw new Error(&quot;unvalid mesage&quot;); } this.gameResult.innerHTML = message; }}우선 constructor함수는 class Banner가 만들어지면 자동으로 실행된다. 그리고 그 외에 함수는 invoke할때만 실행된다.리플레이버튼을 클릭했을때 게임이 실행되려면 startGame 함수가 필요한데 finishBanner안에는 popup관련 함수만 있어야 하므로 startGame은 game module에서 넘겨받기로 했다. 그래서 setOnReplayClick을 이용해서 startGame함수를 넘겨받고 OnReplayClick에 저장한다음 있으면(&amp;amp;&amp;amp;) 그걸 실행하도록 했다.또한 네이밍도 showBanner가 아닌 show여야 한다. 왜냐하면, 예를 들어 showBanner라고 이름을 지었다고 해보자. 나중에 클래스 안에 있는 showbanner메소드를 호출할때 banner.showBanner 라고하면 중복이 발생하기 때문. banner.show라고 이름짓는게 훨씬 깔끔.2-2. play_fieldplayField.jsimport * as sound from &quot;./sound.js&quot;;const CARROT_SIZE = 60;export default class Field { constructor() { // this.IconCount = IconCount; this.playField = document.querySelector(&quot;.play_field&quot;); this.carrotCount = this.playField.getElementsByClassName(&quot;carrot&quot;); } setIconClickEvent(func) { this.onClick = func; // this.onClick &amp;amp;&amp;amp; this.onClick.bind(this); } onIconButton = (event) =&amp;gt; { const whichIcon = event.target; if (whichIcon.matches(&quot;.carrot&quot;)) { whichIcon.remove(); this.onClick &amp;amp;&amp;amp; this.onClick(&quot;carrot&quot;); sound.playCarrotSound(); } if (whichIcon.matches(&quot;.bug&quot;)) { this.onClick &amp;amp;&amp;amp; this.onClick(&quot;bug&quot;); sound.playBugSound(); } }; _creatIcon(iconName, iconPath) { // private 한 함수는 underscore를 붙여줌. typescript에선 private이라고 지정하는 기능이 있는데 바닐라 JS는 아직 없다ㅠ iconName.src = `./img/${iconPath}.png`; iconName.classList.add(`${iconPath}`); const playCoor = this.playField.getBoundingClientRect(); const x = 0; const y = 0; const x1 = playCoor.width; const y1 = playCoor.height; // CARROT_SIZE 를 빼는 이유는? // icon이 출력되는 범위를 화면에 꽉 채우게 될때, 만약 좌표가 화면 끝에 위치하게 된다고 가정해보면, 당근 왼쪽 끝부분이 그 좌표에 맞춰지게 된다. // 따라서 화면 밖으로 벗어나게 됨. 그래서 화면 안에서 출력되게 하려면 애초에 화면의 가로, 세로 길이가 당근의 가로 세로만큼 줄어들어야 당근이 삐져나오지 않게 됨.(논리적이다) var translateX = getRandomCoor(x, x1 - CARROT_SIZE); var translateY = getRandomCoor(y, y1 - CARROT_SIZE); iconName.style.transform = `translate(${translateX}px,${translateY}px)`; return iconName; } createCarrotIcon() { const imgCarrot = new Image(); const carrotIcon = this._creatIcon(imgCarrot, &quot;carrot&quot;); this.playField.append(carrotIcon); } createBugIcon() { const imgBug = new Image(); const bugIcon = this._creatIcon(imgBug, &quot;bug&quot;); this.playField.append(bugIcon); } displayAllIcon(count) { // 콜백으로 넘겨줄때 this 바인딩함! callback function binded with this. // 이거때문에 좀 헤맴 ㅋ 버그있을때는 똑같은 stage에 머무르지말고 알고리즘내에서 버그가 발생했다고 생각하는 지점에서 // 차근차근 한단계씩 거슬러올라가보길 this.playField.addEventListener(&quot;click&quot;, this.onIconButton); this.playField.innerHTML = &quot;&quot;; var i = 0; for (i = 0; i &amp;lt; count; i++) { this.createCarrotIcon(); this.createBugIcon(); } }}function getRandomCoor(min, max) { return Math.random() * (max - min) + min; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random 참고}보면 그전에 만든 sound를 import해서 잘 사용하고 있는걸 볼 수 있다.또한 아이콘을 클릭하면 나타나는 이벤트를 넘겨 받기 위해서 setIconClickEvent 메소드를 만들었다.getRandomCoor는 class바깥에 있다. constructor안에 있는 정보를 사용할 필요가 없는 함수. 완전 독립적으로 존재해도 이상하지 않을 함수라서 빼는게 낫다. 안그럼 class를 불러낼때마다 쓸데없이 저장되서 메모리 손실 발생.또한 여기서 눈여겨봐야하는 건 binding이다. displayAllIcon함수를 보면 class안에있는 onIconButton 메소드를 넘겨주는걸 볼 수 있다. 이때 onIconButton안에 있는 this까지 넘겨주는건 아니다. 따라서 this를 메소드와 binding해야한다(묶어줘야한다) binding하는 방법엔 3가지가 있다 this.onIconButton = this.onIconButton.bind(this) this.playField.addEventListener(“click”,(event) =&amp;gt; this.onIconButton(event)); onIconButton = (event) =&amp;gt; {…}참고로 arrow function로 만들면 저번에 배웠던것 처럼 arrow funciton 안에는 this가 없으니, 상위스코프로 넘어가서 this를 찾으려고 할거기 때문에 자동으로 this가 명시되는 결과로 이어진다.그럼 다음글에서는 top_ui를 리팩토링해보도록 하자" }, { "title": "export로 sound.js 리팩토링", "url": "/posts/carrot3/", "categories": "Javascript, carrot-game", "tags": "export, round", "date": "2021-02-24 00:00:00 +0900", "snippet": "1. export하기일단 먼저 제일 쉬운거 부터 하는게 맞다. 탄력이 붙기 때문이다. 그래서 sound관련해서 모두 모아준다음에 export를 해서 불러오면 자유자재로 원할때마다 사용가능하다. 그럼 일단 export부터 알아보자.예시로, 캐나다 달러를 미국달러로 환산하는 프로그램을 만들고 export하려고 한다. 그래서 currency-functions.js파일에 함수를 만들었다.currency-functions.jsconst exchangeRate = 0.91;function roundTwoDecimals(amount) { return Math.round(amount * 100) / 100;}export function canadianToUs(canadian) { return roundTwoDecimals(canadian * exchangeRate);}그리고 main.js에서 불러온다음 출력했다. 이때 main.js에 import하려면 html에서 script.type=’module’ 이라고 명시해줘야한다.그래야 export한것을 import로 불러 올 수 있다.&amp;lt;script type=&quot;module&quot; src=&quot;main.js&quot; defer&amp;gt;&amp;lt;/script&amp;gt;main.js&quot;use strict&quot;;// 내보내기 1import { canadianToUs } from &quot;./currency-functions.js&quot;;console.log(&quot;50 Canadian dollars equal this amount of US dollars:&quot;);console.log(canadianToUs(50));// 50 Canadian dollars equal this amount of US dollars:// 45.5이번엔 여러개를 보내보도록 하겠다.const UsToCanadian = function (us) { return roundTwoDecimals(us / exchangeRate);};const cal = { plus: (a, b) =&amp;gt; { return a + b; }, minus: (a, b) =&amp;gt; { return a - b; }, multiple: (a, b) =&amp;gt; { return a * b; }, divide: (a, b) =&amp;gt; { return a / b; },};export { UsToCanadian, cal };요런식으로 마지막에 export할것을 객체에 담아서 보내는 방법이 있다.import * as skills from &quot;./currency-functions.js&quot;;console.log(&quot;30 US dollars eqauls to this amount of Canadian dollars: &quot;);console.log(skills.UsToCanadian(30));console.log(&quot;-----lets add nums using add func from calculation const-----&quot;);console.log(skills.cal.plus(2, 3));// 30 US dollars eqauls to this amount of Canadian dollars:// 32.97// -----lets add nums using add func from calculation const-----// 5불러올때는 모든것을 선택하는 선택자 *를 명시하고 as 뒤에 별명(skills)를 붙인다음 객체처럼 쓰면 됨.2. export2요번에는 export default와 class를 보내는 방법에 대해서 살펴보자.먼저 export default는 한번만 명시할 수 있다. 따라서 import 할때도 전송되는 변수나 객체의 이름을 그대로 쓸필요없이 아무 이름이나 적어도 된다.default_self_intro.jsexport default { selfIntroduction(name, job) { console.log(`Hi my name is ${name}, and i am ${job}`); }, askBack: function (question) { console.log(`what is your ${question}?`); },};export const randomNumBetween = (max, min) =&amp;gt; { return Math.random() * (max - min) + min;};main.jsimport selfIntro from &quot;./default_self_intro.js&quot;;selfIntro.selfIntroduction(&quot;yeong&quot;, &quot;programmer&quot;);selfIntro.askBack(&quot;first language&quot;);import { randomNumBetween } from &quot;./default_self_intro.js&quot;;console.log(randomNumBetween(10, 100));// Hi my name is yeong, and i am programmer// what is your first language?// 83.38011060756901이때 selfIntro라고 아무렇게나 이름붙이고 가져오면 default가 전송된다. 만약 그냥 export한 변수, randomNumBetween을 가져오고 싶으면 default가 아니기 때문에 이름을 정확히 명시해야한다.이번엔 default로 클래스를 가져와보자default_family_class_intro.jsexport default class familyIntro { constructor(yourName, parentsName) { this.myName = yourName; this.parents = parentsName; this.familyDiv = document.querySelector(&quot;.family_new_func&quot;); this.familyFuncDiv = document.querySelector(&quot;.family_fun_express&quot;); this.familyDiv.addEventListener(&quot;click&quot;, () =&amp;gt; { this.expressFamilyFunc(); }); } houseIntro(address) { this.houseAdress = address; return `${this.parents} bought my house in ${this.houseAdress} `; }}import familyIntro from &quot;./default_family_class_intro.js&quot;;const family = new familyIntro(&quot;yeong&quot;, &quot;jongman&quot;);const houseA = family.houseIntro(&quot;ulsan&quot;);console.log(houseA);// jongman bought my house in ulsan이런식으로 클래스를 불러와서 사용가능하다. 그럼 sound.js를 정리하고 export해보자3. sound 리팩토링&#39;use strict&#39;;const audioBackground = new Audio(&#39;./sound/curious_kiddo.mp3&#39;);const swooshSound = new Audio(&#39;./sound/swoosh.mp3&#39;);const blobSound = new Audio(&#39;./sound/blop.mp3&#39;);export function playSwooshSound() { playSound(swooshSound);}export function playBlobSound() { playSound(blobSound);}export function playBgFromTheStart() { audioBackground.currentTime = 0; playSound(audioBackground);}...function playSound(sound) { sound.play();}function stopSound(sound) { sound.pause();}export하려는 function이 너무많아서 생략했다. 요런식으로 한곳에 다 모은다음 import해서 사용가능하다import * as sound from &quot;./sound.js&quot;;sound.playBgFromTheStart();export한 모든것을 *선택자로 묶은다음 sound라는 이름을 부여하여 객체처럼 사용가능. 따라서, 예를들어, 배경음악이 재생되야할곳에 위와 같이 사용하면된다.그럼 다음에 리팩토링할것은 popup부분이다. 리팩토링 module을 나누는 기준은 html에서 설정하면 된다. html을 보면 구분되어지는 덩어리들이 보일것이다. 그 덩어리를 기준으로 삼아서 js파일을 만들고 그 안에 정리하면 된다. 보니깐 top_ui play_field popup toggle이렇게 구분지어서 리팩토링하면 될듯하다." }, { "title": "주먹구구식으로 나름 혼자 구현해보기", "url": "/posts/carrot2/", "categories": "Javascript, carrot-game", "tags": "fetch", "date": "2021-02-22 00:00:00 +0900", "snippet": "1. top_ui 기능 구현function displayAll() { init().then((items) =&amp;gt; { //아이콘 초기화 playField.innerHTML = &quot;&quot;; // json안에 있는 data를 전달해주긴 했지만 그걸 사용하지는 않았음. const carrotItems = items.map(createCarrotIcon); const bugItems = items.map(createBugIcon); // console.log(carrotItems[0],typeof bugItems); playField.append(...carrotItems); playField.append(...bugItems); countCarrotFunc(); });}function startAgain() { playBtnDiv.style.visibility = &quot;visible&quot;; playBtn.innerHTML = `&amp;lt;i class=&quot;fas fa-pause&quot;&amp;gt;&amp;lt;/i&amp;gt;`; audioBackground.play(); count = 10; clearInterval(intervalId); intervalId = setInterval(decreasingCount, 1000); popUp.classList.add(&quot;non_display&quot;); displayAll();}우선 엘리님이 mini shopping에서 사용한 방법을 사용해서 여러개의 아이콘을 만들어보려고 했었다. 그래서 data 폴더안에 아무것도 들어있지 않은 item을 10개 만들고 json파일에 담았다. fetch를 이용해서 data를 받아오고 displayAll에서 받아온 data를 순회하면서 안에 담겨있는 갯수(10개) 만큼 아이템을 만들게 했다.1-1. 버튼 기능 구현function startGame(event) { if (playFromTheVeryStart === true) { activateReplayBtn(); startAgain(); playFromTheVeryStart = false; } else if (playFromTheVeryStart === false) { if (event.target.classList.contains(&quot;fa-pause&quot;)) { playBtn.innerHTML = `&amp;lt;i class=&quot;fas fa-play&quot;&amp;gt;&amp;lt;/i&amp;gt;`; audioBackground.pause(); clearInterval(intervalId); popUp.classList.toggle(&quot;non_display&quot;); gameResult.innerHTML = `Restart?`; } if (event.target.classList.contains(&quot;fa-play&quot;)) { playBtn.innerHTML = `&amp;lt;i class=&quot;fas fa-pause&quot;&amp;gt;&amp;lt;/i&amp;gt;`; audioBackground.play(); intervalId = setInterval(decreasingCount, 1000); popUp.classList.toggle(&quot;non_display&quot;); } if (event.target.classList.contains(&quot;fa-reply-all&quot;)) { startAgain(); } }}//mainfunction init() { playBtnDiv.addEventListener(&quot;click&quot;, startGame); return fetch(&quot;./data/data.json&quot;) .then((response) =&amp;gt; response.json()) .then((json) =&amp;gt; json.items);}init();그리고 startGame함수를 통해서 최초 게임실행을 표시하기 위한 boolean 변수를 만들고(playFromTheVeryStart) 토글처럼 최초 게임실행시 false가 되도록 했다.그리고 playFromTheVeryStart === false 인경우에 한하여 또다시 로직을 구성하였다. 일시정지 버튼을 구현하기 위한 로직이다. 클릭했을때 pause 아이콘이면 다시 시작, 그게 아니면 pause 되도록 했고. replay 버튼을 클릭시 다시 시작 하도록 했다.일단 동작이 되긴 된다 ㅋㅋㅋ 그런데 여기서 훨씬 더 깔끔해 질 수 있고 미래 확장성 까지 고려해서 코드에 옵션을 굉장히 쉽게 추가할 수 있도록 코드를 재구성 할 수 있다. 바로 클래스를 단위로 해서 리팩토링하는 거다.(A quality of design that takes possible future advances into consideration and attempts to accommodate them)다음글에서 자세히 다뤄보자.P.S: 구현 결과를 확인하려면 여기를 들어가보면 됩니다 ㅋㅋCARROT-GAME" }, { "title": "당근게임 시작!", "url": "/posts/carrot1/", "categories": "Javascript, carrot-game", "tags": "getBoundingClientRect", "date": "2021-02-22 00:00:00 +0900", "snippet": "1. 당근게임 시작!이 게임을 통해서 나는 또다시 한걸음, 아니 두세걸음 성장했다. 이 프로젝트는 겉으로 보기에 보잘것 없이 보이지만 내가 이 프로젝트를 하기 전과 후의 모습사이에 매우 상이한 차이가 존재한다. 우선 코드리뷰의 필요성을 절실히 느꼈고, 끈기와 겸손을 배웠다. 그외에 리팩토링하는 법, 그리고 로직을 구성하는 능력도 조금 오른것 같다. 맨 처음시작해서 완전히 완성되어 지금 이글을 쓰기까지 한달이라는 시간이 걸렸다.한달간의 긴 여정동안 무엇을 배우고 느꼈는지 여기에 적어보려한다.우선, 엘리님은 강의를 보기전에 본인 스스로 다 만들어볼것을 매우 권하셨다. 그래서 나혼자 만들기 시작했다. 우선 정적 웹페이지부터 구현하자.&amp;lt;head&amp;gt; &amp;lt;script src=&quot;https://kit.fontawesome.com/579c4d8c64.js&quot; crossorigin=&quot;anonymous&quot; &amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&quot;./src/main.js&quot; defer&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div id=&quot;background&quot;&amp;gt; &amp;lt;img src=&quot;./img/background.png&quot; class=&quot;bg_image&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;section class=&quot;top_ui&quot;&amp;gt; &amp;lt;div class=&quot;play_button_div&quot;&amp;gt; &amp;lt;audio src=&quot;./sound/calm.mp3&quot; id=&quot;audio&quot;&amp;gt;&amp;lt;/audio&amp;gt; &amp;lt;button class=&quot;play_button&quot;&amp;gt;&amp;lt;i class=&quot;fas fa-play&quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;time_display&quot;&amp;gt;00:00&amp;lt;/div&amp;gt; &amp;lt;span class=&quot;count&quot;&amp;gt;0&amp;lt;/span&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;ul class=&quot;play_field&quot;&amp;gt;&amp;lt;/ul&amp;gt; &amp;lt;div class=&quot;popup non_display&quot;&amp;gt; &amp;lt;button class=&quot;replay_btn&quot;&amp;gt;&amp;lt;i class=&quot;fas fa-reply-all&quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/button&amp;gt; &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;top_ui 안에 기본적으로 사용자가 컨트롤하고 확인하는 ui를 추가했다. 그리고 play_field를 만들어서 그 안에다가 icon이 display되도록 했다. 그리고 popup창을 non_display한다음 게임에서 졌을때 그리고 pause했을때 이 창이 뜨면서 사용자는 field안에 있는 아이콘을 클릭하지 못하게 했다.또한, 아이콘을 받아오는 방법을 달리 해봤다. 다운받아서 파일에 넣은다음 src를 불러오는 local의 방식이 아닌, 아이콘을 외부에서 받아와서 바로 쓰는 방식으로 말이다.fontawesome 이라는 웹사이트를 이용하면 된다. 자세한건 검색을 통해 쉽게 배울 수 있으니 굳이 여기에 서술하지는 않겠다.2. 동적인 웹 구현하기 위한 로직 적어보기우선 로직을 글로 쉽게 정리해보자. top_ui 로직1. 플레이 버튼을 누르면 안에 innerHtml이 바뀌면서 타이머가 시작되고 노래가 나옴.2. 그리고 ul안에 캐릭터가 출력.3. count가 나타남. field 로직1. random 함수를 쓴다음 transform을 이용해서 그 값을 pass하면 아이콘의 위치가 무작위로 배치됨. 성공했을경우1. 시간이 끝나기 전에 당근을 다 클릭했으면 시간 중지.2. 재생버튼 없어짐.3. 팝업창이 나타나면서 이겼다고 나옴.4. 리플레이를 클릭하면 시작함수로 돌아감. 실패했을경우1. 타이머가 멈춤.2. 팝업창이 뜨면서 실패했다고 메세지가 바뀜.3. 리플레이버튼을 누르면 시작함수로 돌아감.✨설명팝업도 만들어보기. 니코 홈피보고 만들어보기. 에니메이션도 넣어가면서2-1. 구현 시작!(시간이 1초씩 줄어드는 함수)만들면서 유난히 생각을 많이 하게한 함수만 설명하려고 한다.let count;let intervalId;let playFromTheVeryStart = true;function decreasingCount() { if (count &amp;lt; 0) { audioBackground.pause(); const audioLose = new Audio(&quot;./sound/game_lose.mp3&quot;); audioLose.play(); popUp.classList.remove(&quot;non_display&quot;); playBtnDiv.style.visibility = &quot;hidden&quot;; clearInterval(intervalId); gameResult.innerHTML = `Time out..😅 Wanna play again?`; playFromTheVeryStart = true; return; } const timeDisplay = document.querySelector(&quot;.time_display&quot;); timeDisplay.innerHTML = count &amp;lt;i 10 ? `00:0${count}` : `00:${count}`; --count; // console.log(count);}function startAgain() { clearInterval(intervalId); intervalId = setInterval(decreasingCount, 1000);}게임이 시작되면 시간함수가 초기화되고 다시 decreasingCount 함수가 1초마다 실행된다. 실행될때마다 카운트는 10에서 줄어들고, time에 표시된다. 카운트가 0이되면 게임이 종료된다.2-2. 아이콘을 만들고 랜덤으로 배치하는 함수들function getRandomCoor(min, max) { var minV = Math.ceil(min); var maxV = Math.floor(max); return Math.random() * (maxV - minV) + minV; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random 참고}function creatIcon(iconName, iconPath) { iconName.src = `./img/${iconPath}.png`; iconName.classList.add(`${iconPath}`); iconName.addEventListener(&quot;click&quot;, onIconButton); const playCoor = playField.getBoundingClientRect(); var translateX = getRandomCoor(0, playCoor.right); var translateY = getRandomCoor(-35, playCoor.bottom - playCoor.top); iconName.style.transform = `translate(${translateX - 10}px,${translateY}px)`; return iconName;}function createCarrotIcon() { const imgCarrot = new Image(); const carrotItems = creatIcon(imgCarrot, &quot;carrot&quot;); return carrotItems;}function createBugIcon() { const imgBug = new Image(); const bugItems = creatIcon(imgBug, &quot;bug&quot;); return bugItems;}getRandomCoor에 들어가는 인자가 직관적이지 못하다. 그래도 일단 playfield 사이즈안에 아이템이 표시되도록 끼워맞췄다. 그리고 new Image를 creatIcon에 pass하여 하나씩 부품을 추가한 다음 완성된 부품을 리턴하는 방식으로 알고리즘을 짰다.그럼 다음글에선 top_ui를 구현해보도록 하자." }, { "title": "007의 성능을 개선", "url": "/posts/miniProject6/", "categories": "Javascript, mini-project", "tags": "translate, load", "date": "2021-01-19 00:00:00 +0900", "snippet": "1. 개선 방법그럼 무언가가 바뀔때 가장 좋은 방법은, 수정하고 나서 operation 과정중에 composition만 하면 되게끔 하는 방법이다. 그러나 top,left를 바꾸면 layout부터 다시 시작해야한다. css property 중에 수정하고 나서 operation 과정중에 어디서 부터 수정해야하는지 알려주는 사이트가 있다.효율적인 css를 위한 웹사이트들어가보면 top, left는 operation과정을 모두 거쳐야한다는 것을 확인할 수 있다. 그럼 효율적으로 위치를 수정하는 property가 뭐가 있을까? 바로 transform property 이다. composition만 하면 된다는 것을 확인 할 수 있다. 그럼 자바스크립트를 수정해보자.document.addEventListener(&quot;mousemove&quot;, (event) =&amp;gt; { const xCoor = event.pageX; const yCoor = event.pageY; target.style.transform = `translate(${xCoor}px,${yCoor}px)`; coord.style.transform = `translate(${xCoor}px,${yCoor}px)`; cross.style.transform = `translate(${xCoor}px,0)`; horizontal.style.transform = `translate(0,${yCoor}px)`; coord.innerHTML = `${xCoor}px, ${yCoor}px`;});요렇게 바꾸면 된다. 근데 target이 맞지 않다.곰곰히 생각해보면, target의 가로길이의 반만큼 왼쪽으로 가고 반만큼 위로 올라가면 커서에 위치하는 것을 알 수 있다. 그럼 생각할 수 있는방법이, getBoundingClientRect 함수를 이용해서 target의 width,height를 알아내고 나누기 2를 하는 방법이다. 그리고 그 반으로 나눈 값을 target.transform 에서 빼면 된다.const targetRect = target.getBoundingClientRect();const targetRectHalfWidth = targetRect.width / 2;const targetRectHalfHeight = targetRect.height / 2;target.style.transform = `translate(${xCoor - targetRectHalfWidth}px,${ yCoor - targetRectHalfHeight}px)`;그러나 문제가 발생할 수 있다. getBoundingClientRect을 출력했을때 height/width의 값이 0 일 수 있다. 이유는 html이 rendering되기 전에 js가 fetching되어진 경우이다. 그렇다면 html이 다 rendering 된 이후에 target의 크기를 받아오면 되므로 event추가할때 load라는 키워드를 사용하면 된다.window.addEventListener(&quot;load&quot;, () =&amp;gt; { const target = document.querySelector(&quot;img&quot;); const targetRect = target.getBoundingClientRect(); const targetRectHalfWidth = targetRect.width / 2; const targetRectHalfHeight = targetRect.height / 2; document.addEventListener(&quot;mousemove&quot;, (event) =&amp;gt; { const xCoor = event.pageX; const yCoor = event.pageY; target.style.transform = `translate(${xCoor}px,${yCoor}px)`; coord.style.transform = `translate(${xCoor}px,${yCoor}px)`; cross.style.transform = `translate(${xCoor}px,0)`; horizontal.style.transform = `translate(0,${yCoor}px)`; coord.innerHTML = `${xCoor}px, ${yCoor}px`; });});그럼 html이 다 load되고 나서 중괄호안에 있는 코드를 실행하게 된다. 그렇게 되면, target의 height/width 값을 받아올 수 있게 되면서 target이 커서에 위치하게 된다.2. 성능이 향상되었다는 증거그럼 실제로 성능이 향상되었는지 어떻게 알 수 있을까? 바로 개발자 도구에 performance 탭에 들어가면 된다. 우선 top/left를 썼을때 performance를 살펴보고 tranform을 사용했을때 성능이 얼마나 향상되었을지 비교해보자.우선 perfomance에 들어가서 녹화버튼을 누르고 동작한다음 종료를 누르면 이렇게 녹화했을당시에 얼마나 잘 돌아가고 있었는지에 대한 모든 정보를 볼 수 있다. 기본적으로는 1초당 60개의 프레임이 지나가야한다. 그럼 1개의 프레임당 11.67ms 정도의 시간이 걸리면 그정도 나온다. 근데 보면 프레임 한개당 16ms, 20ms 정도의 시간이 걸린걸 확인할 수 있다.그래서 빨간색으로 문제가 있다고 알려주고 클릭하면 그 문제의 원인이 무엇이고 어디서 발생했는지 까지 매우 친절하게 알려준다.그럼 transform을 사용하면 어떻게 될까?빨간색이 없어지고 초록색깔의 향연을 볼 수 있다. 프레임이 향상된것이다. 이렇게 성능을 향상하는 개발, 그리고 성능을 측정할 수 있는 방법까지 살펴보았다. 진짜 유용한 팁을 알게되어서 매우 기분이 좋다." }, { "title": "좌표찾아 007", "url": "/posts/miniProject5/", "categories": "Javascript, mini-project", "tags": "rendering", "date": "2021-01-19 00:00:00 +0900", "snippet": "1. 좌표찾아 007을 통해 알아보는 좋은 코드작성 법이 프로젝트를 통해 브라우저의 좌표에 대해 알아보고 그 좌표를 화면에 나타내보도록 하겠다. 더 나아가 브라우저가 이 코드를 조금더 덜 부담스럽게 받아들 일 수 있는 방법까지 알아보고 실제로 그걸 확인할 수 있는 방법도 설명하고자 한다.&amp;lt;body&amp;gt; &amp;lt;div class=&quot;target&quot;&amp;gt; &amp;lt;img src=&quot;target.png&quot; alt=&quot;img&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;innerCircle&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;cross&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;horizontal&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;요렇게 target그림 , 좌표가 나오는 공간, 세로축, 가로축 이 들어갈 tag를 만들었다. 그럼 css를 만들어보자.body { background-color: black; margin: 0;}img { position: absolute;}.coord { width: 20vmin; color: beige; position: absolute; margin: 20px;}section { position: absolute;}.cross { height: 100vh; width: 1px; background-color: beige; position: fixed;}.horizontal { height: 1px; width: 100vw; background-color: beige; position: fixed;}마우스가 움직일때 마다 위치가 변해야 하므로 position:absolute 가 동일하게 들어있다는 것을 염두해두자. 그럼이제 자바스크립트를 작성해야한다. 또한 target이 커서로 부터 약간 미세하게 벗어나있는데 body margin 때문에 그런것이니 이것을 0으로 만들어주면 깔끔하게 커서와 target이 일치되는 것을 볼 수 있다.const coord = document.querySelector(&quot;.coord&quot;);const cross = document.querySelector(&quot;.cross&quot;);const horizontal = document.querySelector(&quot;.horizontal&quot;);const target = document.querySelector(&quot;img&quot;);document.addEventListener(&quot;mousemove&quot;, (event) =&amp;gt; { const xCoor = event.pageX; const yCoor = event.pageY; target.style.top = xCoor + &quot;px&quot;; target.style.left = yCoor + &quot;px&quot;; cross.style.top = xCoor + &quot;px&quot;; horizontal.style.left = yCoor + &quot;px&quot;; coord.style.top = xCoor + &quot;px&quot;; coord.style.left = yCoor + &quot;px&quot;; coord.innerHTML = `${xCoor}px, ${yCoor}px`;});그럼 이렇게 잘 나오는 것을 확인할 수 가 있다.그러나 top , left를 쓰면 성능이 저하된다. 그 이유를 알려면 먼저 서버가 브라우저에게 웹 정보를 전달하는 과정을 알아야한다.(rendering 하는 과정)1. request/reponse: 브라우저가 서버에게 html 파일을 요청. 가장 먼저 html을 받아오고 그 파일안에서 링크된 필요한 파일들 (css/js)을 받아온다2. loading: 받아온 파일들을 로딩3. scripting: html 파일을 읽어서 DOM요소로 변환한다(DOM 트리 생성), 그리고 CSS 스타일을 모두 계산해서 CSSOM 트리 생성4. rendering: DOM + CSSOM 트리를 브라우저에 표기될 요소들만 선별해서 Render Tree를 생성 (html header는 표기하지 않음)(여기서부터는 operation 하는 과정)5. layout: Render Tree의 각 요소들의 위치, 크기, 나타날 순서 등을 고려하여 브라우저에 배치하는 과정6. painting: layout을 통해 계산된 모든 정보를 bitmap의 형태로 조각조각 떨어져 있는데 그러한 정보를 모아서 실제 뿌려주는 단계.7. composition: 뿌려주고나서 다듬는 단계그런데 top과 left를 사용하면 layout단계에서 node들이 바뀌어 버린다. 그렇다면 target이 없어지면 그와 관련된 다른 모든 node들의 layout도 계산해서 바뀌어 버리기때문에 엉망이 되고 많다. 쉽게말해, 유지보수도 힘들어지고, 프레임도 떨어진다. 다음글에서 해결방법을 설명하겠다." }, { "title": "쇼핑몰 미니게임 강화!", "url": "/posts/miniProject4/", "categories": "Javascript, mini-project", "tags": "delegation, data-set", "date": "2021-01-15 00:00:00 +0900", "snippet": "1. displayList 함수 구현items을 출력할 함수를 만들어 보자// update the list with given itemsfunction displayList(items) { const list = document.querySelector(&quot;.list&quot;); list.innerHTML = items.map((item) =&amp;gt; displayHTML(item)).join(&quot;&quot;); // list태그안에 있는 내용을 innerHTML을 통해서 업데이트 가능}// map은 key-value가 있는 object를 loop할때 사용할 수 있구나.// join함수가 없으면 li 뒤에 , 가 따라 붙어서 쓸데없는 공백이 생겨버린다.// create list elementfunction displayHtml(item) { // 아까 샘플로 만들었던 html list를 붙여넣고 수정하자 return ` &amp;lt;li class=&quot;item ${item.type} ${item.color}&quot;&amp;gt; &amp;lt;img src=&quot;${item.image}&quot; alt=&quot;${item.type}&quot; class=&quot;thumnail&quot; /&amp;gt; &amp;lt;span class=&quot;description&quot;&amp;gt;${item.gender}, ${item.size}&amp;lt;/span&amp;gt; &amp;lt;/li&amp;gt;`;}// createElement/ append 를 통해서 태그를 만들어도 되지만 이렇게 직관적으로 string template를 통해 return 해줘도 상관없다. 오히려 이게 더 보기 쉬울 수 있다요런식으로 string template를 사용해 만들면 더 보기 깔끔하고 쉽다.2. setClickEvent 함수 구현여기서 아까 buttons를 section으로 감쌌던 이유가 나온다. 바로 이벤트 위임이라는 것 때문인데, 부모태그에 event를 설정하면 자식태그들도 그 부모태그의 이벤트를 위임받기 때문에 querySelectorAll(&#39;.btn&#39;) 사용할 필요가 없다.(참고로 querySelectorAll은 array-like를 리턴하기 때문에 forEach를 사용할 수 있다)// set click functionfunction setClickEvent(items) { const buttons = document.querySelector(&quot;.button&quot;); const logo = document.querySelector(&quot;.logo&quot;); buttons.addEventListener(&quot;click&quot;, (event) =&amp;gt; onButton(event, items)); logo.addEventListener(&quot;click&quot;, () =&amp;gt; displayList(items));}여기서 onButton을 만들기 위해서 button에 dataset을 설정할 필요가 있다. dataset은 내가 임의로 그 button의 data속성을 설정해서 내가 선택한 button을 명확하게 가져올 수 있다.&amp;lt;section class=&quot;button&quot;&amp;gt; &amp;lt;button class=&quot;btn&quot;&amp;gt; &amp;lt;img src=&quot;./img/blue_p.png&quot; alt=&quot;pants&quot; class=&quot;btnImg&quot; data-key=&quot;type&quot; data-value=&quot;pants&quot; /&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;button class=&quot;btn&quot;&amp;gt; &amp;lt;img src=&quot;./img/blue_s.png&quot; alt=&quot;pants&quot; class=&quot;btnImg&quot; data-key=&quot;type&quot; data-value=&quot;skirt&quot; /&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;button class=&quot;btn&quot;&amp;gt; &amp;lt;img src=&quot;./img/blue_t.png&quot; alt=&quot;pants&quot; class=&quot;btnImg&quot; data-key=&quot;type&quot; data-value=&quot;tshirt&quot; /&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;button class=&quot;btn blueB&quot; data-key=&quot;color&quot; data-value=&quot;blue&quot;&amp;gt;blue&amp;lt;/button&amp;gt; &amp;lt;button class=&quot;btn pinkB&quot; data-key=&quot;color&quot; data-value=&quot;pink&quot;&amp;gt;pink&amp;lt;/button&amp;gt; &amp;lt;button class=&quot;btn yellowB&quot; data-key=&quot;color&quot; data-value=&quot;yellow&quot;&amp;gt; yellow &amp;lt;/button&amp;gt;&amp;lt;/section&amp;gt;요런식으로 각 button에 datakey / datavalue를 달아주면 그 button의 속성을 가져올 수 있다. 그러고 onButton을 만들자.function onButton(event, items) { const data = event.target.dataset; const key = data.key; const value = data.value; if (key === null || value === null) { return; } // 예를 들어 blue 버튼을 선택했다고 하면 item[color] === blue 가 속해있는 data만 filter해서 displayList에 보내게 된다 displayList( items.filter((item) =&amp;gt; { return item[key] === value; }) ); const list = document.querySelectroAll(&quot;.item&quot;);}그런데 이렇게 하면 문제가 발생한다. 버튼을 매번 클릭할때마다 list가 업데이트된다는 것이다. 그럼 시간도 에너지도 많이 든다. 따라서 기존에 있는 list에서 클릭한 값에 해당되는 list에다가 display = none 해주는게 더 바람직하다.const list = document.querySelectorAll(&quot;.item&quot;);list.forEach((item) =&amp;gt; { if (item.classList[1] === value || item.classList[2] === value) { item.classList.remove(&quot;non-visible&quot;); } else { item.classList.add(&quot;non-visible&quot;); }});(css에는 non-visible 클래스에 display = none을 추가해주었다) 이런식으로 말이다.그리고 list 중에서 class에 선택한 버튼의 value에 해당되는 게 있다면 표시 아니면 표시하지 않는 로직을 짰다.(string template를 보면 클래스에 color와 type 을 추가했었다) 그럼 이로써 다 만들었다.3. 느낀 점1. 필요할것 같은 함수의 이름을 일단 적고나서 함수의 기능을 구현해라.만들고 나서 적용하지 말고. 우선 가이드라인이 있어야하기 때문. 큰그림을 먼저그려놓고 세부적으로 안에 작은 그림을 채워넣는거다2. 일단 html을 정적으로 만드는것 부터 시작하라.가이드라인이 되는것도 있지만 일이 탄력받는데 도화선이 되는 목적이 가장 크다.우선 뭔가 진전이 있어야 할 마음이 생기기 때문. 그리고 코드 작성하면서 머리도 빨리빨리 돌아가고3. 도저히 풀리지 않으면 끙끙 앓지말고 질문해라.힌트를 봐라! 안그럼 엄청난 고통이 느껴지면서 포기하게 될 수 도 있다.4. 새로 배운 문법1. …(spread syntax)예를 들어, 가져온 json 데이터를 여러개의 list로 변환한 뒤에 container에 append 해주려고 한다.이때 forEach를 사용해서 하나하나 append 해줘도 되지만, iterable elements 이므로 ... 를 사용해도 된다. 아래처럼 말이다.loadItems().then(items =&amp;gt; {const elements = items.map(createElement);const container = document.querySelector(&#39;.items&#39;);// 아래 코드를elements.forEach(item =&amp;gt; {container.append(item);});// 요렇게 깔끔하게 바꿀수 있다container.append(...elements);아래 링크를 클릭하면 결과물을 확인할 수 있다.mini-shopping-game" }, { "title": "쇼핑몰 미니게임 시작!", "url": "/posts/miniProject3/", "categories": "Javascript, mini-project", "tags": "JSON", "date": "2021-01-15 00:00:00 +0900", "snippet": "1. 쇼핑몰 미니게임 만들기우연히 엘리님의 강의를 듣게되었는데 사소하게 보이지만 정말 중요하다고 생각했던것을 알려주고 계셨고 관심이 있어서 강의를 하나 들었다. 간단한 미니게임을 만드는 과제를 받았다. 색깔을 누를때마다 거기에 해당하는 색깔대로 list가 출력되도록 하는 웹앱이어서 쉽게 만들 수 있다고 생각했다. 그러나 막상시작하려니 뭘 할지 막막했다. 내가 기본기가 아직 많이 약하다는것을 발견했다. 게다가 엘리님이 코딩리뷰까지 해주신다고 하니 이건 꼭 수강해서 배워야겠다고 생각했다.우선 프로젝트의 기능은 버튼이 있고 그 버튼(바지,치마,색깔)을 클릭할때 마다 그 버튼에 해당되는 속성만 필터링되서 출력되게 하는 프로젝트였다. vanila JS 로 만들어야 했다. 그리고 필요한 자료는 img폴더안에 들어있었다. 일단 내가 쓴 코드는 모르고 다 지워버렸다. 대충 설명하자면 HTML에서 버튼은 IMG와 DIV로 구현을 했고 JS에서는 각 리스트의 이름을 ARRAY 안에 담은 다음 for문으로 array안에 있는 이름들을 img에 대입하여 list를 만들었다. 그러나 버튼을 구현하는 과정에서 막혔고 결국 이틀을 고민끝에 엘리님 코딩을 보았다.엘리님은 data.json을 따로 만들어서 data폴더에 보관하셨고 그 data를 fetch를 통해 동적으로 전달받아서 html에 출력하셨다. 정말 깔끔하고 보기 쉽고 효율적인 방법이었다. 그래서 나도 data.json을 만들어서 불러들이려고 했으나 http형태가 아니면 전달받을 수 없다고 에러가 떴다. 알아보니깐 html 파일을 클릭해서 열면 로컬서버가 아닌 html을 그대로 보여주는 것 밖에 안되기 때문에 http 형태로 출력되지 않기 때문이었다.따라서 node.js 를 설치하고 http-server 파일경로를 명령창에 입력한다음 localhost를 만들어서 실행해야만 json파일을 받아 올 수 있었다. 그럼 본격적으로 만들어 보자. 로직의 순서는 아래와 같다.1. data.json을 불러온다.2. 불러온 json을 display 함수에 넣고 알아서 가공한다음 browser에 전달한다.3. setclick 함수에 json을 pass 하고 조건에 따라 filter 되도록 한다.2. data.json과 html만들기먼저 data폴더 안에 data.json을 만들자. data를 js안에 보관하면 안된다. js는 비지니스 코드만 보관하고 data는 따로 보관해야 모든면에서 편하다.(가독성,유지보수, 메모리){ &quot;items&quot;: [ { &quot;type&quot;: &quot;tshirt&quot;, &quot;gender&quot;: &quot;female&quot;, &quot;size&quot;: &quot;large&quot;, &quot;color&quot;: &quot;pink&quot;, &quot;image&quot;: &quot;./img/pink_t.png&quot; }, { &quot;type&quot;: &quot;pants&quot;, &quot;gender&quot;: &quot;male&quot;, &quot;size&quot;: &quot;small&quot;, &quot;color&quot;: &quot;blue&quot;, &quot;image&quot;: &quot;./img/blue_p.png&quot; }, { &quot;type&quot;: &quot;pants&quot;, &quot;gender&quot;: &quot;male&quot;, &quot;size&quot;: &quot;large&quot;, &quot;color&quot;: &quot;yellow&quot;, &quot;image&quot;: &quot;./img/yellow_p.png&quot; }, { &quot;type&quot;: &quot;skirt&quot;, &quot;gender&quot;: &quot;male&quot;, &quot;size&quot;: &quot;large&quot;, &quot;color&quot;: &quot;yellow&quot;, &quot;image&quot;: &quot;./img/yellow_s.png&quot; }, { &quot;type&quot;: &quot;skirt&quot;, &quot;gender&quot;: &quot;female&quot;, &quot;size&quot;: &quot;small&quot;, &quot;color&quot;: &quot;blue&quot;, &quot;image&quot;: &quot;./img/blue_s.png&quot; } ......... ]}그래서 나중에 fetch로 받아와서 array처럼 사용하면 된다. 그럼 html을 만들어보자우선 button을 만들고 그 button들을 section안에 담았다(이유는 나중에 나온다) 그리고 ul을 만든다음 대충 어떻게 표시되나 볼려고 임의로 list를 만들었다.&amp;lt;body&amp;gt; &amp;lt;img src=&quot;./img/logo.png&quot; alt=&quot;logo&quot; class=&quot;logo&quot; /&amp;gt; &amp;lt;section class=&quot;button&quot;&amp;gt; &amp;lt;button class=&quot;btn&quot;&amp;gt; &amp;lt;img src=&quot;./img/blue_p.png&quot; alt=&quot;pants&quot; class=&quot;btnImg&quot; /&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;button class=&quot;btn&quot;&amp;gt; &amp;lt;img src=&quot;./img/blue_s.png&quot; alt=&quot;pants&quot; class=&quot;btnImg&quot; /&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;button class=&quot;btn&quot;&amp;gt; &amp;lt;img src=&quot;./img/blue_t.png&quot; alt=&quot;pants&quot; class=&quot;btnImg&quot; /&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;button class=&quot;btn blueB&quot;&amp;gt;blue&amp;lt;/button&amp;gt; &amp;lt;button class=&quot;btn pinkB&quot;&amp;gt;pink&amp;lt;/button&amp;gt; &amp;lt;button class=&quot;btn yellowB&quot;&amp;gt;yellow&amp;lt;/button&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;ul class=&quot;list&quot;&amp;gt; &amp;lt;li class=&quot;item&quot;&amp;gt; &amp;lt;img src=&quot;./img/yellow_p.png&quot; alt=&quot;pants&quot; class=&quot;thumnail&quot; /&amp;gt; &amp;lt;span class=&quot;description&quot;&amp;gt;male, large&amp;lt;/span&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt;&amp;lt;/body&amp;gt;css같은경우 배울점만 설명하겠다. 바로 아래와 같이 변수를 설정하는 것이었다. 그럼 일일이 숫자와 unit을 입력하지 않아도 된다. 코드가 길어지면 이렇게 간편화하는게 얼마나 큰 차이를 낳는지 느껴지게 될것이다. 여기만 바꾸면 되니깐 말이다.(또한 주석을 달아주는 것도 매우 중요하다. 그리고 핵심만 깔끔하게 적어주자):root { /* color */ --color-black: #3f454d; --color-white: #ffffff; --color-blue: #3b88c3; --color-yellow: #fbbe28; --color-pink: #fd7f84; --color-light-grey: #dfdfdf; --animation-duration: 300ms; /* space */ --base--space: 1vmin;}3. JS 시작!우선 JSON을 불러오고 그다음 내가 필요한 기능을 대략적으로 파악하여 어떤 함수를 만들지 적어보자. 다시말해, 큰그림을 그리고 세부적인것을 채우는 방식이다. 함수의 이름을 먼저 적고 기능은 나중에 구현하자는 말이다.// fetching data from data folderfunction loadJson() { return fetch(&quot;./data/data.json&quot;) .then((response) =&amp;gt; response.json()) .then((json) =&amp;gt; json.items);}// main boardloadJson() .then((item) =&amp;gt; { displayList(item); setClickEvent(item); }) .catch((err) =&amp;gt; console.log(err));지금 보면 가져온 data를 displayList에 보내줘서 일단 출력한다.그리고 button을 클릭했을때 해당 item이 출력되도록 한다.에러가 있으면 에러를 출력한다.처럼 우선 해야할 것들을 적음으로써 가이드라인을 명확하게 제시한다. 그럼 각 함수의 기능은 다음 글에서 구현해보자" }, { "title": "to do list - progress바 추가", "url": "/posts/vanila13/", "categories": "Javascript, todo-list", "tags": "progress", "date": "2020-12-17 00:00:00 +0900", "snippet": "progress 태그를 이용한 진행상황 보고챌린지를 진행했던 다른사람들의 작품을 참고하다가 또 발견한 기능이. 리스트를 추가할때마다 그리고 완료할때마다 몇개나 남았는지 시각적으로 알려주는 기능이다. 살펴보니 progress tag를 html에 사용하였고 js 기능을 추가하면 될 것 같았다.적당한 위치를 보다가 todo input 밑이 좋을 것 같았다.&amp;lt;div class=&quot;progress&quot;&amp;gt; &amp;lt;div class=&quot;count_pending&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;progress id=&quot;progress_bar&quot; value=&quot;&quot; max=&quot;&quot;&amp;gt;&amp;lt;/progress&amp;gt;&amp;lt;/div&amp;gt;max갯수 중에 value가 차지하는 비율에 따라 prgress가 나타난다. 그리고 count_pending에는 현재 pendinglist의 갯수를 숫자로 표시하고 싶었다. 그럼 생각나는게 childElementCount 함수였다. 로직은 pedninglist + finishedlist 갯수를 max에 넣고 finishedlist 갯수를 value에 넣으면 될 것 같았다.const pendingList = document.getElementById(&quot;js_pending&quot;), finishedList = document.getElementById(&quot;js_finished&quot;), progessDiv = document.querySelector(&quot;.progress&quot;), countPending = progessDiv.querySelector(&quot;.count_pending&quot;), progressBar = document.getElementById(&quot;progress_bar&quot;);function progressFunction() { if (pendingList.childElementCount || finishedList.childElementCount) { // html 에 pending, finished 가 있을 경우 아래의 코드를 실행 countPending.innerHTML = `${pendingList.childElementCount} more to go`; progressBar.max = pendingList.childElementCount + finishedList.childElementCount; progressBar.value = finishedList.childElementCount; if (pendingList.childElementCount === 0) { // 그리고 pendinglist 갯수가 없으면 끝났다고 알려줌 countPending.innerHTML = `Finished!! Let&#39;s go out and enjoy your life! 😆`; } } else { // 아무것도 없으면 &quot;너의 삶을 살아라&quot; 고 나타남 countPending.innerHTML = `Nothing to do. Enjoy your life!`; }}그리고 submit 할때마다, 버튼을 누를때 마다 실행되서 반영되야 하기에 sumit , 모든 버튼의 함수에 progress()를 추가해주면된다. 2021-11-03:movieSeats 프로젝트에서 queryselectorAll을 이용해 dynamic하게 만들려고 했는데 All은 static하다고 해서 실패했는데 queryselector는 static하지 않은가 보군?" }, { "title": "to do list - 날씨 토글 기능 활성화", "url": "/posts/vanila12/", "categories": "Javascript, todo-list", "tags": "z-index", "date": "2020-12-17 00:00:00 +0900", "snippet": "1. weather.js 추가(API를 이용한 WEATHER 정보 추가)openweathermap 사이트에서 정보를 가져온다. 우선 기존 weather.js 에서 몇가지 코드를 추가해줄것이다. html 에서 js_weather 아래에 추가해준 틀은 도시, 날씨아이콘, 온도, 체감온도이다.json을 log 해보면 현재 위도, 경도를 통해 검색한 결과값을 볼 수 있다. 그리고 openweathermap 에서 날씨 아이콘을 추출 할 수 있는 방법을 알 수 있으니 잘 찾아보면 된다.const js_weather = document.querySelector(&quot;.js_weather&quot;), weather_box = js_weather.querySelector(&quot;.weather_box&quot;), city = weather_box.querySelector(&quot;.city&quot;), weather = weather_box.querySelector(&quot;.weather&quot;), weather_icon = weather.querySelector(&quot;.weather_icon&quot;), current_temp = weather_box.querySelector(&quot;.current_temp&quot;), feel_like = weather_box.querySelector(&quot;.feel_like&quot;);// DOM 변수를 설정해준다function getWeather(lat, lng) { fetch( `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&amp;amp;lon=${lng}&amp;amp;appid=${API_KEY}&amp;amp;units=metric&amp;amp;lang=kr` ) .then((response) =&amp;gt; { return response.json(); }) .then((json) =&amp;gt; { // 위의 then을 통해 받은 api 데이터안에서 원하는 값을 extract 한다. const cityJson = json.name, weatherJsonIcon = json.weather[0].icon, currentTempJson = json.main.temp, feelLiksJson = json.main.feels_like; // JSON을 로그해서 나온 값을 보고 원하는 정보만 추출해보았다 city.innerHTML = `도시: ${cityJson}`; weather_desciption.innerHTML = &quot;날씨:&quot;; weather_icon.src = `http://openweathermap.org/img/wn/${weatherJsonIcon}.png`; current_temp.innerHTML = `현재기온: ${currentTempJson}℃`; feel_like.innerHTML = `체감기온: ${feelLiksJson}℃`; // 그리고 DOM 변수에 추출한 정보를 담아준다 });}2. toggle.js 추가그리고 마지막으로 버튼에 기능을 추가해준다.관건은 빈 변수를 설정하고 클릭할 때마다 false와 true를 왔다갔다 하도록 함수 코드를 짜는 것이다.const functionButton = document.querySelector(&quot;.see_function&quot;), fucntionList = document.querySelector(&quot;.section&quot;), functionArrow = functionButton.querySelector(&quot;.functionArrow&quot;);const weatherButton = document.querySelector(&quot;.see_weather&quot;), weatherList = document.querySelector(&quot;.weather_box&quot;), weatherArrow = weatherButton.querySelector(&quot;.weatherToggleImg&quot;);let b_pressed = false;function displayWeather() { if (b_pressed === false) { weatherButton.classList.add(&quot;forWeatherBtnWidth&quot;); // 버튼의 크기와 모양 위치가 weather.css 에서 설정해준 forWeatherBtnWidth에 의해 바뀐다. weatherList.classList.remove(&quot;non-showing&quot;); // 날씨 정보 박스가 나타난다. weatherArrow.classList.add(&quot;non-showing&quot;); // 화살표가 없어진다 b_pressed = true; // 버튼을 클릭했을때 b_pressed는 false 상태이므로 위의 코드가 실행될 것이다. 그리도 다시 클릭하면 아래의 함수가 설정된다. } else { weatherButton.classList.remove(&quot;forWeatherBtnWidth&quot;); weatherList.classList.add(&quot;non-showing&quot;); weatherArrow.classList.remove(&quot;non-showing&quot;); b_pressed = false; }}function init() { weatherButton.addEventListener(&quot;click&quot;, displayWeather);}init(); \\ \\3. 디버그label img를 클릭하면 실행이 되지만 버튼을 클릭하면 실행이 안된다. 그래서 개발자툴을 봤더니 main이 버튼을 가리고 있었던 것이다. 그래서 main{z-index: -1} 을 해주었고 화면 가장 안쪽으로 이동했기 때문에 버튼을 클릭할 수 있게 되었다." }, { "title": "to do list - 날씨 토글 추가", "url": "/posts/vanila11/", "categories": "Javascript, todo-list", "tags": "label, vmin", "date": "2020-12-17 00:00:00 +0900", "snippet": "토글기능 추가(날씨 토글)챌린지 도중 다른 사람의 작품도 보았는데 그 중에 어떤 사람이 토글버튼을 추가해서 그 버튼을 누르면 날씨가 펼쳐지게 하였고 다시 누르면 날씨박스가 닫혀서 보이지 않았다. 무언가 내가 이 사이트랑 좀더 친밀해진 느낌이었고 재밌었고 깔끔했다. 그래서 나도 구현해보려고 했다.로직을 순서대로 설명하자면. 우선 html 부터 손을 봐야한다. label과 button을 추가한다. 그리고 weather.js 에서 API로 정보를 전달받고 전달받은 정보를 button안에 있는 내용을 채워준다 toggle.js 에서 버튼의 기능을 추가하고 활성화한다.1. html 만들기label과 button을 추가한다. 그리고 button안에 날씨의 내용을 추가한다.&amp;lt;div class=&quot;js_weather&quot;&amp;gt; &amp;lt;label for=&quot;weatherBtn&quot;&amp;gt; &amp;lt;img src=&quot;src/img/weather.png&quot; alt=&quot;&quot; class=&quot;weatherToggleImg&quot; /&amp;gt; &amp;lt;/label&amp;gt; &amp;lt;!-- label.for = button.id 면 label을 눌렀을때 button도 같이 작동한다. 그리고 날씨 아이콘을 다운받고 label안에 img.src에 추가해주었다. --&amp;gt; &amp;lt;button class=&quot;see_weather&quot; id=&quot;weatherBtn&quot;&amp;gt; &amp;lt;span class=&quot;weatherToggleImg&quot;&amp;gt;🔻&amp;lt;/span&amp;gt; &amp;lt;div class=&quot;weather_box non-showing&quot;&amp;gt; &amp;lt;!-- 날씨 박스를 만들고 그 안에 날씨의 내용을 채워넣었다. --&amp;gt; &amp;lt;!-- 도시/날씨/온도/체감온도 --&amp;gt; &amp;lt;span class=&quot;city&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;div class=&quot;weather&quot;&amp;gt; &amp;lt;span class=&quot;weather_description&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;img src=&quot;&quot; alt=&quot;&quot; class=&quot;weather_icon&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;span class=&quot;current_temp&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;feel_like&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;2. weather.css 추가클릭하기 전에는 label img와 화살표만 보이게 했고 둘다 크기를 어느정도 조정하고, 위치를 오른쪽 위에 위치하게 했다..see_weather { background: transparent; outline: none; border: none; border: 1.5px solid white; position: absolute; top: 15vmin; right: 5vmin; width: 10vmin; transform: rotateZ(0deg); /* 버튼의 위치가 돌아가게 하는 property이다 */ transform-origin: top left; border-radius: 0.9vmin; transition: all 200ms linear;}/* 버튼의 위치와 크기 스타일을 설정했다. */.see_weather:hover { cursor: pointer; border-color: pink; background-color: rgba(236, 240, 241, 1);}/* 버튼에 커서를 올렸을때 스타일 */.js_weather { font-size: 2.1vmin; font-weight: 700; padding: 1vmin 1vmin;}/* weather 토글 전체의 크기 설정 */그라고 버튼을 눌렀을때 non-showing class 가 없어지면서 weather-box 가 드러나고, button class 에 forWeatherBtnWidth가 추가된다..weather_box { display: flex; flex-direction: column; transform: rotateZ(-90deg); align-items: baseline;}.weather { display: flex; align-items: center; justify-content: center;}.forWeatherBtnWidth { background-color: rgba(236, 240, 241, 0.5); font-size: 2vmin; padding: 0px; font-weight: 900; color: black; border: none; border-top: 0.5vmin solid rgba(255, 255, 255, 0.7); border-bottom: 0.5vmin solid rgba(255, 255, 255, 0.7); top: 1vmin; right: -5vmin; width: 19vmin; height: 26vmin; transform: rotateZ(90deg); /* 왼쪽 위로 펼쳐지도록 함. */ transform-origin: top left;}.forWeatherBtnWidth:hover { background-color: rgba(236, 240, 241, 0.7);}중요한것은 글자크기 위치를 설정할때 vmin을 사용하였다. viewport minimum의 약자로 viewport 즉, 모바일화면의 가로 세로중 최소넓이의 100분의 1의 크기를 의미한다. 즉 화면에 따라 수치가 비율적으로 알아서 달라진다는 의미.그리고 js 기능을 추가해주었는데 그 기능은 다음글에서 설명하도록 하겠다." }, { "title": "to do list - list 내용 수정", "url": "/posts/vanila10/", "categories": "Javascript, todo-list", "tags": "matches, replaceChild", "date": "2020-12-17 00:00:00 +0900", "snippet": "list 내용 수정이번에 소개할 기능은 list의 내용을 수정하는 기능이다. challenge 도중 다른 사람의 작품을 보다가 수정할 수 있는 기능을 추가한 사람이 있어서 , 그분의 코드를 읽고 이해한 다음 내 나름대로 적용해보았다. 논리의 흐름은 이렇다..1 to-do list 더블클릭2 내용이 없어지고 input 박스가 생겨남3 input 박스에 내용을 입력하고 enter를 누름4 input.value의 내용과 버튼들이 다시 생기고 localstorage(이하 LS)에 해당 list의 내용이 input.value로 수정됨5 LS 저장6 ESC를 누르거나 커서를 input 바깥에서 누르면 기존의 내용이 그대로 복원됨..그럼 번호순으로 자세히 설명해보겠다..1. 더블 클릭 input 박스가 생겨남더블클릭은 eventlistner “dbclick” 으로 구현했고, input박스는 replacechild로 구현했다. 좀더 자세하게 코드로 알아보자.const handleEdit = (event) =&amp;gt; { const isSpan = event.target.closest(&quot;span&quot;); // event.target은 li 안에 있는 태그들을 말한다.closest(&quot;span&quot;)이라고 하면 그 태그들 중에 span 을 찾거나 가장 가까운걸 찾아서 return 하라는 뜻. 결국 span값만 선택하겠다는 거다. if (isSpan) { // 그게 span이라면 아래의 코드를 진행(따라서 span말고 다르걸 클릭하게 되면 이 코드가 실행안되는 거임) const li = isSpan.parentNode; const span = li.querySelector(&quot;span&quot;); const input = document.createElement(&quot;input&quot;); input.value = span.innerText; // input이 생겨나고 기존의 span 내용이 input에 입력된다 li.querySelector(&quot;.delBtn&quot;).classList.add(&quot;non-showing&quot;); if (li.querySelector(&quot;.finishBtn&quot;) !== null) { li.querySelector(&quot;.finishBtn&quot;).classList.add(&quot;non-showing&quot;); } if (li.querySelector(&quot;.backBtn&quot;) !== null) { li.querySelector(&quot;.backBtn&quot;).classList.add(&quot;non-showing&quot;); } // 버튼들을 없애는 작업이다. input.name = span.innerHTML; input.maxLength = &quot;100&quot;; input.placeholder = &quot;값을 수정해라카이&quot;; input.autocomplete = &quot;off&quot;; // input을 클릭했을때 자동완성되는 기능이다. li.replaceChild(input, span); // 그렇게 만든 input이 기존 span과 교체된다 input.focus(); // 그리고 커서가 input에 올라간다. input.addEventListener(&quot;keyup&quot;, handleKeyUp); // keyup 이벤트는 input에 어떤 키를 입력했을때를 가정해서 함수를 적용하는 것이다. 아래 설명으로 넘어가자. input.addEventListener(&quot;focusout&quot;, handleFocusOut); }};function init() { todoForm.addEventListener(&quot;submit&quot;, handleFormSubmit); entireTodolist.addEventListener(&quot;dblclick&quot;, handleEdit); // 리스트 전체를 범위로 잡고 더블클릭했을때 이벤트가 발생하게 함. loadState(); restoreState();}2. input 박스에 내용을 입력하고 enter를 누름input에 뭔가 키를 입력했을때 작동되는 함수이다.const pendingList = document.getElementById(&quot;js_pending&quot;), finishedList = document.getElementById(&quot;js_finished&quot;);function updateFinishedTask(id, text) { finishedTask.map((finishedElement) =&amp;gt; { if (finishedElement.id === id) { finishedElement.text = text; } });}function updatePendingTask(id, text) { pendingTask.map((pendingElement) =&amp;gt; { if (pendingElement.id === id) { pendingElement.text = text; } });}function isLiInTodos(li) { return li.parentNode.matches(&quot;#js_pending&quot;);}function nonShowingRemover(li, btnName) { li.querySelector(`.${btnName}`).classList.remove(&quot;non-showing&quot;);}function buttonRestorer(li) { nonShowingRemover(li, &quot;delBtn&quot;); if (li.querySelector(&quot;.finishBtn&quot;)) { nonShowingRemover(li, &quot;finishBtn&quot;); } // 보니깐 nonshowingremover도 반복되어서 위에 따로 빼놓았다. if (li.querySelector(&quot;.backBtn&quot;)) { nonShowingRemover(li, &quot;backBtn&quot;); }}3. input.value의 내용이 span의 내용이 됨. 버튼 다시 생기고 LS에 저장function handleKeyUp(event) { if (event.target.value !== &quot;&quot; &amp;amp;&amp;amp; event.key === &quot;Enter&quot;) { // 무언가 입력했으면서 enter 키를 누른상태라면 아래의 코드가 실행된다. event.target.lastKey = event.key; // 둘다 로그해보면 target.key는 &quot;Enter&quot; 라고 나오는데 lastKey는 undefined라고 나온다. 그럼 undefined라고 되어있는게 문제가 된다는 말인데, lastKey가 도데체 무엇을 의미하는것일까. 근데 또, event를 로그하고 target.lastKey 를 따라 가보면 &quot;Enter&quot; 라고 되어있다. 여기는 왜 Enter라고 되어있으며 로그했을땐 왜 undefined라고 되어있었던 것일까? // 이게 무슨 역할을 하는지 궁금해서 삭제하고 돌려보니 아래와 같은 경고가 나온다. // Failed to execute &#39;replaceChild&#39; on &#39;Node&#39;: The node to be removed is no longer a child of this node. Perhaps it was moved in a &#39;blur&#39; event handler? // 교체하려고 하는 node가 더이상 li의 child가 아니라는 말을 한다. 뭐지... 구글링해보니 설명이 복잡해서 더 헷갈린다.. 일단 더 알아봐야겠다. const li = event.target.parentNode; const span = document.createElement(&quot;span&quot;); span.innerHTML = event.target.value; li.replaceChild(span, event.target); // input을 span으로 교체함 다시. if (isLiInTodos(li)) { // 위에 있는 isLiInTodos 함수를 살펴보자. li의 부모가 #js_pending 이랑 일치하느냐 이다. 그렇다면 아래 함수가, 아니면 그 아래함수가 실행됨. updatePendingTask(li.id, span.innerHTML); } else { updateFinishedTask(li.id, span.innerHTML); } //update함수를 살펴보면 ul 안에 있는 li 중에 지금 수정하려는 li.id 랑 같으면 그 안에 있는 텍스트를 input.value로 교체하라는 뜻이다. saveState(); // 그리고 LS를 저장한다. buttonRestorer(li); // 그리고 버튼을 살려냄. 이 코드는 반복이 되어서 따로 refactoring을 하였다. } else if (event.key === &quot;Escape&quot;) { // 그게 아니고 esc를 누르면 아래코드가 실행된다. // 원래상태 그대로 복원시키는 것이다. event.target.lastKey = event.key; const li = event.target.parentNode; const span = document.createElement(&quot;span&quot;); span.innerHTML = event.target.name; li.replaceChild(span, event.target); buttonRestorer(li); }}4.esc, 커서 아웃그리고 focusout(커서를 input 밖에서 클릭할때) 일때 실행되는 코드는 esc눌렀을떄 실행되는 코드랑 같다.input.addEventListener(&quot;focusout&quot;, handleFocusOut);const handleFocusOut = (event) =&amp;gt; { if (event.target.lastKey === undefined) { // 커서가 바깥으로 가면 lastKey 가 undefined 되어버린다. 그럼 원상복귀다. const li = event.target.parentNode; const span = document.createElement(&quot;span&quot;); span.innerHTML = event.target.name; li.replaceChild(span, event.target); buttonRestorer(li); }};" }, { "title": "to do list - drag and drop(jquery)", "url": "/posts/vanila9/", "categories": "Javascript, todo-list", "tags": "drag and drop(jquery)", "date": "2020-12-16 00:00:00 +0900", "snippet": "list 위치 변경.기존에 내가 만든 to-do 리스트를 사용하다가 이번에 챌린지로 인해서 할일과 다 끝낸일을 추가했다. 그렇게 사용하다가 불편한게 있어서 몇가지 기능을 추가하려고 했다. 그 첫번째로 to-do 리스트의 순서를 변경하고 싶다는 것이었다. 그래서 구글에 찾아본결과 자바스크립트로 drag and drop 이벤트로 구현할 수 있긴 한데 너무 복잡해보였다. 그러던 도중 jquery 의 sortable 이란걸 발견했고 적용했다.jquery는 자바스크립트와는 다르게 html 상에 jquery source script를 추가하고 그밑에 또다시 sript 태그를 쓰고 안에다 jquery코드를 입력하는 방식이다. jquery UI 와 library 가 필요하다.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot; /&amp;gt; &amp;lt;title&amp;gt;JUST F**KING DO IT&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&quot;https://code.jquery.com/ui/1.12.1/jquery-ui.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; $(function () { $(&quot;#js_pending&quot;).sortable({ //옮기고 싶은 리스트를 id 로 명시하고 sortable 함수를 추가한다. axis: &quot;y&quot;, // y축 방향으로 옮긴다. revert: true, // 커서를 놓으면 부드럽게 옮겨진 위치로 리스트가 이동한다 scroll: true, placeholder: &quot;sortable-placeholder&quot;, // 옮겨질 위치에 임시로 무언가를 표시해준다. index.css에 sortable-placeholder {opacity:0.5} 로 설정해놓았다. start: function (event, ui) { console.log(ui.item.html()); ui.placeholder.html(ui.item.html()); // 그리고 선택한 아이템을 placeholder있는자리에 위치하도록 한다. }, }); $(&quot;#js_pending&quot;).disableSelection(); // 아이템안에서 선택을 못하게 하는 기능이라고 한다. }); &amp;lt;/script&amp;gt; &amp;lt;body&amp;gt; &amp;lt;section class=&quot;list&quot;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;PENDING&amp;lt;/h3&amp;gt; &amp;lt;ul id=&quot;js_pending&quot;&amp;gt;&amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h3&amp;gt;FINISHED&amp;lt;/h3&amp;gt; &amp;lt;ul id=&quot;js_finished&quot;&amp;gt;&amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;" }, { "title": "to do list - finished list 추가", "url": "/posts/vanila8/", "categories": "Javascript, todo-list", "tags": "투두리스트강화", "date": "2020-12-16 00:00:00 +0900", "snippet": "얽히고 섥힌 로직이번에 챌린지 하면서 풀었던 과제가 있다. PENDING(할일) 과 FINISHED(한일)을 구분하고 할일이 끝나면 한일로 이동하도록하고 또 한일에서 할일로 이동하도록 하며 새로고침해도 그대로 이어지도록 만들었다. 사실 내가 그렇게 되도록 코드를 짜봤는데 너무 복잡해서 미완성으로 남았었다. 그러다 , 다음날 니코가 올려준 코드를 보고 진짜 대단하다 싶어서 하나하나 로직의 연결고리, 문법을 다 이해하였고 내 TODO LIST에 적용했다. 로직의 순서를 살펴보자1.입력을 하면 입력한 값이 pending에 뿌려진다.2.그리고 LS(localstorage)에 저장된다.3.삭제, 끝냄 버튼을 만들고 그에 따른 함수를 추가한다.4.삭제버튼을 누르면 없어지고, 끝냄 버튼을 누르면 finished로 이동하면서 그와 관련된 LS정보또한 옮겨진다.5.finised에서 pending으로 옮겨질때도 마찬가지다.6.그리고 새로고침하면 LS값이 parsed 된다음 paint 함수에 의해 각자 알맞게 나타난다.그럼 1번부터 먼저 살펴보자1. pending에 뿌리기const pendingList = document.getElementById(&quot;js-pending&quot;), finishedList = document.getElementById(&quot;js-finished&quot;), form = document.getElementById(&quot;js-form&quot;), input = form.querySelector(&quot;input&quot;); //먼저 DOM 변수를 설정해준다.const PENDING = &quot;pedning&quot;;const FINISHED = &quot;finished&quot;;// LS에 저장될 KEY값을 설정함let pendingTasks, finishedTasks;//LS 의 VALUE 로 저장될 LIST 값인데 여기서 명확하게 명시안해주는 이유는 load함수 설명할때 알게된다.function init() { form.addEventListener(&quot;submit&quot;, handleFormSubmit); loadState(); restoreState();}init();//언제나 그렇듯이 init함수를 만들고 안에 몇가지 함수를 추가한다.먼저 handleFormSubmit 함수에 대해 알아보자.function getTaskObject(text) { return { id: String(Date.now()), // 기발한 아이디어 text, // 이렇게 설정해도 나중에 저장될떄는 text:text이런식으로 저장됨. };}function savePendingTask(task) { pendingTasks.push(task);}function handleFormSubmit(e) { e.preventDefault(); const taskObj = getTaskObject(input.value); //getTask 함수는 여기서 딱 한 번 쓰이기 때문에 따로 빼지 않아도 상관없는데 니코는 강조하기 위해 따로 빼둔것 같다 input.value = &quot;&quot;; paintPendingTask(taskObj); savePendingTask(taskObj); saveState();} // 그다음 pending에 뿌려주고 pendinglist에 값을 입력한다음 LS를 저장한다.그럼 paintPendingTask에 대해 알아보자.function removeFromPending(taskId) { pendingTasks = pendingTasks.filter(function (task) { return task.id !== taskId; });}function removeFromFinished(taskId) { finishedTasks = finishedTasks.filter(function (task) { return task.id !== taskId; });}// tasklist 중에 li.id가 아닌것만 찾아서 다시 list에 넣으라는 뜻function deleteTask(e) { const li = e.target.parentNode; li.parentNode.removeChild(li); removeFromFinished(li.id); removeFromPending(li.id); saveState();}function buildGenericLi(task) { const li = document.createElement(&quot;li&quot;); const span = document.createElement(&quot;span&quot;); const deleteBtn = document.createElement(&quot;button&quot;); span.innerText = task.text; deleteBtn.innerText = &quot;❌&quot;; deleteBtn.addEventListener(&quot;click&quot;, deleteTask); // li, span, 삭제 button을 만든다. 삭제버튼에는 함수를 추가하여 기능을 입힌다. li.append(span, deleteBtn); // 그리고 li에 span과 삭제버튼을 child로 입력함 li.id = task.id; // li id 도 설정해줌 return li; // 나중에 ul의 child로 넣어주기 위해 li을 return한다.}function paintPendingTask(task) { const genericLi = buildGenericLi(task); // buildGeneric 함수가 반복되기 때문에 refactoring을 해준것이다. const completeBtn = document.createElement(&quot;button&quot;); completeBtn.innerText = &quot;✅&quot;; //그리고 완료버튼에 기능을 추가한다. completeBtn.addEventListener(&quot;click&quot;, handleFinishClick); genericLi.append(completeBtn); pendingList.appendChild(genericLi); //그러고 ul에 genericli 를 추가함.}완료버튼에 대해 알아보자.2. 완료버튼 함수function findInPending(taskId) { return pendingTasks.find(function (task) { return task.id === taskId; });}function addToFinished(task) { finishedTasks.push(task);}function handleFinishClick(e) { const li = e.target.parentNode; li.parentNode.removeChild(li); // 일단 버튼 클릭된 li는 pending 화면에서 지우고 const task = findInPending(li.id); // 해당 list중에서 해당 li를 찾고 return해서 task에 할당함 removeFromPending(li.id); //pendinglist에서 지우고 addToFinished(task); // finishedlist 에 입력함 paintFinishedTask(task); // 그리고 해당 li를 다시 finished 화면에 입력함 saveState();}//P.S: find() 와 filter()의 차이. 조건과 일치한 결과를 딱 찾으면 바로 끝내느냐 아님 조건과 일치한 결과를 모두 찾아내느냐의 차이다. 따라서 find()는 결과값이 1개이고 filter()는 결과값이 2개이상일 수 있다.어디까지 했더라…아 init()함수에서 submit과 연결된 함수를 설명했었지. 그럼 이제 새로고침했을때도 나타나도록 load와 restore 함수에 대해서 알아보자.(로직이 복잡하다.)3. load와 restore 함수function loadState() { pendingTasks = JSON.parse(localStorage.getItem(PENDING)) || []; finishedTasks = JSON.parse(localStorage.getItem(FINISHED)) || [];} // Tasks는 LS에 저장된 PENDING인데 없을 경우 빈 list(array)를 할당한다. 조건부 할당이기 때문에 (&quot;||&quot; 때문에) 애초에 명시안해준것이다.function restoreState() { pendingTasks.forEach(function (task) { paintPendingTask(task); }); finishedTasks.forEach(function (task) { paintFinishedTask(task); });} // load에서 Tasks가 할당되었기 때문에 Tasks안에 있는 값들을 forEach 함수를 돌려 하나하나 손수 화면에 입력한다.paintFinished 함수에 대해 알아보자.function paintFinishedTask(task) { const genericLi = buildGenericLi(task); const backBtn = document.createElement(&quot;button&quot;); backBtn.innerText = &quot;⏪&quot;; backBtn.addEventListener(&quot;click&quot;, handleBackClick); genericLi.append(backBtn); finishedList.append(genericLi);} // pending과 동일한 로직이다. span,li,button(기능추가) 한다음 ul 의 child로 추가한다.반응형으로 만들어서 모바일에서도 사용가능하게 했다.@media screen and (max-width: 600px) { .list { grid-template-columns: repeat(1, 1fr); gap: 0; }}P.S: 로직이 복잡해서 어떻게 하면 쉽게 이해할 수 있을까 연구하다가 그림을 그리고 그걸 눈앞에서 배열하면 더 확실하게 다가오지 않을까 하는 마음에서 종이를 자르고 함수를 그려 배열해보았다. 좀더 쉽게 와닿았느냐? 딱히 그런것 같지도 않다 ㅋㅋLOGIC" }, { "title": "좀 더 세련된 계산기 코드(shout out to Nico💪)", "url": "/posts/miniProject2/", "categories": "Javascript, mini-project", "tags": "advanced calulator", "date": "2020-12-16 00:00:00 +0900", "snippet": "좀더 세련된 계산기 코드고생고생해서 계산기를 완성했고 다행히 제시간내에 제출했다. 그리고 다음날 니코의 정답이 나왔는데 역시나 굉장히 깔끔하고 참신하며 예술적이기 까지 했다. 우선 html 부터 보자.&amp;lt;body&amp;gt; &amp;lt;span class=&quot;js-result result&quot;&amp;gt;0&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-reset reset&quot;&amp;gt;C&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-number&quot;&amp;gt;7&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-number&quot;&amp;gt;8&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-number&quot;&amp;gt;9&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-operation operation&quot;&amp;gt;+&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-number&quot;&amp;gt;4&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-number&quot;&amp;gt;5&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-number&quot;&amp;gt;6&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-operation operation&quot;&amp;gt;-&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-number&quot;&amp;gt;1&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-number&quot;&amp;gt;2&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-number&quot;&amp;gt;3&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-operation operation&quot;&amp;gt;*&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-number zero&quot;&amp;gt;0&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-equals&quot;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;js-operation operation&quot;&amp;gt;/&amp;lt;/span&amp;gt; &amp;lt;script src=&quot;src/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;span만 사용했고 class로 번호는 번호끼리 연산자는 연산자끼리 묶었다.계산기 로직array와 queryselectorAll을 통해서 같은 class를 semi array로 만들 수 있었고 그걸 foreach로 풀어낸다.로직 순서를 설명해보면1. 웹브라우저를 처음 켜고 숫자를 최초로 입력하면 firstDone이 true가 되면서 입력되는 족족 값이 쌓이고 firstValue에 할당2. 그다음 연산자를 누르면 secondDone이 없기 때문에 아무일도 일어나지 않음 그리고 그 연산자는 currentOpearation에 할당됨3. 그리고 다시 숫자를 누르면 그 숫자는 secondValue에 할당되고 secondDone은 true가 됨.4. 그 뒤에 연산자를 다시 클릭하면 calculate함수가 실행됨5. calculate 함수 안에 doOperation 함수에 의해서 “fisrtValue 연산자 secondValue” 의 수식이 만들어지고 계산이 됨.6. 결과값이 창에 띄어지며, 동시에 firstValue에 할당이 되고 secondDone 은 false가 되면 secondValue는 ““로 바뀜.7. 그 뒤에 다시 연산자를 클릭하면 4번의 순서로 돌아가면서 반복된다.어떻게 이런 로직을 짤 수 가 있는지 진짜 참신하다. 정말 대단하다는 말 밖에 안나온다. 진짜 기막힌 로직을 배운것 같아서 매우 기분 좋다.const result = document.querySelector(&quot;.js-result&quot;);const reset = document.querySelector(&quot;.js-reset&quot;);const equals = document.querySelector(&quot;.js-equals&quot;);const numbers = Array.from(document.querySelectorAll(&quot;.js-number&quot;));const operations = Array.from(document.querySelectorAll(&quot;.js-operation&quot;));let firstValue = &quot;&quot;, firstDone, secondValue = &quot;&quot;, secondDone, currentOperation;numbers.forEach(function (number) { number.addEventListener(&quot;click&quot;, handleNumberClick);});operations.forEach(function (operation) { operation.addEventListener(&quot;click&quot;, handleOperationClick);});reset.addEventListener(&quot;click&quot;, handleReset);equals.addEventListener(&quot;click&quot;, handleEqualsClick);이렇게 틀을 만들어주고 함수를 만들자.함수 만들기function doOperation() { console.log(firstValue, secondValue); console.log(typeof firstValue, typeof secondValue); const intValueA = parseInt(firstValue, 10); const intValueB = parseInt(secondValue, 10); switch (currentOperation) { // 첫번째 숫자를 입력후 연산자를 클릭했을시 그 연산자는 currentOperation 전연변수에 저장됨. 그 저장된걸 꺼내씀 case &quot;+&quot;: return intValueA + intValueB; case &quot;-&quot;: return intValueA - intValueB; case &quot;/&quot;: return intValueA / intValueB; case &quot;*&quot;: return intValueA * intValueB; default: return; // switch 함수에 의해 깔끔하게 계산됨 // 다시 calculate함수로 돌아감 }}function handleNumberClick(e) { const clickedNum = e.target.innerText; if (!firstDone) { firstValue = firstValue + clickedNum; result.innerHTML = firstValue; // 최초 숫자 입력시 활성화 } else { secondValue = secondValue + clickedNum; result.innerHTML = secondValue; secondDone = true; console.log(secondValue); // 그 이후론 줄곧 second 쪽만 활성화됨 }}function calculate() { const operation = doOperation(); // 본격적인 계산이 들어감 console.log(firstDone); result.innerHTML = operation; // 결과값이 화면에 띄어짐 firstValue = operation; secondDone = false; secondValue = &quot;&quot;; // second 가 비활성화 초기화됨}function handleOperationClick(e) { const clickedOperation = e.target.innerText; if (!firstDone) { console.log(firstDone); firstDone = true; //최초 계산시 활성화 } if (firstDone &amp;amp;&amp;amp; secondDone) { calculate(); // 연산자를 입력하고 두번째 숫자를 입력한 그다음 연산자를 클릭했을때 활성화됨 } currentOperation = clickedOperation; // 첫번째 숫자를 입력하고 연산자를 클릭했을시 활성화}equal/reset 함수 만들기간단하다. equal함수는 계산하면되고 reset함수는 모든것을 초기화/비활성화 시킨다.function handleReset() { firstValue = &quot;&quot;; secondValue = &quot;&quot;; firstDone = false; secondDone = false; currentOperation = null; result.innerHTML = &quot;0&quot;;}function handleEqualsClick() { if (firstDone &amp;amp;&amp;amp; secondDone) { calculate(); }}정말 다시 생각해봐도 기분좋을 정도로 예술적이다. 또 배웠다! Thanks a bunch Nico!" }, { "title": "그 유명한 계산기 한 번 만들어보기", "url": "/posts/miniProject1/", "categories": "Javascript, mini-project", "tags": "eval", "date": "2020-12-16 00:00:00 +0900", "snippet": "계산기 만들기.챌린지 과제중에 계산기 만들기 과제가 있었다. 숫자를 누를때마다 화면에 출력되어야 하고 연산자를 누를때마다 계산되어야 하며 그 결과 값이 바로바로 화면에 출력되어야한다.js로 계산기 만드는 방법은 쉽게 구글링 할 수 있었지만 오로지 내 스스로의 능력으로 만들어보고 싶었다. 예상대로 고통스러웠지만 결국에는 해내는 나를 보면서 참 자랑스러웠다. 우선 html 부터 만들어주자.&amp;lt;body&amp;gt; &amp;lt;form&amp;gt; &amp;lt;div&amp;gt; &amp;lt;span class=&quot;big&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;small&quot;&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;button value=&quot;undo&quot; id=&quot;undo&quot;&amp;gt;C&amp;lt;/button&amp;gt; &amp;lt;button value=&quot;1&quot; id=&quot;one&quot;&amp;gt;1&amp;lt;/button&amp;gt; &amp;lt;button value=&quot;2&quot; id=&quot;two&quot;&amp;gt;2&amp;lt;/button&amp;gt; &amp;lt;button value=&quot;3&quot; id=&quot;three&quot;&amp;gt;3&amp;lt;/button&amp;gt; &amp;lt;button value=&quot;4&quot; id=&quot;four&quot;&amp;gt;4&amp;lt;/button&amp;gt; &amp;lt;button value=&quot;5&quot; id=&quot;five&quot;&amp;gt;5&amp;lt;/button&amp;gt; &amp;lt;button value=&quot;6&quot; id=&quot;six&quot;&amp;gt;6&amp;lt;/button&amp;gt; &amp;lt;button value=&quot;7&quot; id=&quot;seven&quot;&amp;gt;7&amp;lt;/button&amp;gt; &amp;lt;button value=&quot;8&quot; id=&quot;eight&quot;&amp;gt;8&amp;lt;/button&amp;gt; &amp;lt;button value=&quot;9&quot; id=&quot;nine&quot;&amp;gt;9&amp;lt;/button&amp;gt; &amp;lt;button value=&quot;0&quot; id=&quot;zero&quot;&amp;gt;0&amp;lt;/button&amp;gt; &amp;lt;button value=&quot;=&quot; id=&quot;equal&quot;&amp;gt;=&amp;lt;/button&amp;gt; &amp;lt;button value=&quot;+&quot; id=&quot;plus&quot;&amp;gt;+&amp;lt;/button&amp;gt; &amp;lt;button value=&quot;-&quot; id=&quot;minus&quot;&amp;gt;-&amp;lt;/button&amp;gt; &amp;lt;button value=&quot;*&quot; id=&quot;multiple&quot;&amp;gt;*&amp;lt;/button&amp;gt; &amp;lt;button value=&quot;/&quot; id=&quot;divide&quot;&amp;gt;/&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;script src=&quot;src/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;그리고 각각의 버튼을 클릭했을때 값이 입력되는걸로 대충 로직을 짰다. 로직 순서는 이렇게 생각했다. 입력값을 한곳에 모으기(i.e 1112 ) 리스트를 쓰튼 localstrage를 쓰든. 그리고 모은 값을 가져와서 span에 display하기. 연산자를 클릭하면 모은값을 가져다가 연산자 함수에 pass 해서 계산 하고 display한다음, return으로 저장. result 를 리스트안에 저장하지 말고 span값을 가져다가 바로 계산해서 display하면 된다. = 을 누르면 최종값을 가져다가 span에 display함. c 누르면 값이 없어지고 return으로 함수 종료.const form = document.querySelector(&quot;form&quot;), span = form.querySelector(&quot;.big&quot;), spanSmall = form.querySelector(&quot;.small&quot;), undo = document.getElementById(&quot;undo&quot;), one = document.getElementById(&quot;one&quot;), two = document.getElementById(&quot;two&quot;), three = document.getElementById(&quot;three&quot;), four = document.getElementById(&quot;four&quot;), five = document.getElementById(&quot;five&quot;), six = document.getElementById(&quot;six&quot;), seven = document.getElementById(&quot;seven&quot;), eight = document.getElementById(&quot;eight&quot;), nine = document.getElementById(&quot;nine&quot;), zero = document.getElementById(&quot;zero&quot;), equal = document.getElementById(&quot;equal&quot;), plus = document.getElementById(&quot;plus&quot;), minus = document.getElementById(&quot;minus&quot;), multiple = document.getElementById(&quot;multiple&quot;), divide = document.getElementById(&quot;divide&quot;);let spanContainer = [];let smallContainer = [];undo.addEventListener(&quot;click&quot;, undoFunc);one.addEventListener(&quot;click&quot;, display);two.addEventListener(&quot;click&quot;, display);three.addEventListener(&quot;click&quot;, display);four.addEventListener(&quot;click&quot;, display);five.addEventListener(&quot;click&quot;, display);six.addEventListener(&quot;click&quot;, display);seven.addEventListener(&quot;click&quot;, display);eight.addEventListener(&quot;click&quot;, display);nine.addEventListener(&quot;click&quot;, display);zero.addEventListener(&quot;click&quot;, display);equal.addEventListener(&quot;click&quot;, equalFunc);plus.addEventListener(&quot;click&quot;, plusFunc);minus.addEventListener(&quot;click&quot;, minusFunc);multiple.addEventListener(&quot;click&quot;, mutipleFunc);divide.addEventListener(&quot;click&quot;, divideFunc);// 우선 이렇게 대략적인 틀을 만들었다. 그러고 함수를 추가하면 된다.1. 각 버튼에 함수 추가우선 숫자를 누를때마다 실행되는 함수부터 만들어주자.function display(event) { event.preventDefault(); let value = event.target.value; spanContainer.push(value); smallContainer.push(value); //입력하는 족족 array에 넣어준다. var spanResult = &quot;&quot;; var spanSmallResult = &quot;&quot;; for (var i = 0; i &amp;lt; spanContainer.length; i++) { spanResult += spanContainer[i]; } span.innerHTML = spanResult; for (var i = 0; i &amp;lt; smallContainer.length; i++) { spanSmallResult += smallContainer[i]; } spanSmall.innerHTML = spanSmallResult; // 그리고 array에 넣은 값을 for 문을 통해서 이어붙인다음 화면에 띄어준다.}2. 연산자 함수 만들기여기서 참 고생했다. 연산자를 클릭할때마다 결과값이 나와야하는데 그 로직을 어떻게 짜야할지 머리가 터질 지경이었다. 처음엔 for 문을 써서 하려고 했는데 실패했다. 그렇게 검색하다가 우연히 eval() 이란 함수를 발견했다. 적혀있는데로 수식을 계산한다음 결과를 내놓는 함수였다. 치트키같은 함수다.// + 연산자 함수만 일단 써봤다. 나머지 연산자도 다 같기 때문에.function plusFunc(event) { event.preventDefault(); const plusVal = spanSmall.innerHTML; try { const plusResult = eval(plusVal); //spansmall에 숫자와 연산자가 이미 적혀있는데 그것을 그대로 불러온것이다. 그 수식을 eval에 pass 했다. console.log(plusResult); span.innerHTML = plusResult; // 그리고 결과값을 span에 띄어주고 spanContainer = []; // main display는 빈칸으로 만들어준다. } catch (error) { //pass } let val = event.target.value; spanSmall.innerHTML = spanSmall.innerHTML + val; // 그리고 수식을 이어붙여 계산 display 에 띄어준다. smallContainer.push(val); //display 함수를 위해 smallcontainer에 입력된수식을 push한다.}3. undo/equal 함수 만들기undo/equal 함수는 쉽다. equal은 smallspan 값을 계산하기만 하면 되고 undo는 모든 값을 초기화 하면 된다.function equalFunc(evnet) { evnet.preventDefault(); const finalVal = spanSmall.innerHTML; const finalResult = eval(finalVal); span.innerHTML = finalResult;}function undoFunc(event) { event.preventDefault(); span.innerHTML = 0; spanSmall.innerHTML = 0; spanContainer = []; smallContainer = [];}계산기 결과물" }, { "title": "다양한 에러와 해결책 정리", "url": "/posts/debug/", "categories": "GitHub Blog, blog guide", "tags": "blogging", "date": "2020-12-15 00:00:00 +0900", "snippet": " 기본적으로 에러가 났을때는 bundle exec jekyll server 를 통해 로컬사이트에 접속해보자. 그럼 명령프롬프트에서 에러가 왜 났는지 알려줄것이다.1. NOT FOUND 에러(검사를 잘 활용하자)우선 블로그 만들면서 만났단 버그가 있다. 바로 not found 에러이다. 아래 그림처럼 favicon1번 그림이 깨져서 나왔다. 이때 깨진 그림에 커서를 올리고 오른쪽 마우스를 클릭해서 검사를 누른다. 그리고 검사메뉴에 console에 들어가면 현재 이 웹사이트에서 발생하는 오류를 볼 수 있다.그러고 “name not resolved element” 라고 뜬다. ‘이름(경로?)을 분석할 수 없다’ 정도로 이해하자. 그리고 구글에 검색해봐도 되는데, 내 생각에는 경로가 올바르지 않은 것 같다고 생각했다.그래서 element 메뉴로 들어가보자. 그럼 이 그림에 해당하는 코드, 링크가 나온다. 이 링크를 복사해서 웹사이트에 검색하면 역시나 찾을 수 없는 웹페이지라고 뜬다.그래서 블로그 리파지토리에 들어가서 해당 그림을 클릭해보았다. 그러자 아래와 같은 그림처럼 경로가 뜬다assets 앞에 YeonghunKO.github.io를 입력해줘야 했던거다. 이때 다시 element를 들어가 링크쪽을 더블클릭하면 임시로 그 코드를 바꿀 수 있다. 그래서 YeonghunKO.github.io을 assets에 추가하니 그림이 뜬다!그러고 에디터툴로 해당 링크를 수정해주니 잘 작동한다!따라서 버그가 발생하면 우선 검사-console로 들어가 버그의 이유를 알아낸다. 그게 시작이다.2. Jekyll 서버2-1. 특수문자 에러마크다운 문법으로 글을 작성하고 로컬홈페이지로 들어가서 확인하려 하는데 터미널에 이런 에러가 떴다.“did not find expected key while parsing a block mapping at~”그럼 해당 라인에 특수문자때문일 확률이 높다. 따라서 세미콜론, 중괄호 같은 특수문자를 없애주자.2-2. 띄어쓰기 에러이 에러는 : 뒤에 띄어쓰기 를 안해서 생긴 에러다.3. 사이트가 깨져 보인다. 사이트에 메뉴나 글꼴, 그림이 전부 나타나지 않고 글만 나타나는 경우였다. 이유는 config 파일안에 baseurl을 잘못 설정했기 때문이었다. 그냥 공란으로 두자.baseurl: &quot;&quot; 레포 이름을 username으로 안바꿔줘서 그런것일 수 있다.4. 터미널 경로 에러예를들어, C: 드라이브 안에 A폴더가 있고 그 안에 B폴더가 있다고 하자. 그래서 cd..\\A를 입력하고 그다음 cd..\\B를 입력했는데 “지정된 경로를 찾을 수 없습니다.” 라고 에러가 떴다.이때는 C: 드라이브에서 한번에 경로를 입력하자.cd..\\A\\B5. 링크가 작동안됨&amp;lt;/br&amp;gt;이것도 로컬서버를 돌리던 도중에 명령프롬프트에서 발견했다. 어떤 글에서든지 상관없이 중괄호가 2개가 겹쳐있을경우 about me의 프로젝트 링크가 작동하지 않는 다는 것을 발견했다." }, { "title": "깃헙블로그 시작하기!!", "url": "/posts/blog-start/", "categories": "GitHub Blog, blog guide", "tags": "blogging", "date": "2020-12-15 00:00:00 +0900", "snippet": "깃헙블로그 글올리기깃헙블로그 ?개발자라면 , 개발자를 준비하고 있는 사람이라면 깃헙블로그 하나쯤은 갖고 있는것이 좋다. 그 이유는 그 블로그에 기록된 것을 보고 이 개발자의 능력, 성향, 습득한 기술을 파악하는 문화가 있기 때문이다. 그래서 주저리주저리 자소서를 쓰지 않고 블로그 링크하나 보낸다. 또한, 개발자라면 기록하는 습관은 기본이다. 그리고 유용한 정보를 다른 사람과 공유함 으로써 시너지 효과를 일으키는 것도 정말 중요하다.따라서 이 블로그는 오늘 배운것, 고쳐야 할 것, 자잘한 일상을 기록하고, 앞으로 필요할때마다 도서관 처럼 꺼내쓰는 공간일 뿐만 아니라 다른 개발자와 소통하는 공간이기도 하다.또한 깃헙블로그를 만드므로써 깃헙과 마크다운문법을 자연스럽게 익힐 수 있으니 일석 이조라고 할 수 있다. 그럼 깃헙블로그를 만드는 방법을 살펴보자!1. 자신의 깃헙블로그에 리파지토리를 만들기이때 중요한것은 깃헙의 리파지토리 이름이 자신의 username을 차용해야한다. 아니면 404found 페이지가 뜰 수 있다. ex) username.github.io2. 테마를 포크함Jekyll에 있는 테마를 가져온다. 그중에 가장 깃헙시스템을 잘 체험할 수 있는 minimal mistakes를 사용했었는데 검색과 카테고리가 아쉬워서 chirpy로 바꾸었다.아래 링크로 들어가보자!" }, { "title": "깃헙포스트 게시글 마크다운 작성 가이드 1", "url": "/posts/styleguide/", "categories": "GitHub Blog, blog guide", "tags": "blogging, markdown", "date": "2020-12-14 00:00:00 +0900", "snippet": "Heading levels This is a fixture to test heading levelsHeadingThis is an h1 headingSub-headingThis is an h2 headingSub-sub-headingThis is an h3 headingHeadingThis is an h1 headingSub-headingThis is an h2 headingSub-sub-headingThis is an h3 headingHeadingThis is an h1 headingSub-headingThis is an h2 headingSub-sub-headingThis is an h3 heading마크다운으로 toc 구현 첫 번째 두 번째 세 번째 첫 번째This is an h1 heading두 번째This is an h2 heading세 번째This is an h2 heading Coursera python #괄호안에를 소문자로 해야적용됨. 대문자로 하면 링크가 작동 하지 않음.#Coursera pythonCoursera python그냥 시범삼아. devlopr jekyll - Styleguide 이탈릭체, 굵은 글씨체, 줄바꿈(space버튼 2번)이탈릭에서 여기만 굵은글씨 다시 돌아옴굵은글씨로 시작해서이탈릭으로 돌아왔다가 다시 굵어짐너의 이름은.파아워어레인저!==============Blockquote this is h1! list textbox#list 뒤에 tab을 입력하니 hierarchy가 생김. 이글을 쓰는 도중에 나는 아무생각이 없다.&amp;lt;/br&amp;gt; 그냥 글을 두줄로 나눠야 한다는 생각뿐이다.이 글도 마찬가지다 그냥 글을 두줄로 br 말고 \\ 로 나눈다. 여기부터는 두번째 문장이다 나뉘어져 있다. \\ 를 입력하고 엔터를 누르면 나뉜다.그리고 글자에 색깔을 입력하는 방법이다. \\textcolor{red}{red}table Syntax Description Header Title Paragraph Text Tickbox Write the press release Update the website Contact the mediaThe world is flat. Lets try the different text styles Bold , Strong , Emphasis , Italic Now, lets try different heading styles : Hello in h1 ! Hello in h2 ! Hello in h3 ! Hello in h4 ! Hello in h5 ! Hello in h6 ! Unordered List List Item 1 List Item 2 List Item 3 List Item 4 List Item 5 Ordered List List Item 1 List Item 2 List Item 3 List Item 4 List Item 5 This is a Block Quote, It can Expand Multiple Lines You can use the mark tag to highlight text. This line of text is meant to be deleted text This line of text will render as underlinedThis line of text is meant to be treated as fine print.This line rendered as bold text.This line rendered as italicized text.attrHTML # Heading Heading Heading Heading Heading Heading Heading Heading Heading 1 Cell Cell Cell Cell Cell Cell Cell Cell Cell 2 Cell Cell Cell Cell Cell Cell Cell Cell Cell 3 Cell Cell Cell Cell Cell Cell Cell Cell Cell YouTube Responsive EmbedVimeo Responsive EmbedTED Responsive EmbedTwitch Responsive EmbedSoundCloud EmbedCodePen EmbedSyntax Highlighting&#39;use strict&#39;;var markdown = require(&#39;markdown&#39;).markdown;function Editor(input, preview) { this.update = function() { preview.innerHTML = markdown.toHTML(input.value); }; input.editor = this; this.update();}You can add inline code just like this, E.g. .code { color: #fff; }pre { background-color: #f4f4f4; max-width: 100%; overflow: auto;}GitHub gist EmbedInput Style Twitter Embed I just published “Deploying a blog using Jekyll and Github Pages with SSL certificate for Free” https://t.co/B3T3IQVU93&amp;mdash; Sujay Kundu (@SujayKundu777) June 29, 2018 Instagram Embed A post shared by Ahmad Ajmi (@ahmadajme) on Apr 2, 2018 at 2:18pm PDT" }, { "title": "[개발자 블로그] Chirpy테마 게시글 작성 가이드", "url": "/posts/chirpy-theme/", "categories": "GitHub Blog, blog guide", "tags": "blogging", "date": "2020-12-13 00:00:00 +0900", "snippet": "첫글로 Writting New Post페이지를 번역해보았다.Naming &amp;amp; PathYYYY-MM-DD-TITLE.EXTENSION 의 형식으로 새 파일을 만들어주고 _post/ 폴더에 넣어준다.EXTENSION은 md 혹은 markdown으로 해주어야한다.Front Matter기본적으로, 글을 작성할 때 아래와 같은 양식의 Front Matter를 작성해야 한다.---title: TITLEdate: YYYY-MM-DD HH:MM:SS +/- TTTTcategories: [TOP_CATEGORIE, SUB_CATEGORIE]tags: [TAG] # TAG는 반드시 소문자로 이루어져야함!--- Note: post의 layout이 기본적으로 post으로 설정되어있어서 Front Matter에 따로 layout변수를 만들어 주지 않아도 된다.Timezone of date더 정확한 시간을 포스트에 제공하기 위해서는 _config.yml의 timezone만 설정해줄 것이 아니라, Post FrontMatter에서 date필드에도 post timezone을 제공해주어야한다.형식: +/-TTTT, e.g. +0800.Categories &amp;amp; Tag각 포스트의 categories는 2개의 요소로 구성되어있으며 tags는 0~무한 개의 요소를 가질 수 있다.categories: [Animal, Insect]tags: [bee]Table of Contents기본적으로, Table of Contents(TOC)는 포스트의 오른쪽 패널에 위치한다. 만약 너가 이 기능을 끄고싶다면 _config.yml파일로가서 toc값을 false로 바꾸어주면된다. 하나의 포스트에만 이 기능을 끄고싶다면 FrontMatter에서 toc값을 false로 바꾸면된다:---toc: false---CommentsTOC와 비슷하게 Disqus comments가 각 포스트마다 기본적으로 내장되어있으며, 모든 글에대한 comments유무는 _config.yml파일의 comments값에 의해 결정된다. 하나의 포스트에만 이 기능을 끄고 싶다면 FrontMatter에서 값을 설정해주면된다:---comments: false---Mathematics웹페이지의 성능적인 이유에서 mathematical 기능은 기본적으로 꺼져있으나 아래 코드를 추가하여 켤 수 있다:---math: true---MermaidMermaid는 훌륭한 표생성 도구이다. 아래코드를 추가함으로 기능을 켤 수 있다.---mermaid: true---그러면 너는 ```mermaid로 그래프 코드를 감싸 다른 마크다운 언어와 같이 사용할 수 있다.ImagesPreview image포스트의 최상단에 이미지를 넣고싶다면 아래와 같이 url을 추가하여 이미지를 넣을 수 있다:---image: /path/to/image-file---Image caption이미지를 삽입한 다음 라인에 아래와 같이 Italics를 추가해서 이미지 캡션을 달 수 있다. 이미지 캡션은 이미지의 하단에 달린다:![img-description](/path/to/image)_Image Caption_Image sizewidth를 아래와같이 추가하여 이미지 사이즈를 설정할 수 있다.![image-description](path){: width=&quot;400px&quot;}기본적으로 이미지의 위지는 centered이다. 아래 3가지 방법으로 이미지의 위치를 normal, left, right중 하나로 설정할 수 있다: Normal ![Desktop View](/assets/img/sample/mockup.png){: width=&quot;350&quot; class=&quot;normal&quot;} Left ![Desktop View](/assets/img/sample/mockup.png){: width=&quot;350&quot; class=&quot;left&quot;} Right ![Desktop View](/assets/img/sample/mockup.png){: width=&quot;350&quot; class=&quot;right&quot;} 너가 이미지의 위치를 정하게되면 image caption은 달 수 없게된다.Pinned Posts너의 홈페이지 메인화면에 특정 게시물을 고정시킬 수 있다. 순서는 포스팅 날짜가 최근일수록 위로 올라오게된다.---pin: true---Code Block마크다운 문법 ``` 를 통해 쉽게 코드블럭을 생성할 수 있다.This is a common code snippet, without syntax highlight and line number.Specific Language```language를 통해 line number 와 syntax highlight를 갖는 코드블럭을 생성할 수 있다. Note: The Jekyll style {% highlight LANGUAGE %} or {% highlight LANGUAGE linenos %} are not allowed to be used in this theme !items: - part_no: A4786 descrip: Water Bucket (Filled) price: 1.47 quantity: 4Liguid Codes만약 Liquid snippet(수도코드?)를 배치하고싶다면 liquid code를 {% raw %}와 {% endraw %}로 감싸주면된다.{% if product.title contains &#39;Pack&#39; %} This product&#39;s title contains the word Pack.{% endif %}Learn More더 많은걸 알고싶다면, 여기로Jekyll Docs:Posts." }, { "title": "GET VS POST", "url": "/posts/html2/", "categories": "HTML, network", "tags": "get, post", "date": "2020-10-22 00:00:00 +0900", "snippet": "1. GET 과 POST의 차이클라이언트(유저, 브라우저)와 서버간에 정보를 주고받는 과정을 HTTP(The Hyper Transfer Protocol) 가 가능하게 해준다. 이때 클라이언트가 요청한 정보를 보내는 방식(METHOD)에 여러가지가 있는다 가장 대표적인 것 두가지가 GET 이랑 POST 이다.GETGET은 query string같이 url 같은 정보를 보낼때 사용되는 method이다. history에 저장되고 길이 제한이 있으며 정보를 불러들이기만 할뿐 수정하지는 못한다.HTML 안에서 사용되는 방법은 대략적으로 아래와 같다.&amp;lt;form action=&quot;서버로 전송한 데이터를 수신할 URL&quot; method=&quot;데이터를 전송하는 방법&quot;&amp;gt; 텍스트 필드, 라디오 버튼, 체크 박스와 같은 컨트롤을 생성하는 태그&amp;lt;/form&amp;gt;만약에 아래와 같은 html 코드가 있다고 하면&amp;lt;form action=&quot;/report&quot; method=&quot;GET&quot;&amp;gt; &amp;lt;input placeholder=&quot;what job do you want?&quot; required name=&quot;word&quot; /&amp;gt; &amp;lt;button&amp;gt;Search&amp;lt;/button&amp;gt;&amp;lt;/form&amp;gt;input 에 정보를 입력하고 버튼을 눌렀을때 그 정보를 “baseurl/report?word=input info” 의 url에 정보를 담아서 server에 전송한다. 사용자의 정보가 이런식으로 노출되기에 민감한 정보일경우는 POST 방식으로 전송한다.그리고 이 url은 permalink(고유한 주소체계) 로 사용가능하다.html_tutorials?nickname=yeong&amp;amp;age=12 라는 url 이 있다고 하면 ?뒤에 붙어있는 부연정보가 perlink 로 사용이 가능한것이다.(또한 permalink 는 &amp;amp; 로 구분가능하다.) 그럼 그 permalink 에 의해 나만의 정보가 담긴 고유의 url이 탄생가능하다.POSTPOST는 정보를 서버에 보내어 어떤 자료를 업데이트하거나 만들어낼때 사용되는 method이다. GET 처럼 URL 에 정보가 표시되지는 않는다. 개발자 도구에 NETWORK 탭에 HEADERS 안에 BODY의 형태로 담겨 표시가 된다. 따라서 노출되지 않으므로 보안상 더 안전하다.아래의 예제를 통해 더 자세히 알아보자&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;ko&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt; &amp;lt;title&amp;gt;HTML&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; * { font-size: 16px; font-family: Consolas, sans-serif; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form method=&quot;post&quot; action=&quot;form-action.php&quot;&amp;gt; &amp;lt;p&amp;gt; &amp;lt;label&amp;gt;Input Color : &amp;lt;input type=&quot;text&quot; name=&quot;color&quot; /&amp;gt;&amp;lt;/label&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;&amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;여기서 input에 blue를 입력했다고 했을때 /form-action.php 파일로 정보가 숨겨진채 전송됨. 아래는 php파일이다&amp;lt;?php $color = $_POST[&#39;color&#39;]; ?&amp;gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;ko&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt; &amp;lt;title&amp;gt;HTML&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; * { font-size: 16px; font-family: Consolas, sans-serif; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Submitted&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt; Your color is &amp;lt;?php echo $color ?&amp;gt;. &amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;그럼 화면엔SubmittedYour color is blue.라고 뜨게 되는 것이다.출처: https://devbox.tistory.com/entry/HTML5-a-태그 [장인개발자를 꿈꾸는 :: 기록하는 공간] //https://www.codingfactory.net/11576" }, { "title": "DIV vs SPAN", "url": "/posts/html1/", "categories": "HTML, basic(html)", "tags": "div, block", "date": "2020-10-22 00:00:00 +0900", "snippet": "1. DIV 와 SPANdiv 태그는 display:block 과 같은 성질을 가진다. 그래서 블럭을 쌓듯이 위로 포개지는 속성을 가지며 width, height 값에 영향을 받는다.반면 span 태그는 display: inline 과 같은 성질을 가지며 옆으로 또는 위아래로 다닥다닥 붙는 속성을 가지고 있다. 그리고 width, height의 영향을 받지 않고 그 안에 담겨있는 내용에 따라 크기가 달라진다.아래 html 과 css를 보면서 좀더 직관적으로 이해해보자.2. html, css 코드&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&amp;gt; &amp;lt;title&amp;gt;test&amp;lt;/title&amp;gt; &amp;lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div&amp;gt;div는 block 임돠&amp;lt;/div&amp;gt; &amp;amp;nbsp; &amp;lt;!-- 빈칸을 나타내는 코드 --&amp;gt; &amp;lt;div&amp;gt;div는 block 임돠&amp;lt;/div&amp;gt; &amp;amp;nbsp; &amp;lt;div&amp;gt;div는 block 임돠&amp;lt;/div&amp;gt; &amp;amp;nbsp; &amp;lt;br /&amp;gt; &amp;lt;span&amp;gt;span은 inline 임돠&amp;lt;/span&amp;gt;&amp;amp;nbsp; &amp;lt;span&amp;gt;span은 inline 임돠&amp;lt;/span&amp;gt;&amp;amp;nbsp; &amp;lt;span&amp;gt;span은 inline 임돠&amp;lt;/span&amp;gt;&amp;amp;nbsp; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;div { background: skyblue; width: 300px; height: 30px;}span { background: pink; width: 300px; height: 30px;}보면 div 태그는 위아래로 쌓이면서 넓이 높이 가 적용되었지만 span은 옆으로 쌓이면서 넓이 높이는 안에 있는 text 내용에 한정된 것을 볼 수 있다.그러나 span도 block형태로 변경가능하다 바로 display: block 을 추가해주면 된다.또는 block 과 inline 의 속성을 둘다 가지고 가고 싶다 하면.display: inline-block 이라고 하면 된다." }, { "title": "http://donicaida.com", "url": "/posts/clone4/", "categories": "CSS, clone", "tags": "extend", "date": "2020-10-13 00:00:00 +0900", "snippet": "http://donicaida.com/ 클론 코딩이번에 클론할 웹은 사실 그렇게 어렵지는 않다. 그러나 나중에 python scapper 웹을 꾸밀때 이런 grid 가 있으면 좋을 것 같아서 포스팅한다.그리고 여기 content는 li 가 아닌 span에 담았다.&amp;lt;body&amp;gt; &amp;lt;header&amp;gt; &amp;lt;h1&amp;gt; Donica Ida is an art director and designer working in editorial, identity, and digital design. &amp;lt;/h1&amp;gt; &amp;lt;/header&amp;gt; &amp;lt;div class=&quot;works&quot;&amp;gt; &amp;lt;div class=&quot;works_header&quot;&amp;gt; &amp;lt;span&amp;gt;Year&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;Client&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;Info&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;ul class=&quot;works_list&quot;&amp;gt; &amp;lt;li class=&quot;works_work&quot;&amp;gt; &amp;lt;span&amp;gt;2019&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;Huffpost Highline&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;Investigative journalism meets digital storytelling.&amp;lt;/span&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li class=&quot;works_work&quot;&amp;gt; &amp;lt;span&amp;gt;2019&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;Huffpost Highline&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;Investigative journalism meets digital storytelling.&amp;lt;/span&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li class=&quot;works_work&quot;&amp;gt; &amp;lt;span&amp;gt;2019&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;Huffpost Highline&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;Investigative journalism meets digital storytelling.&amp;lt;/span&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;cv&quot;&amp;gt; &amp;lt;span&amp;gt;Education&amp;lt;/span&amp;gt; MFA Design Entrepreneurship, School of Visual Arts; BFA Visual Communication Design, University of Washington. &amp;lt;span&amp;gt;Formerly at&amp;lt;/span&amp;gt; HuffPost Highline, Mary Review, Critical Mass, Pentagram. &amp;lt;span&amp;gt;Select clients&amp;lt;/span&amp;gt; Airbnb, Condé Nast Traveler, Google, Planned Parenthood. &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;about&quot;&amp;gt; &amp;lt;span&amp;gt;About&amp;lt;/span&amp;gt; Donica Ida is a Hawaii-born designer who loves beautiful typography and a well-told story. She is the former Creative Director of HuffPost Highline and Design Director of Mary Review. Donica lives in Brooklyn with her &amp;lt;a href=&quot;#&quot;&amp;gt;husband&amp;lt;/a&amp;gt; and splits her time between freelance work, traveling, hikes, and ramen. She is currently available for new opportunities. &amp;lt;span&amp;gt;Connect&amp;lt;/span&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;Email &amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;Instagram &amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;LinkedIn &amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;WorkingNotWorking.&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 결론적으로 효과가 들어가는 글자에는 span 이나 div태그를 붙였다. --&amp;gt;&amp;lt;/body&amp;gt;scss자주 사용되는 글자가 빨간색 글자이다. 그리고 grid도 form 도 extend를 이용해 한 곳에 정리해주면 깔끔하다._extend.scss%tinyText { color: $red; font-size: 12px; font-family: &quot;Nunito&quot;;}%grid { display: grid; grid-template-columns: 1fr 3fr 5fr;}_variables.scss$red: #fc3f33;$black: #444444;@import &quot;_variables&quot;;@import &quot;_extend&quot;;@import url(&quot;https://fonts.googleapis.com/css?family=Nunito|PT+Serif:400,400i&amp;amp;display=swap&quot;);* { box-sizing: border-box;}body { font-family: &quot;PT Serif&quot;, serif; background-color: #f0efeb; color: $black; padding: 30px 40px; line-height: 1.5;}header { font-size: 46px; letter-spacing: 1px; margin-bottom: 175px;}.works { margin-bottom: 80px; .works_header { @extend %grid; padding-bottom: 10px; span { @extend %tinyText; } // works 에 grid를 적용해야 직계 자손인 works_list 가 grid 안에 들어가게 된다. } .works_list { .works_work { cursor: pointer; font-size: 20px; border-top: 1px solid black; padding: 20px 0px; @extend %grid; &amp;amp;:hover { font-style: italic; } } }}.cv { margin-bottom: 120px;}.cv,.about { font-size: 30px; span { @extend %tinyText; }}a { color: $red; &amp;amp;:hover { font-style: italic; }}.about { padding-bottom: 80px;} 배웠던것 우선 한 곳에 import 된다면, _variables 에 있는 변수를 _extend 에서 사용할 수 있다는 것이다. extend 사용 법 커서를 올렸을 떄 이태리 체로 바뀜 (&amp;amp;:hover{font-style: italic;}) 결과물" }, { "title": "https://paint-box.com 2", "url": "/posts/clone3/", "categories": "CSS, clone", "tags": "not선택자", "date": "2020-10-12 00:00:00 +0900", "snippet": "style.scss@import url(&quot;https://fonts.googleapis.com/css?family=Montserrat:400,500&amp;amp;display=swap&quot;);@import url(&quot;https://fonts.googleapis.com/css?family=Caladea:400&amp;amp;display=swap&quot;);@import &quot;_variables&quot;;@import &quot;_titles&quot;;* { box-sizing: border-box;}a { text-decoration: none; color: inherit; @extend %miniTitle;}body { font-family: &quot;Caladea&quot;; // 두번째 url 에서 뽑아온것 padding-top: 70px;}body &amp;gt; *:not(.footer) { padding: 0px 140px;} // 맨위의 코드에서 모든 태그가 border-box 안으로 들어가게 했다. 근데 원본을 보면 footer부분은 width가 삐져나온걸 알 수 있다.// 그래서 직계자손중 footer만 저 값을 준다는 뜻이다. 만약 &quot;&amp;gt;&quot;는 직계자손을 선택한다는 뜻. &quot;*&quot; 는 모두를 선택한다는뜻. 즉, 직계자손 전부라는 뜻.// 만약 &quot;*&quot;만 있으면 안에 있는 모든 태그를 다 선택한다는 뜻이다.header { z-index: 1; // 위쪽으로 항상 튀어나오게 하는 property position: fixed; width: 100%; top: 0; // 맨 위로 가게 함. left: 0; padding: 0px 40px; // 위아래 왼쪽오른쪽 이렇게 설정됨 background-color: white; height: 70px; display: flex; align-items: center; nav { width: 100%; display: flex; justify-content: space-between; align-items: center; img { width: 70px; height: 55px; } ul { display: flex; justify-content: space-between; @extend %miniTitle; &amp;amp;:first-child { li { margin-right: 60px; } } } }}.hero { height: 100vh; background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.4)), url(&quot;https://images.unsplash.com/photo-1535137755190-8a0b337717e9?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=800&amp;amp;q=80&quot;); background-size: cover; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; margin: 0px $sideSpace; h4 { @extend %miniTitle; margin-bottom: 90px; } h3 { font-size: 40px; width: 35%; text-align: center; margin-bottom: 70px; font-weight: 50; } a { width: 10%; border: solid 2px; padding: 10px 8px; text-align: center; text-decoration: none; color: rgb(255, 255, 255); @extend %miniTitle; transition: color 0.3s linear, background 0.3s linear; // 글자 color 가 0.3초 동안 일정하게 바뀜, 배경 색이 0.3초동안 일정하게 바뀜. &amp;amp;:hover { background-color: white; color: black; } }}.under_hero { height: 100vh; display: flex; justify-content: center; padding: 100px; width: 100%; .under_hero_content { height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background-color: $bg; .wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; h4 { @extend %miniTitle; margin-bottom: 30px; } h3 { font-size: 26px; text-align: center; margin-bottom: 50px; width: 55%; } a { width: 50%; border: solid 2px; padding: 10px 8px; text-align: center; text-decoration: none; color: black; @extend %miniTitle; transition: color 0.3s linear, background 0.3s linear; // 글자 color 가 0.3초 동안 일정하게 바뀜, 배경 색이 0.3초동안 일정하게 바뀜. &amp;amp;:hover { background-color: black; color: white; } } } }}.blog { width: 100%; display: grid; grid-template-columns: 1fr; grid-template-rows: repeat(3, 60vh); margin-bottom: 80px; padding: 0px 150px; .blog_post { background-color: $bg; display: grid; grid-template-columns: repeat(2, 1fr); &amp;amp;:nth-child(even) { img { order: 1; // 두번째 blog_post 에 속해있는 img 를 의미 } } img { width: 100%; height: 100%; //blog_post 에 속해있는 모든 이미지를 의미. 위의 코드가 없으면 사진이 삐져나옴. } .post_content { display: flex; flex-direction: column; justify-content: center; align-items: center; .post_date { @extend %miniTitle; margin-bottom: 70px; } h4 { font-size: 32px; margin-bottom: 40px; @extend %miniTitle; text-align: center; font-weight: 100; } a { @extend %miniTitle; text-decoration: none; font-size: 12px; font-weight: 500; } } }}.gallery { display: grid; grid-template-columns: repeat(4, auto); grid-template-rows: repeat(2, auto); padding: 0px 120px; .gallery_poster { height: 100%; width: 100%; cursor: pointer; img { max-width: 100%; height: 100%; transition: opacity 0.3s cubic-bezier(0.39, 0.575, 0.565, 1); &amp;amp;:hover { opacity: 0.5; } } }}.footer { margin-top: 100px; background-color: $bg; display: grid; grid-template-columns: repeat(3, 1fr); padding: 65px 0px; .footer_column { display: flex; flex-direction: column; align-items: center; font-size: 5px; @extend %miniTitle; .column_title { margin-bottom: 50px; opacity: 0.5; } ul { text-align: center; li { margin-bottom: 15px; } } &amp;amp;:nth-child(2) { border-right: 1px solid black; border-left: 1px solid black; } }} 배운것 grid 직계자손에서 특정 자손 제외 하는 selector(&amp;gt;*:not()) 배경화면 어둡게 하는 property(background-gradient) transition, hover 랑 같이 묶여서 코딩됨. (a 태그) google font 에서 font 를 import 해옴.결과" }, { "title": "https://paint-box.com 1", "url": "/posts/clone2/", "categories": "CSS, clone", "tags": "article", "date": "2020-10-12 00:00:00 +0900", "snippet": "https://paint-box.com/ 클론코딩클론 코딩할때 또 기억해야 하는 것은 글자와 그림 배치를 보고 flex 로 할 건지 grid 로 할 건지 대충 머릿속에 그려놔야하고, 또한 flex로 했을때 direction이 column 인지 row인지도 미리 구상하면 더 명확하게 코딩 할 수 있다.&amp;lt;body&amp;gt; &amp;lt;header&amp;gt; &amp;lt;nav&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;NAIL STUDIOS&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;SHOP POLISH&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;img src=&quot;logo.png&quot; /&amp;gt; &amp;lt;ul&amp;gt; JOURNAL &amp;lt;/ul&amp;gt; &amp;lt;/nav&amp;gt; &amp;lt;!-- 역시나 위에 목록부분은 nav 와 header로 감싼다 --&amp;gt; &amp;lt;/header&amp;gt; &amp;lt;div class=&quot;hero&quot;&amp;gt; &amp;lt;h4&amp;gt;The Uptown Collection&amp;lt;/h4&amp;gt; &amp;lt;h3&amp;gt; Meet our newest nails, designed in collaboration with our friends on the Upper East Side. &amp;lt;/h3&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;Read More&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;section class=&quot;under_hero&quot;&amp;gt; &amp;lt;img src=&quot;studio.png&quot; /&amp;gt; &amp;lt;div class=&quot;under_hero_content&quot;&amp;gt; &amp;lt;div class=&quot;wrapper&quot;&amp;gt; &amp;lt;h4&amp;gt;The studio&amp;lt;/h4&amp;gt; &amp;lt;h3&amp;gt; Book a manicure at our Soho flagship studio or our new Uptown studio, 20 East 69th Street at Madison Avenue. &amp;lt;/h3&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;Book a Manicure&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;section class=&quot;blog&quot;&amp;gt; &amp;lt;article class=&quot;blog_post&quot;&amp;gt; &amp;lt;img src=&quot;brown.png&quot; /&amp;gt; &amp;lt;div class=&quot;post_content&quot;&amp;gt; &amp;lt;span class=&quot;post_date&quot;&amp;gt;Feb 25, 2020&amp;lt;/span&amp;gt; &amp;lt;h4&amp;gt;New and Now: Fall–Winter 2020 Lookbook Collection&amp;lt;/h4&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;Read Story&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/article&amp;gt; &amp;lt;article class=&quot;blog_post&quot;&amp;gt; &amp;lt;img src=&quot;https://images.unsplash.com/photo-1583255448430-17c5eda08e5c?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1350&amp;amp;q=80&quot; /&amp;gt; &amp;lt;div class=&quot;post_content&quot;&amp;gt; &amp;lt;span class=&quot;post_date&quot;&amp;gt;Feb 25, 2020&amp;lt;/span&amp;gt; &amp;lt;h4&amp;gt;New and Now: The Uptown Collection&amp;lt;/h4&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;Read Story&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/article&amp;gt; &amp;lt;article class=&quot;blog_post&quot;&amp;gt; &amp;lt;img src=&quot;https://images.unsplash.com/photo-1583255448430-17c5eda08e5c?ixlib=rb-1.2.1&amp;amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=1350&amp;amp;q=80&quot; /&amp;gt; &amp;lt;div class=&quot;post_content&quot;&amp;gt; &amp;lt;span class=&quot;post_date&quot;&amp;gt;Feb 25, 2020&amp;lt;/span&amp;gt; &amp;lt;h4&amp;gt;New and Now: The Uptown Collection&amp;lt;/h4&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;Read Story&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/article&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;section class=&quot;gallery&quot;&amp;gt; &amp;lt;div class=&quot;gallery_poster&quot;&amp;gt; &amp;lt;img src=&quot;gallery_web.png&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;gallery_poster&quot;&amp;gt; &amp;lt;img src=&quot;gallery_web.png&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;gallery_poster&quot;&amp;gt; &amp;lt;img src=&quot;gallery_web.png&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;footer class=&quot;footer&quot;&amp;gt; &amp;lt;div class=&quot;footer_column&quot;&amp;gt; &amp;lt;span class=&quot;column_title&quot;&amp;gt;support&amp;lt;/span&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;F.A.Q.&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Privacy Policy&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Terms and Conditions&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Accessibility&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;footer_column&quot;&amp;gt; &amp;lt;span class=&quot;column_title&quot;&amp;gt;FOLLOW US&amp;lt;/span&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;INSTAGRAM&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;PINTEREST&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;FACEBOOK&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;NEWSLETTER&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;footer_column&quot;&amp;gt; &amp;lt;span class=&quot;column_title&quot;&amp;gt;PAINTBOX&amp;lt;/span&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;OUR STUDIOS&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;CAREERS&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;PRESS&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;CONTACT US&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/footer&amp;gt;&amp;lt;/body&amp;gt;scss 코딩우선 extend 와 variables 를 설정하자.%miniTitle { font-family: &quot;Montserrat&quot;; font-weight: 500; font-size: 15px; text-transform: uppercase; letter-spacing: 2px;}$bg: #f3ede8;$sideSpace: 140px;이렇게 일단 설정해놓고 styles.scss 는 다음 글에서 알아보자 글이 너무 길어질 것 같으니." }, { "title": "https://besthorrorscenes.com - html 구조", "url": "/posts/clone1/", "categories": "CSS, clone", "tags": "section, nav, linear-gradient", "date": "2020-10-12 00:00:00 +0900", "snippet": "첫 번째 클론 웹 (https://besthorrorscenes.com/)이제 부터는 기존의 웹페이지를 최대한 비슷하게 복제해보는 프로젝트이다. 처음 클론할 웹사이트는 위에 링크를 걸은 웹사이트인데 보면 왼쪽 nav 부분이 고정되어있고 오른쪽에는 영상이 나열되어 있는 보기에 간단한 웹페이지 이다. 그럼 뼈대를 만들어 주자.이때 html 안에 어떤 부분에 어떤 태그를 사용했는지, 그리고 어떤 태그로 얼마만큼 감쌌는지 유심히 살펴보자.&amp;lt;!-- head 부분은 생략 --&amp;gt;&amp;lt;body&amp;gt; &amp;lt;header&amp;gt; &amp;lt;h1&amp;gt;BEST HORROR SCENES&amp;lt;/h1&amp;gt; &amp;lt;div class=&quot;bottom&quot;&amp;gt; &amp;lt;h3&amp;gt; An ever growing collection featuring some of the best scenes in horror. &amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt; “Best Horror Scenes” is a collection of scenes I feel are some of the most affecting in horror. Some may be simple black cat scares, others may be more subdued or nuanced. Many come from films that aren&#39;t necessarily “horror” but have elements or threads of horror, and all have the same general effect: unease, dread, fear, shock, disgust. &amp;lt;/p&amp;gt; &amp;lt;nav&amp;gt; &amp;lt;!-- 다른 곳으로 이동시키는 링크 페이지 설정 or 페이지 안에 구역을 나누는 태그 --&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;Watch on YouTube&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Suggest a Scene&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Get Episode&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Notices&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Contact&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;RSS&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;!-- ul&amp;gt;li*숫자 하면 ul 안에 담긴 li 태그가 숫자만큼 생김 --&amp;gt; &amp;lt;/nav&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/header&amp;gt; &amp;lt;main&amp;gt; &amp;lt;section class=&quot;movie&quot;&amp;gt; &amp;lt;div class=&quot;wrapper&quot;&amp;gt; &amp;lt;div class=&quot;movie_header&quot;&amp;gt; &amp;lt;h4&amp;gt;38. Hereditary (2018)&amp;lt;/h4&amp;gt; &amp;lt;h5&amp;gt;Directed by Yeong&amp;lt;/h5&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;img src=&quot;poster.png&quot; alt=&quot;&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;section class=&quot;movie&quot;&amp;gt; &amp;lt;div class=&quot;wrapper&quot;&amp;gt; &amp;lt;div class=&quot;movie_header&quot;&amp;gt; &amp;lt;h4&amp;gt;38. Hereditary (2018)&amp;lt;/h4&amp;gt; &amp;lt;h5&amp;gt;Directed by Yeong&amp;lt;/h5&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;img src=&quot;poster.png&quot; alt=&quot;&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;section class=&quot;movie&quot;&amp;gt; &amp;lt;div class=&quot;wrapper&quot;&amp;gt; &amp;lt;div class=&quot;movie_header&quot;&amp;gt; &amp;lt;h4&amp;gt;38. Hereditary (2018)&amp;lt;/h4&amp;gt; &amp;lt;h5&amp;gt;Directed by Yeong&amp;lt;/h5&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;img src=&quot;poster.png&quot; alt=&quot;&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;section class=&quot;movie&quot;&amp;gt; &amp;lt;div class=&quot;wrapper&quot;&amp;gt; &amp;lt;div class=&quot;movie_header&quot;&amp;gt; &amp;lt;h4&amp;gt;38. Hereditary (2018)&amp;lt;/h4&amp;gt; &amp;lt;h5&amp;gt;Directed by Yeong&amp;lt;/h5&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;img src=&quot;poster.png&quot; alt=&quot;&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/section&amp;gt; &amp;lt;!-- 모든 텍스트에 태그를 달음. 그리고 세세하게 클래스를 설정함. 그래야 관리하기 쉬움 --&amp;gt; &amp;lt;/main&amp;gt;&amp;lt;/body&amp;gt;위에 html를 분석해보면 제목을 header 태그에 넣었고 밑에 contact 부분을 nav 태그에 넣었다. 그리고 영상들을 main 태그에 넣고 movie로 감쌌다. 또한 wrapper로 감싼다음 안에 영화 제목과 그림을 분류한 것을 볼 수 있다. 이러한 패턴은 뒤에서 다룰 클론웹에서 자주 등장하는 패턴이다.그 다음 local에서 styles.scss 를 css로 변환하고 모니터 하기 위해 node를 켜 주자. npm run devscss 설정.우선 배경색과 글자색을 반복해서 써야 하므로, 변수 설정이 필요하다. (변수를 설정해야 신속하게 코드를 작성할 수 있고 읽기도 쉬워지고 여러가지로 좋다.) _variables.scss 를 만들자.$red: #e7473c;$white: #f0f0f0;$fixedWidth: 33%;그리고 styles.scss 를 적어주자.@import &quot;_variables&quot;;@import &quot;reset&quot;;// _variables 파일을 import 해야 변수를 사용 할 수 있다// reset 파일은 html 을 표준화하는데 기여하는 파일이라서 import 해준다.* { box-sizing: border-box; //padding 이랑 border 가 박스안에 담기도록 함. //두가지 element의 크기를 균일하게 할때 사용되는 property이다. // *는 universal selector 로 전체 스타일에 영향을 주는 선택자이다.}body { height: 100vh; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Open Sans&quot;, &quot;Helvetica Neue&quot;, sans-serif; background-color: $white;}header { position: fixed; //header 가 fixed 되면 main의 margin-left 에 공간을 줘야 겹치지 않게 된다. top: 0; left: 0; width: $fixedWidth; // 페이지 설명 header가 왼쪽에 위치하도록 하게 함. height: 100%; padding: 5vh 0 72px 72px; //위에서 부터 오른쪽 방향으로 설정 display: flex; flex-direction: column; justify-content: space-between; color: $red; h1 { font-size: 85px; letter-spacing: 5px; text-transform: uppercase; width: 50%; } h3 { margin-top: 40px; font-size: 30px; margin-bottom: 40px; // letter-spacing: 3px; } h3, p { width: 70%; line-height: 1.2; // 줄의 높이를 설정. 말그대로. text-align: justify; // 텍스트 위치 설정. } p { font-weight: 330; font-size: 22px; margin-bottom: 40px; } nav { width: 80%; ul { display: flex; flex-wrap: wrap; li { cursor: pointer; margin-right: 12px; font-size: 20px; opacity: 0.5; //투명도 padding-bottom: 5px; //줄간격이 늘어남. 모든 li에 적용하니깐 border-bottom: 2px solid rgba(0, 0, 0, 0.5); margin-bottom: 20px; color: #616165; &amp;amp;:hover { opacity: 1; //마우스를 갖다대니깐 더 진해짐. 하이라이트 효과. 이럴때 쓰는 구나! } } } }}main { background-color: $red; margin-left: $fixedWidth; .movie { background: linear-gradient( to bottom, rgba(0, 0, 0, 0.1) 5%, transparent, transparent, transparent, transparent ) // 아래로 갈수록 더 옅어짐 배경색이. .movie 맨위에서 5%가량에 살짝 검정색깔이 들어가게 함. 그리고 밑으로는 점점 투명하게 변한다. $red; height: 100vh; display: flex; justify-content: center; align-items: center; color: white; .wrapper { width: 80%; display: flex; flex-direction: column; .movie_header { display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 25px; h4 { font-size: 32px; text-transform: uppercase; } h5 { letter-spacing: 2px; } } } img { width: 100%; box-shadow: 0 80px 80px -80px #000, 0 0 12px rgba(0, 0, 0, 0.06), inset 0 0 0 1px rgba(0, 0, 0, 0.2); } // 영상뒷면에 그림자가 지게 하는 효과. horror 사이트 검색을 통해 찾아낸 효과. }}결과물 Best horror scens web" }, { "title": "SCSS - responsive", "url": "/posts/basic8/", "categories": "CSS, basic(css)", "tags": "media, content", "date": "2020-10-01 00:00:00 +0900", "snippet": "1. responsive이번엔 화면에 크기에 따라 효과가 적용되는 mix을 만들어볼려고 한다. responsive mix은 @content 함수를 통해 함수 내용을 styles.scss에서 설정할 수 있다. 그럼 먼저 html 을 만들어주자. 화면 크기에 따라 HELLO의 색깔이 바뀔것이다.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;dist/css/reset.css&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;dist/css/styles.css&quot; /&amp;gt; &amp;lt;title&amp;gt;(S)CSS Masterclass&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Hell3o&amp;lt;/h1&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;그리고 mixins.scss 파일을 만들어주자. 그리고 안에 변수를 설정하고 media query로 화면의 최소, 최대 크기를 설정한다. 그리고 @content를 적어준다. 말 그대로 media query의 효과는 함수가 적용될 때 외부에서 설정한 값에 따라 유연하게 반응한다는 것이다. 말로는 잘 이해가 가지 않는다. 다음 코드를 통해 더 자세히 살펴보자.$minIphone: 400px;$maxIphone: 700px;$minTablet: 900px;$maxTablet: 1100px;@mixin responsive($device) { @if $device == &quot;iphone&quot; { @media screen and (max-width: $maxIphone) and (min-width: $minIphone) { @content; // 즉 최소넓이가 400px 그리고 최대 700ox 일때 효과가 발동되는 데 // 그 효과는 styles.scss 에 적어준대로다.(@content때문에 가능한 기능이다.) } } @else if $device == &quot;tablet&quot; { @media screen and (max-width: $maxTablet) and (min-width: $minTablet) { @content; } }}아래 처럼 mix 를 import 하고 @include 를 이용해 마찬가지로 함수를 호출한다. 그리고 인자를 넣어주고 적용될 효과를 적어준다. 이때 지정한 효과가 @content가 되는 것이다.@import &quot;_mixins&quot;;h1 { @include responsive(&quot;iphone&quot;) { color: yellowgreen; } @include responsive(&quot;tablet&quot;) { color: peru; }}// responsive 함수안에 있는 @content 때문에 h1 태그에 적는 족족 responsive와 연동되어 함께 효과가 나타난다." }, { "title": "SCSS - extend", "url": "/posts/basic7/", "categories": "CSS, basic(css)", "tags": "", "date": "2020-10-01 00:00:00 +0900", "snippet": "1. EXTENDmixin 유연하게 css를 변환하는 반면 extend는 말그대로 그대로 옮겨다가 쓰는 용도이다. html 부터 먼저 만들자. log in 링크와 log out 버튼의 스타일을 같게 만들려고 한다.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;dist/css/reset.css&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;dist/css/styles.css&quot; /&amp;gt; &amp;lt;title&amp;gt;(S)CSS Masterclass&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;log In&amp;lt;/a&amp;gt; &amp;lt;button&amp;gt;Log Out&amp;lt;/button&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;그리고 _buttons.scss 라는 파일을 만들어 주자. extend를 만들때는 % 기호를 이용한다. 그럼 아래처럼 많은 기능을 한꺼번에 감싼 패키지같은걸 만들게 되는 셈이다.%button { font-family: Georgia, &quot;Times New Roman&quot;, Times, serif; border-radius: 7px; text-decoration: none; text-transform: uppercase; background-color: powderblue; color: white; font-weight: 500; padding: 5px 10px;}// extend를 쓰고 싶을때는 퍼센테이지 바로 옆에 함수의 이름이 있어야 한다.그리고 import 해주자. @ 통해서 extend를 불러오고 아래에 새로운 css property를 추가 할 수 있다.@import &quot;_buttons&quot;;a { @extend %button; text-decoration: none;}button { @extend %button; border: none;}// extend 함수는 minxins 과는 다르게 똑같은 함수를 가볍게 적용할 수 있다.// minxins은 인자와 조건에 따라 유연하게 바뀌는 측면에서, 그리고 독립적으로 적용할 수 있다는 점에서 extend와 차이가 있다.결과" }, { "title": "SCSS - mixin", "url": "/posts/basic6/", "categories": "CSS, basic(css)", "tags": "mixin", "date": "2020-10-01 00:00:00 +0900", "snippet": "1. MIXINMIXIN를 이번에 배워보자. MIXIN는 함수와 모양과 기능이 비슷하다. 그리고 IF/ELSE 와 같은 조건문도 넣을 수 있다. 역시나 html 을 먼저 만들어주자. 홀수번째 google 은 파란색 짝수번째에 있는 google은 빨간색으로 설정해주려 한다.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;dist/css/reset.css&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;dist/css/styles.css&quot; /&amp;gt; &amp;lt;title&amp;gt;(S)CSS Masterclass&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;Google&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;Google&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;Google&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;Google&amp;lt;/a&amp;gt; &amp;lt;a href=&quot;#&quot;&amp;gt;Google&amp;lt;/a&amp;gt; &amp;lt;!-- google 이라는 링크를 5개 만들고 싶다고 하면 a*5{google} 이라고 하면 됨 --&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;그리고 _minxins.scss 란 파일을 만들어주자.(참고로 import하려는 파일은 styles.scss 와 같은 폴더안에 있어야 한다.)mixin을 정의할때는 @ 기호를 사용하고 함수이름을 설정한다. 보면 알겠지만 인자까지 pass할 수 있다.@mixin link($color) { text-decoration: none; display: block; color: $color;}@mixin awesome($word) { text-decoration: none; display: block; @if $word == &quot;odd&quot; { color: blue; } @else { color: red; }} //엄청나지 않나?? 파이썬 함수 만들때 처럼 인자설정은 물론, if/else 문까지 쓸수 있다.그리고 _minxins를 import 한다음 scss 코드를 적어주면 된다. include 를 이용해서 함수를 호출한다.@import &quot;_minxins&quot;;a { margin-bottom: 10px; &amp;amp;:nth-child(odd) { @include awesome(&quot;odd&quot;); } &amp;amp;:nth-child(even) { @include awesome(&quot;even&quot;); }} //파이썬 처럼 minxins 안에 있는 함수를 적용하였다. 이때 include 를 사용한다.결과그럼 아래와 같이 짜잔하고 나타난다.CSS로 처리할 수 있는것은 최대한 CSS로 처리하자. JS에 넘겨주면 그게 다 성능에 영향을 끼친다." }, { "title": "SCSS 준비하기", "url": "/posts/basic5/", "categories": "CSS, basic(css)", "tags": "", "date": "2020-10-01 00:00:00 +0900", "snippet": "1. SCSS 준비하기sassy(스타일리쉬한) css 라고도 한다. 마치 프로그래밍하듯이 변수도 설정하고 함수와 조건문을 이용해 css 를 구성하는걸 뜻한다. 그럼 compiler가 scss 문법을 css 문법으로 번역하고(이런 과정을 compile 이라고 한다) 그걸 html이 알아들어 화면에 반영한다. 마치 프로그래밍하듯 css를 작성한다는건 엄청난 효율을 끌어낼 수 있다는 의미가 된다. 그럼 scss를 알아보기 전에 node js를 설치하여 로컬에서 scss 를 모니터링하도록 하자.우선 아래 니코의 깃헙에서 node를 다운받아주자.NODE그리고 터미널에서 다운받고 압축을 풀은 폴더에 위치하게 한다음 다음 명령어를 입력하면 된다.npm i &amp;amp;&amp;amp; npm run dev dev는 development mode 의 의미로 local에서만 사용하겠다는 뜻이다. 그럼 gulpfile.babel.js 라는 파일에 의해서 scss 코드가 css 코드로 변환된다. gulpfile 안에 들어가보면 알 수 있다.src: &quot;src/scss/styles.scss&quot; 원본파일의 위치dest: &quot;dist/css&quot; 변환되는 파일의 위치아니면 아래와 같이 sass를 통해서 compile해도 된다.// 버전을 확인하고 설치node -vnpm -vnpm install -g sass// scss-yeong안에 있는 폴더에 있는 scss파일을 css파일로 컴파일하고 css-yeong폴더안에 보관.// 우분투 리눅스 cmd 에서 사용가능sass scss-yeong:css-yeong그럼 scss에 대해서 본격적으로 알아보자.2. SCSS 기본 문법(변수설정)우선 html 파일을 만들어 scss의 코드가 css로 변환되어 잘 적용되는지 알아보자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;dist/css/reset.css&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;dist/css/styles.css&quot; /&amp;gt; &amp;lt;!--최종적으로 변환되어 적용되는 파일은 css 파일인것이다. --&amp;gt; &amp;lt;title&amp;gt;(S)CSS Masterclass&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h2&amp;gt;Title&amp;lt;/h2&amp;gt; &amp;lt;div class=&quot;box&quot;&amp;gt; &amp;lt;h2&amp;gt;Another title&amp;lt;/h2&amp;gt; &amp;lt;button&amp;gt;Hello&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;button&amp;gt;Bye Bye&amp;lt;/button&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;그리고 styles.scss 를 클릭해 scss방법으로 코드를 입력해보자. 그런데 변수를 설정해야한다. 변수는 scss파일에서 바로 설정하지는 않고 따로 파일을 하나더 만든 다음에 그 파일안에 변수를 명시하고 import 해오는 방식으로 사용할 수 있다. 우선 *variables.scss 를 만들어보자 (앞에 *를 붙이는 경우는 scss를 의미한다고 보면 된다.)$bg: #e74c3c;$title: 32px;변수를 설정할때 $ 기호를 붙인다.그리고 styles.scss에 변수를 적용해보자.@import &quot;_variables&quot;;h2 { color: $bg;} //우선 variables를 import하고 _variables.scss 에서 설정한 변수를 여기서 사용하였다..box { margin-top: 20px; &amp;amp;:hover { background-color: green; } //&amp;amp;는 box 클래스 본인을 가리키는 것이다. 그리고 hover는 마우스를 올려놨을때 작동되게 한다. h2 { color: blue; &amp;amp;:hover { color: red; } //h2안에 또 자신에 대한 태그에 효과를 달았다. 이것을 nesting이라고 한다. } button { color: red; }}그럼 styles.scss 의 파일들이 styles.css 파일에 css 문법으로 변환된것을 볼 수 있다. 그리고 아래 터미널에 nodmon 이 실시간 styles.scss 파일을 관찰하고 오류가 있으면 알려준다.3. 결과물그럼 compile 된 css 가 적용된다. 아래 처럼 말이다.우선 문법을 이해하기 굉장히 쉽다. 객관적이다. 그림을 보는 것 처럼 말이다. 그리고 변수를 이용하기 때문에 관리가 쉬워 효율성을 증대시키고 코드가 직관적으로 바뀌는건 덤이다. scss는 진짜 sassy 한 css 이다!" }, { "title": "flexible grid", "url": "/posts/basic4/", "categories": "CSS, basic(css)", "tags": "repeat, minmax, nth-child", "date": "2020-09-29 00:00:00 +0900", "snippet": "1. 좀더 flexible 한 웹을 위한 property.이번엔 minmax, grid-auto-flow 등과 같이 창의 크기에 따라 item의 크기가 바뀌거나 또는 새로 들어오는 item을 자동으로 배열해주는 property를 배워볼 것이다. 역시나 html 을 우선 만들어주자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width = device-width, initial-scale = 1.0&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;grid3.css&quot; /&amp;gt; &amp;lt;title&amp;gt;SCSS CLASS WITH NICO&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; auto-fill &amp;lt;div class=&quot;grid&quot;&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;4&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;5&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;6&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; auto-fit &amp;lt;div class=&quot;grid&quot;&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt; It is realllllllllllllllllllllllllllllly long words &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt; It is realllllllllllllllllllllllllllllly long words &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt; It is realllllllllllllllllllllllllllllly long words &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt; It is realllllllllllllllllllllllllllllly long words &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt; It is realllllllllllllllllllllllllllllly long words &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;it is moderate length of the word&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;it is short word&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 대박이다!! 만약에 item 이라는 클래스를 20개 만들고 싶고 안에 들어갈 값은 숫자이고 싶다고 하면 다음 html 코드를 쓰면 됨. .item*20&amp;gt;{$}--&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;그리고 css를 만들어주자..grid { display: grid; gap: 5px; height: 50vh; grid-template-columns: repeat(5, minmax(100px, 1fr)); grid-template-rows: repeat(4, 1fr); grid-auto-columns: 100px; /* justify-items: stretch; default 값 align-items: stretch; default 값 위의 두 property는 fraction 안에서도 구역을 나누어 얼마나 채워질지를 정할 수 있는 property 이다.*/ /*place-items: end start; 위의 두 값을 다 합친 지름길이다. 앞에 값이 세로이고 뒤에가 가로값이다. justify-content: center; 이번에 배울 property는 grid 전체를 조정하는 코드이다 align-content: center; place-content: end start; 마찬가지로 위에 두개를 한꺼번에 modify 한다.*/ /*grid-auto-rows: grid-auto-rows: 100px; 라고 하면 마지막, grid fraction 을 초과하여 item이 외부에서 들어올 경우(초기에 설정해놓은 가로 세로 줄보다 더 많은 item을 말함) 밑으로(row 방향으로) 100px의 그리드가 자동으로 생성되면서 item이 거기에 담기게 됨. 근데 만약 row 방향이 아닌 column 방향으로 item 이 생성되게 하고 싶다 할때는 grid-auto-flow: columns; 라고 하면 옆으로 새로운아이템이 생성되는 방향이 옆으로 바뀜. */ /*minmax: grid-template-columns: repeat(10, minmax(100px, 1fr)); 라고 하면 말그대로 최소가 100px 이고 최대가 1fr으로 설정하는 property 이다 grid를 한층더 유연하게 만들어준다. */}.item:nth-child(odd) { background-color: honeydew;} /*홀수번째 아이템을 모두 선택한것임 */.item:nth-child(even) { background-color: indianred;} /*짝수번째 아이템을 모두 선택한것임 */.grid:first-child { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));}.grid:last-child { grid-template-columns: repeat(auto-fit, minmax(max-content, 500px));} /* grid=class 가 2개있다고 하자. 그럼 첫번째 grid에만 효과를 주고 싶을때 .grid:first-child 라고 한다. 마지막은 last-child 라고 한다. *//*이번엔 auto-fill 이랑 auto-fit에 대해 배워볼거다. auto-fill은 item이 자동채워지는 게 아닌, grid가 남은 스크린을 자동으로 채우는것이다.auto-fit은 아이템이 스크린의 사이즈를 균일하게 배분받아서 크기가 설정된다. *//* 마지막으로 배울 property는 min-content와 max-content 이다. min-content는 상자안에 item 크기가 작아질수있을만큼 작아지게 만든뒤 상자의 크기도 그 item의 크기만큼 줄이는것. max-content는 반대로 item의 크기를 최대로 키운다음 상자의 크기도 그만큼 키우는거다. 이 두개의 property는 minmax 와 repeat 와도 융합해서 쓸수 있다 */결과grid의 빈칸이 이미 준비되어있는 것을 볼 수 있다.(auto-fill)grid의 칸이 item으로 꽉차있는 걸 볼 수 있다.(auto-fit)아무리 창을 작게해도 글자 크기보다 더 작아지진 않았다.(minmax(max-content, 500px))그리고 auto-fit 안에 있는 item들이 500px 이상으로 커지진 않는다.(minmax(max-content, 500px))" }, { "title": "GRID-TEMPLATE", "url": "/posts/basic3/", "categories": "CSS, basic(css)", "tags": "grid-area", "date": "2020-09-29 00:00:00 +0900", "snippet": "1. GRID TEMPLATE이번에는 훨씬더 직관적이고 더 쉽게 GRID를 만들어보도록 하자. 바로 GRID-TEMPLATE 라는 PROPERTY 를 사용해서 말이다. 그리고 GRID의 각 행과 열에 이름을 붙여 세부적으로 MODIFY 할 수 도 있다. 또한 특정 행과 열이 어디부터 어디까지 이어지는지도 정할 수 있다. 먼저 HTML 부터 만들자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width = device-width, initial-scale = 1.0&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;grid2.css&quot; /&amp;gt; &amp;lt;title&amp;gt;SCSS CLASS WITH NICO&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&quot;grid&quot;&amp;gt; &amp;lt;div class=&quot;header&quot;&amp;gt;header&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;content&quot;&amp;gt;content&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;nav&quot;&amp;gt;nav&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;footer&quot;&amp;gt;footer&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;그리고 CSS도!!.grid { display: grid; /* fraction(fr): grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(4, 1fr); 1fr 은 1 fraction 즉 화면의 크기가 얼마나 작든 크든 동일한 비율로 한 조각을 차지한다는 뜻이다. 화면의 크기에 따라 유연하게 사이즈가 달라지기 때문에 매우 유용하다.*/ /*naming: grid-template-columns: [first] 100px [second] 100px [third] 100px [forth] 100px [fifth]; grid-template-rows: repeat(4,100px [line]); columns 네이밍과 rows 네이밍이 같은 말이다. */ height: 50vh; /*화면의 반을 차지한다. 높이를 설정해주지 않으면 item이 늘어날 공간이 없으므로 유의해주자 */ grid-template: [h-s] &quot;header header header header&quot; 1fr [h-e] [c-s] &quot;content content content nav&quot; 2fr [c-e] [f-s] &quot;footer footer footer footer&quot; 1fr [c-e] / 1fr 1fr 1fr 1fr; /* grid-template 를 쓰면 높이까지 한꺼번에 설정할 수 있기 때문에, 그리고 각각의 상자가 얼마만큼 차지하는지 까지 세부조정할 수 있기 때문에 훨씬 쉽고 빠른 작업이 가능함. 그리고 [] 안에 네이밍 까지 가능하다. 거의 그림을 그린것 처럼 볼 수 있어서 직관적이기도 하다. */ gap: 10px;}.header { background-color: grey; grid-column: 1 / 5; grid-area: header; /*grid-template를 쓰면 반드시 grid-area를 child 내부에 명시해줘야 grid-template가 적용이된다. grid-column: first / fifth; 이런식으로 네이밍한걸 써먹을 수 있다. */}.content { background-color: blue; /* grid-column-start: 1; grid-column-end: 4; grid-row-start: 2; grid-row-end: 4; grid-column: 1 / -2; grid-row: span 2;*/ grid-area: content;}/*이런식으로 행과 열의 어느위치에서 시작해서 끝날지 결정할 수 있다. *//* 아님 더 간략화시킬 수 있다. a/b 라고 하면 a에서 부터 b까지란 뜻이고, span 숫자 하면 숫자만큼의 공간을 차지한다는 뜻이다 *//* 더 간단한 방법이 있다. row-start + column-start + row-end + column-end = grid-area rs / cs / re/ ce */.nav { background-color: brown; grid-area: nav;}.footer { background-color: burlywood; grid-area: footer;}/* 아무리 변화를 줘도 안바뀌길래 먼가 했더니 typo였다. typo가 뜨면 빨간줄로 표시된다. 잘 살펴보자 */결과그럼 이렇게 짠 하고 나타난다. 화면의 반만 사용된걸 볼 수 있다." }, { "title": "GRID를 배워보자", "url": "/posts/basic2/", "categories": "CSS, basic(css)", "tags": "grid", "date": "2020-09-29 00:00:00 +0900", "snippet": "1. GRIDflex 와는 다르게 높이와 넓이를 설정할 수 있다. 쉽게 말해 표라고 보면 된다. 우선 몸풀기로 간단한 표 하나 만들어 보자. 역시나 html 파일을 하나 만들자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width = device-width, initial-scale = 1.0&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;grid1.css&quot; /&amp;gt; &amp;lt;title&amp;gt;SCSS CLASS WITH NICO&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&quot;parents&quot;&amp;gt; &amp;lt;div class=&quot;child&quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;child&quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;child&quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;child&quot;&amp;gt;4&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;그리고 위의 html 의 소스가 되는 css파일을 만들자..parents { display: grid; grid-template-columns: 250px 250px 250px 250px; /* 세로줄간의 간격. 또는 repeat(4, 250px) 라고 해도 된다. 개발자들은 반복을 싫어하다 못해 혐오하는 것 같다. */ grid-template-rows: 40px 180px 90px 150px; /*가로줄의 간격 */ gap: 10px; height: 100vh; /*높이 설정하는거 역시 잊지 말자. */}.child { background: peru; color: blue; display: flex; justify-content: center; align-items: center; font-size: 25%; flex-basis: 30%;}결과그리고 검사를 통해 grid 가 만들어진 걸 볼 수 있다." }, { "title": "flex 하게 소리질러!!", "url": "/posts/basic1/", "categories": "CSS, basic(css)", "tags": "flex", "date": "2020-09-29 00:00:00 +0900", "snippet": "1. flexbox이제부터 본격적으로 웹디자인을 담당하는 css에 대해서 배워볼려고 한다. flex는 contents 위주의 디자인이다. grid 처럼 위아래를 다루는 2d 방식의 form이 아니기 때문. 그리고 flex property는 웹창의 크기에 따라 유연하게 item이 변할 수 있게 해준다. 우선 flex.html을 만들어주자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width = device-width, initial-scale = 1.0&quot; /&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;flexbox.css&quot; /&amp;gt; &amp;lt;title&amp;gt;SCSS CLASS WITH NICO&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&quot;parents&quot;&amp;gt; &amp;lt;div class=&quot;child&quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;child&quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;child&quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;child&quot;&amp;gt;4&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;child&quot;&amp;gt;5&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;child&quot;&amp;gt;6&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;그리고 css디자인을 적용해주기 위해 flexbox.css를 만들어주자..parents { display: flex; font-size: 50px; gap: 10px; /*모든 상자 사이의 틈을 설정한다. */ flex-direction: column; justify-content: stretch; align-items: flex-end; flex-wrap: wrap; height: 100vh;} /*flex 박스를 이용할때 항상 직계부모를 건드려야함. *//* default direction: rowto modify the columns, use this property: align-itemsto modify the row(defalut), use this property: justify-content그리고 body의 높이를 늘려줘야 수정가능하다. 늘어날 공간이 필요하니깐(height: 100vh 로 해줌--화면을 100%활용함)/* 그리고 flex-direction: column; 이면,..어떻게 설명해야하나. 화면이 90도 왼쪽으로 돌아갔다고 보면 된다그럼 가로가 늘어나면 위아래가 늘어나는 것이고 세로가 늘어나면 왼쪽 오른쪽이 늘어나는 것이다. *//* flex-wrap: wrap; 이라고 하면 item들이 밖으로 삐져나가거나 충돌하지 않도록 감싸준다고 생각하면 된다. 그래서 넘쳐 흐른 item 들이 밑으로 가게 된다. */.child { height: 60px; width: 150px; display: flex; justify-content: center; align-items: flex-start; background-color: peru; color: blue;}/* child 에도 flex, justfy-content, align-items 를 적용할 수 있다.(그럼 숫자의 위치가 바뀌겠지.) flex-basis 는 default width 라고 생각하면 된다. 그리고 child 전체 클래스에 주로 적용된다. */.child:nth-child(3) { align-self: flex-start;}/*특정 child 를 지정해서 modify 할 수 있는데 이때 align-self property를 사용한다. */.child:nth-child(1) { order: 1;}/*관리자의 권한이 없어서 아니면 그 다른이유로 html 을 못바꿀때 order를 사용하면 순서를 바꿀 수 있다. 그리고 참고로default order은 &#39;0&#39;이다. 그러므로 위의 코드에 의해서 첫번째 child가 제일 뒤로가게 된다.*/.child:nth-child(2) { flex-shrink: 7; background: black; flex-grow: 3; flex-basis: 1;}/*이런식으로 하면 웹창이 줄어들때 그리고 늘어날때 2번 상자만 늘어났다 줄어들었다 한다. 다른상자에 비해 그리고 늘어날때와 줄어들때 빈칸이 없이 꽉차게 늘어나거나 줄어듬.*/결과3번째 child 가 맨앞쪽으로 향해있고 1번째 child가 order:1에 의해 가장 마지막에 위치해있는걸 확인할 수 있다.parents클래스에 부여된 flex-wrap: wrap; 때문에 화면이 줄어들어도 모든 item이 한 화면에 감싸지게 된다. 그리고 2번째 child에 부여된 shrink와 grow property 에 의해 혼자 더 늘어나고 더 줄어들게 된다." }, { "title": "todo list - css 다듬기", "url": "/posts/vanila7/", "categories": "Javascript, todo-list", "tags": "", "date": "2020-09-09 00:00:00 +0900", "snippet": "목표물거의 끝났지만 아직 완전히 끝난게 아니다. 가운데 정렬도 안되어있고 글자 크기도 뒤죽박죽이다. 나의 목표는 아래의 그림같이 나오게 하는거다그러기 위해서 우선 가운데 정렬부터 하자. 그리고 검사에 들어가서 해당 태그를 클릭한후에 margin, padding 값을 더블클릭하면 임시로 변환할 수 있다. 변화를 줘가면서 균형을 맞추자.그리고 글자 크기와 스타일도 검색해가면서 마음에 드는 걸로 바꾸어 봤다.h1 { color: #ecf0f1; transition: color 0.5s ease-in-out; text-align: center; margin-bottom: 10px; margin-top: 50px; /* 컬러가 바뀔때 0.5초정도 시간을 두고 자연스럽게 바뀌게 하는 효과 */}.js-clock { text-align: center; margin-top: 120px; margin-bottom: 10px; border-bottom-width: 10px; font-size: 70px; font-family: &quot;Times New Roman&quot;, Times, serif;}.js-form { color: #ecf0f1; text-align: center;}.js-toDoForm { text-align: center; padding-left: 13px;}.js-greetings { color: #ecf0f1; text-align: center; border-left-width: 12px; padding-left: 18px; margin-top: 10px; margin-bottom: 20px; font-size: x-large; font-family: Georgia;}.js-toDoList { color: #ecf0f1; text-align: center; font-family: &quot;Times New Roman&quot;, Times, serif;}input 상자 없애기근데 input 상자가 여전히 보인다. input 상자가 안보이게 하고 싶고 밑줄도 긋고 싶다. 그리고 글자크기도 조금 키우고 italic 채로도 바꾸고 싶다.역시 구글 영어 검색이 짱이다. stackflow에서 많은 도움을 받았다. input 에다가 스타일을 입혀준다는 것을 발견했고.크롬에서 placeholder 를 변경해야 할때는 ::placeholder 를 쓰는 것을 알아냈다. 그리고 코드가 끝나고 난후에 세미콜론을 반드시 붙여야 한다는 것도 배웠다.input[type=&quot;text&quot;] { background: transparent; /*이럼 상자가 보이지 않게 된다.*/ border: none; color: white; font-size: 20px; width: 20%; padding: 12px 50px; margin: 2px; text-align: center;} /*반드시 코드 끝에 세미콜론(;) 을 붙여주자! 안그럼 인식못한다. */::placeholder { /* Firefox, Chrome, Opera */ color: white; font-style: italic; font-size: 20px; text-decoration: underline;}목록 똑바로 정렬하기여기서 끝난게 아니다. 목록이 가운데로 왔지만 계속 정렬이 뻐드렁니 처럼 들쑥날쑥 하다. 그래서 구글링을 또 한다. 결국 알아냈다.우선 ul 태그를 div 태그로 감싸고 div 태그에다 parent 라는 클래스를 부여한다.그러고 ul 안에 display: inline-block; 부여하면 보기좋게 줄을 선다..parent { text-align: center;}.parent ul { display: inline-block; text-align: left;}.parent li { float: left; padding: 2px 5px; border: 1px solid black;}그럼 그전에 글에서 잠깐 봤던것 처럼 이렇게 나타난다. 짜잔!그치만 아직 버그가 남아있다. 새로고침을 하면 날씨 정보가 사라진다는 것이다. 콘솔에 가본 결과 fetch 함수 안에 있는 url 에서 lng = undefined 이라고 뜬다.근데 분명 localstorage 에는 value 값에 longitutde 가 명확하게 저장되어있는데도 불구하고 말이다.우선 니콜라스 쌤의 깃헙 저장소를 보아도 당최 모르겠다. 우선 여기까지 하고 나중에 파고들어보자! (해결했다. 이 전 글에서 나와있듯이 getWeather(parsedCoords.latitude, parsedCoords.longitude); 라고 해줬어야 했다. ) 느낀점: 확실히 html 하고 python 강의를 들으면서 시행착오를 겪어보니 javascript 기초강의를 이해하기 쉬웠다. 다 연결되는것 같다. 하지만 또다시 느끼는 것은 본인이 스스로 코드를 짜봐야한 다는 것이다. 백날천날 남이 짜주는 코드를 복붙하면 절대로 늘지 않는다. 깜박이는 커서앞에서 꿀먹은 손벙어리가 되어버리고 만다.또한 구글링의 중요성과 위대함을 또다시 발견하였다. 이럴때는 영어를 배워둔게 천만 다행이라고 생각한다. " }, { "title": "to do list - 위도 경도 받기(api)", "url": "/posts/vanila6/", "categories": "Javascript, todo-list", "tags": "api", "date": "2020-09-09 00:00:00 +0900", "snippet": "위도, 경도 받아오기.우선 위도, 경도를 navigator 함수를 이용해 받아온다. 그리고 그 위치로 장소를 파악해 해당 장소의 날씨데이터를 전송해준다.weather.js 파일을 만들고 언제나 그렇듯 html 에 추가한다.const COORDS = &quot;coords&quot;;function getWeather(lat, lng) {}function saveCoords(CoordsObj) { localStorage.setItem(COORDS, JSON.stringify(CoordsObj));} // 그 이전에도 늘상 해왔듯이 정보가 지속되게 하기위해서 LOCAL 에다가 그 정보를 저장해야한다. 따라서, COORDS KEY 에다가 인자를 value로 지정한다.function handleGeosuccess(position) { const latitude = position.coords.latitude; // console.log(position) 이라고 해서 coords 밑에 child로 위도,경도가 있다는것을 확인했다. const longitude = position.coords.longitude; const CoordsObj = { latitude, longitude, }; // latitude : latitude 라고 해도 되는데 이걸 그냥 간단하게 latitude 라고 해도 됨. saveCoords(CoordsObj); getWeather(latitude, longitude);} // 위도 경도를 객체 형태로 저장해준다.function handleGeoError() { console.log(&quot;Can&#39;t access geo location&quot;);}function askForCoords() { navigator.geolocation.getCurrentPosition(handleGeosuccess, handleGeoError);}// 구글위성을 통해 현재 내 위치정보를 알려준다. 그리고 현재 위치가 나오면 success 함수로 아니면 error 함수로 가게끔 한다.// console.log(navigaor) 해서 보면 navigator가 object 임을 알 수 있다.(browser에 대한 정보를 알려주는 객체) navigator안에 또 다시 object가 있고 function도 있다. 이 중에 geolocation이란 object가 있는데 안에 들어가보면 getCurrentposition이란 함수가 있다. &amp;lt;아래 스샷 확인&amp;gt;// 구글위성을 통해 현재 내 위치정보(위도,경도)를 알려주는 함수이다. 그리고 현재 위치가 나오면 success 함수로 아니면 error 함수로 가게끔 한다.function loadCoords() { const loadedCords = localStorage.getItem(COORDS); if (loadedCords === null) { askForCoords(); } else { }}function init() { loadCoords();}init();우선 여기까지 하자. 그리고 날짜 데이터는 openweather 라는 웹사이트에서 가져오는데 이때 api key 가 필요하다. 서로다른 app 끼리 정보를 주고 받을때 쓰이는 일종의 암호같은거다.날씨 데이터 함수openweather여기서 sign up하고 api 를 부여받자.const API_KEY = &quot;fdc043150b4a4dabe389dd2724e69e21&quot;;function getWeather(lat, lng) { fetch( `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&amp;amp;lon=${lng}&amp;amp;appid=${API_KEY}&amp;amp;units=metric` ) // URL 을 통해서 밖에서 데이터를 가져올때 쓰는 함수가 fetch 라는 함수이다. .then(function(response) { return response.json(); }) // 위에 fetch를 통해 받은 API값을(response) JSON 형태로 인코딩했다. 무슨말인지 모르겠으면 console.log로 프린트해봐라.// 그리고 그 값을 저장했다.// API에 대한 설명은 맨아래 간략하게 적어놓았다.// then 함수는 말그대로 앞에 있는 코드가 완료되고 난뒤에 실행되도록 하는 함수이다. 또한 API 를 호출하고 받는 역할을 하는 함수이기도 하다.//fetch를 통해 날씨 정보를 json의 형태로 가져오고 있는데 reponse 하라고 하면 에러가 날 수 있으니 데이터를 다 받고 나서 response 하라고 명령하는 것이다.//api key를 입력하는 이유는 얼마나 많이 요청했는지 그 웹사이트에서 알아보기 위해서이다.function loadCoords(){ const loadedCords = localStorage.getItem(COORDS); if(loadedCords === null){ askForCoords(); } else { const parsedCords = JSON.parse(loadedCords); // 저장된 객체를 분석함. 역시나. getWeather(parsedCoords.latitude, parsedCoords.longitude); // 분석된 객체데이터(위도,경도) 를 getweather 에 대입하여 openweather에서 날씨데이터를 뽑아옴 }};그리고 html 파일에 js-weather 클래스를 추가해주자.&amp;lt;span class=&quot;js-weather&quot;&amp;gt;&amp;lt;/span&amp;gt;그라고 weather.js 에 부품을 추가해주면 된다.const weather = document.querySelector(&quot;.js-weather&quot;);그렇게 부품을 지정하고 getweather 함수에 아래의 코드를 추가하자..then(function(json){ const temp = json.main.temp; const place = json.name; weather.innerText = `${temp} @ ${place}`});// fetch를 통해 json 형태의 날씨자료를 받고 나서. console.log(json) 입력해보면, json.main이 온도. json.name 이 장소라는 것을 알 수 있을 것이다.// API란?// 기본적으로는 운영체제, 프로그래밍언어가 제공하는 &#39;기능&#39;을 제어할 수 있게하는 인터페이스를 뜻한다. 주로 창제어 화상처리 문자제어 같은것을 의미// 근데 웹에서의API는 데이터를 요청하고 응답하는게 전부다.그럼 아래처럼 날짜와 장소가 표시되는 것을 확인할 수 있다." }, { "title": "to do list - 배경화면", "url": "/posts/vanila5/", "categories": "Javascript, todo-list", "tags": "math, image", "date": "2020-09-09 00:00:00 +0900", "snippet": "배경화면배경화면을 3개 고르고 새로고침할때마다 3개중 1개가 랜덤으로 선택되어 나타나게 된다. 그래서 unplash 라는 웹사이트에서 마음에 드는 배경 3개를 다운받도록한다. 사이즈는 1920 x 1920 언저리로 하는게 가장 이상적일것이다. 안그럼 그림이 늘어나서 해상도가 떨어지는 경우가 생길 수 있다. 그리고 bg.js 를 만들고 index.html 에 &amp;lt;script src=&quot;bg.js&quot;&amp;gt;&amp;lt;/script&amp;gt; 를 추가하자.bg.js 의 코드는 아래와 같다.const body = document.querySelector(&quot;body&quot;);// 배경이 위치할 곳은 body 태그이다. 그러므로 body태그를 지정해주자.const IMG_NUMBER = 3;function paintImage(imgNumber) { const image = new Image(); // 이미지를 삽입하는 함수이다 image.src = `img/${imgNumber + 1}.jpg`; // img폴더안에 있는 파일을 지정한다. imgNumber뒤에 1을 더한 이유는 아래 기술했다. image.classList.add(&quot;bgImage&quot;); // bgImage 클래스를 img 에 추가하여 세부조정 할 수 있게 한다. body.appendChild(image);}//imgNumber뒤에 1을 더한 이유://Math.floor(Math.random() * 3) 가 0,1,2 만 뽑아내기 때문에 1을 더해서 1,2,3 이 되게 하는 것이다(img 파일안에는 1.jpg, 2.jpg, 3.jpg 밖에 없다)function genRandom() { const number = Math.floor(Math.random() * IMG_NUMBER); return number;}// Math.random() * 숫자 --&amp;gt; 숫자를 넘어서지 않은 수를 무작위로 뽑아내는 함수이다.// Math.floor() -- 괄호안에 있는 숫자의 소수점을 없애고 무조건 내림한다. 참고로, 반대되는 함수는 math.ceiling() 이다.// Math.floor(Math.random() * 숫자) -- 숫자 아래에 있는 수를 무작위로 뽑아내고 그 수가 소수라면 내림한 수를 프린트한다.function init() { const random = genRandom(); paintImage(random);}init();css 로 배경화면 예쁘게 다듬기배경화면의 크기를 조정하고, 배경화면이 은은하게 로딩되도록 효과를 부여한다.@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; }} /* keyframes 는 효과를 지정한다. 형태는 함수처럼 이름을 지정해준다. opacity 는 불투명함을 나타내는 뜻. 0~1로 불투명함이 증가하면서 나타나는 효과 */.bgImage { position: absolute; top: 0; left: 0; width: 100%; height: 120%; z-index: -1; /*이미지가 나타나는 layer의 위치를 정할 수 있다 -1이면 이미지가 글자뒤로 후퇴한다는 뜻.*/ animation: fadeIn 0.5s linear;}/*아까 bg.js에서 image.classList.add(&quot;bgImage&quot;) 이미지에다 클래스를 추가한것도 여기 css에서 이미지만 선택적으로 미세조정 하려고 하기 위함*/" }, { "title": "to do list - 데이터 저장, 삭제", "url": "/posts/vanila4/", "categories": "Javascript, todo-list", "tags": "set/getItem", "date": "2020-09-09 00:00:00 +0900", "snippet": "데이터 저장 하는 법데이터 저장은 array를 하나 만들어서 차곡차곡 저장한다. 아래는 todolist.js 에 추가되는 코드들이다.그리고 데이터는 tuple 의 형태로(id:@@ ,text:@@) array 이에 저장되게 될 것이다.const loadedToDos = localStorage.getItem(TODOS_LS); if (toDos !== null) { if (loadedToDos !== null) { const parsedToDos = JSON.parse(loadedToDos); // 스트링형태인 정보를 객체화 시켜준다. parsedToDos.forEach(function(toDo) { paintToDo(toDo.text); });// foreach는 파이썬의 포문이라고 생각하면 된다. foreach는 function을 기본적으로 탑재한다.// 그 function의 이름은 toDo로 일단 정했다. 그리고 parsetodo 의 원소(line)를 하나하나 paintodo에다가 대입한다.const toDos = []; // to do list 에 입력되는 값이 저장되는 array를 하나 만든다.//아래 코드는 &#39;function paintToDo (text) {}&#39; 안에 추가될 코드들이다.{const newId = toDos.length + 1; //tuple 에 추가될때 부여되는 데이터의 id를 정해준다.delBtn.innerText = &quot;❌&quot;;li.id = newId;const toDoObj = { text: text, id: newId}; // todolist 에 submit 된 정보가 tuple 의 형태로 만들어지고toDos.push(toDoObj); // push 라는 메스드를 통해 array 이에 삽입된다.saveToDos(); // 그리고 저장해준다.}function saveToDos() { localStorage.setItem(TODOS_LS, JSON.stringify(toDos));} // JSON 은 &quot;JavaScript Object Notion&quot; 의 약자로 외부 데이터를 자바스크립트가 객체로 인식할 수 있게 해준다. json.stringify 는 일단 외부데이터를 스트링화해준다.(나중에 객체로 parse 해줄거다). toDos array 에 있는 값들이 tuple 형태로 TODOS_LS Key 와 연결되어 저장됨.}//요약: todolist 값을 local storage에 저장.데이터 삭제하는 법let toDos = []; // deleToDo 함수안의 toDos = cleanToDos; 때문에 toDos 변수를 고정시키면 안됨. 그래서 let 으로 변환했다.// 컴퓨터에게 정확히 어떤 위치에 있는 것을 삭제하라고 알려줘야한다. 그래서 명령을 세부화 시켜야 하기 때문에 까다로울 수 있다.function deleteToDo(event) { const btn = event.target; // 이벤트.타겟이 버튼을 의미한다.(버튼을 누르면 삭제되므로 버튼을 의미하는 코드가 무엇인지 알아내야한다) // 무슨말인지 잘 모르겠다. 까먹었다 싶으면 console.log(btn) 하면 알 수 있다. 이 함수가 실행하게끔 한 원래 객체를 target 해서 보여주는 것. // 여기선 &amp;lt;button&amp;gt;엑스표시&amp;lt;/button&amp;gt;이 되는 것이다. const li = btn.parentNode; //근데 버튼과 함께 버튼에 딸린 내용도 삭제되어야한다. 그래서 버튼에 해당하는 parent 를 찾아야함. 그때 console.dir(btn)라고 console 에 타이핑하고 쭉 내려가면 li.id = #1이 parentNode라는 걸 알 수 있다. toDoList.removeChild(li); // removeChild 메소드를 이용해 li를 삭제하자. 근데 삭제하고 나서 저장이 되어야 새로고침해도 안나타난다. const cleanToDos = toDos.filter(function (toDo) { //이때 사용하는 메소트가 filter이다. 말그대로 filter안에있는 함수가 지정한 조건에 해당하는 값만 return 하는 메소드이다. 더 자세한 설명은 아래에 있다 console.log(li.id, toDo.id); return toDo.id !== parseInt(li.id); }); toDos = cleanToDos; // 그리고 이렇게 삭제되어 없어진 원소들이 toDos array 에 업데이트되어야 하기에 toDos앞에 let을 붙여 변환가능한 변수로 만들어주고 cleantoDos와 같다고 치환하는 것이다. saveToDos(); // 그리고 변화를 유지하기 위해 저장해준다. // cleanToDos 에 대한 자세한 설명: // forEach 함수와 똑깥이 파이썬의 FOR 문처럼 원소하나하나를 훑는다. 그래서 toDos array안에 존재하는 원소가 4개라고 할때 4번 훑으면, delete누른 id 도 4번 훑는다. // array안에 존재하는 원소의 갯수만큼 나온다는 뜻.(단 , delete된 id는 하나이므로 똑깥은 숫자가 나오겠지.) // 예를들어, array안에 4개의 원소가 존재. 그중 2번째 원소를 삭제하면 id=2에 해당하는 원소가 없어짐. 그럼 li.id/toDos.id =(2/1,2/3,2/4) 가 되는것이다. 그럼 array안에 있는 1,3,4번째의 원소가 선택삭제된 원소의 id랑 다르므로 필터링되어 나오게 된다. // 근데 parseInt(정수로 변환) 하는 이유는 선택 삭제된 원소의 id 가 string 형태로 인식되기 때문에 array 원소 id랑 비교가능해지기 위해서 정수로 변환해주는 것이다. // 요약: 쪼까 이해하기 어려운 함수다. 삭제해서 없애고 그 상태를 저장하는 함수다. //그리고 아래의 코드를 &#39;function paintToDo (text) {}&#39; 안에 추가해줌으로써 이모지를 눌렀을때 삭제 함수로 이동해 클릭된 데이터가 삭제되도록 한다. delBtn.addEventListener(&quot;click&quot;, deleteToDo);}to do.id / li.id위의 그림처럼 application 에 들어가서 보면 key: toDos 이고 value: tuple 형태로 저장 되어있는 것을 볼 수 있다.to do list 에서 4개중 첫번째것을 지웠다. 그리고 콘솔을 눌러보니(console.log(li.id,toDo.id)에 의해 삭제된 아이디와 array에 남은 id 가 출력된다.) 삭제된 id 가 1로 나와있고 밑에 2,3,4 가 아직 array에 남은 데이터의 id 임을 알 수 있다. 즉 2,3,4번째의 데이터 = toDos array 가 되는 것이다." }, { "title": "to do list - list 추가", "url": "/posts/vanila3/", "categories": "Javascript, todo-list", "tags": "blogging", "date": "2020-09-03 00:00:00 +0900", "snippet": "To do list 칸 만들기Html 파일 수정역시나 to do list가 들어갈 공간을 html 에 만들어준다.&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt; charset을 추가해줘서 이모지를 인식할 수 있게 해준다.&amp;lt;/head&amp;gt;&amp;lt;form class=&quot;js-toDoForm&quot;&amp;gt; &amp;lt;input type=&quot;text&quot; placeholder=&quot;Write a to do&quot; /&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;ul class=&quot;js-toDoList&quot;&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;script src=&quot;todo.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;!--그리고 리스트만 취급하는 파일인 todo.js을 추가해준다. --&amp;gt;todo.js 파일 만들기.const toDoForm = document.querySelector(&quot;.js-toDoForm&quot;), toDoInput = toDoForm.querySelector(&quot;input&quot;), toDoList = document.querySelector(&quot;.js-toDoList&quot;);// 역시나 다뤄야할 부품에다 이름을 붙여준다.const TODOS_LS = &quot;toDos&quot;;function paintToDo(text) { // 아래의 코드는 뼈대를 만드는 작업. const li = document.createElement(&quot;li&quot;); // 말그대로 &amp;lt;li&amp;gt; 태그를 자바스크립트로 만드는 거다. const delBtn = document.createElement(&quot;button&quot;); //이 버튼을 눌러서 삭제하게 만들거다 나중에. delBtn.innerText = &quot;💢&quot;; // 이모지가 깨진다면 index.html 에들어가서 head 태그 안에 &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt; 를 추가해주자. const span = document.createElement(&quot;span&quot;); // todolist 에 입력된 정보가 담기는 태그이다. span.innerText = text; // input의 값이 나옴. span을 쓰는 이유는 더 좁은 범위의 text값을 수정할때 span(inline)태그를 사용한다. 참고로 div 태그는 더 큰 범위를 수정할때 block element의 형태로 사용됨 // P.S: innertext 와 innerhtml 의 차이는? innerText는 말그대로 코드까지 텍스트로 읽어버리는거고 innerHtml은 코드는 코드로 읽고 적용해준다. li.appendChild(delBtn); // li(리스트 태그) 안에다가 delbtn을 넣은것임 li.appendChild(span); // li(리스트 태그) 안에다가 span을 넣은것임 toDoList.appendChild(li);} // to do list 에 데이터를 입력했을때 담을 수 있는 틀(parent, chile 태그)들을 만드는 과정이다.function handlesubmit(event) { event.preventDefault(); const currentValue = toDoInput.value; paintToDo(currentValue); //input의 값을 currentvalue에 집어넣는것임. toDoInput.value = &quot;&quot;; // input에 값을 입력하고나서 엔터누르면 초기화되면서 다시 입력가능하게 함.}// 요약: todolist 값을 입력하게 함.function loadToDos() { const loadedToDos = localStorage.getItem(TODOS_LS); if (loadedToDos !== null) { }}function init() { loadToDos(); toDoForm.addEventListener(&quot;submit&quot;, handlesubmit); // 이벤트 기능을 써서 엔터를 누르고 submit 하면 handlesubmit으로 가게끔 해놓았다.}init();//p.s: father, children 이란 용어는 hierarchy 를 가리키는 것. nested 된 태그가 당연 children 이고 nest 하는 태그가 parent 이다.//p.s: 함수안에 저장된 변수나 리스트는 함수밖에서 사용불가능. is not defined 라고 뜰것임. 그렇지 않으면 나도 모르는 사이 그 변수같은게 실행될 수 있음.//p.s: 사용된 이벤트가 어떤 기능을 하는지 까먹었을 경우 사용된 이벤트를 변수에 저장하고 그 변수를 console.log 해서 보면 이해가능 ex)event.target//만약 변수를 모든곳에 적용가능하게 하고 싶다고 하면 함수 밖에서 그냥 변수를 지정." }, { "title": "todo list - username", "url": "/posts/vanila2/", "categories": "Javascript, todo-list", "tags": "", "date": "2020-09-03 00:00:00 +0900", "snippet": "이름입력하기Html 파일 수정(역시)&amp;lt;form class=&quot;js-form form&quot;&amp;gt; &amp;lt;!--form 태그를 쓰는 이유: form 태그는 웹상에 구현되는 공간을 생성하는 거고 div는 단순히 구역을 구분할때 쓰는 태그이다. --&amp;gt; &amp;lt;input type=&quot;text&quot; placeholder=&quot;What is your name?&quot; /&amp;gt; &amp;lt;!-- 이름을 입력할 박스를 생성 --&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;h4 class=&quot;js-greetings greetings&quot;&amp;gt;&amp;lt;/h4&amp;gt;&amp;lt;!-- 이름을 입력하면 h4 태그에 나타나게 됨 --&amp;gt;&amp;lt;script src=&quot;gretting.js&quot;&amp;gt;&amp;lt;/script&amp;gt;css 파일 수정(토글처럼 사용하게 하기 위함).form,.greetings { display: none;}.showing { display: block; 줄바꿈하게 함(block)}greeting.js 생성const form = document.querySelector(&quot;.js-form&quot;), input = form.querySelector(&quot;input&quot;), greeting = document.querySelector(&quot;.js-greetings&quot;); // 갖고놀아야할 부품을 3개 지정.const USER_LS = &quot;currentUser&quot;, SHOWING_CN = &quot;showing&quot;;function saveName(text) { localStorage.setItem(USER_LS, text); // key값이 currentUser 인 value의 값으로 text 가 저장됨}//로직 순서:3번function handSubmit(event) { event.preventDefault(); // 디폴트값은 원래 엔터를 누르면 없어지는건데 엔터를 눌러도 그대로 남아있게 했다. const currentValue = input.value; paintGreeting(currentValue); saveName(currentValue);} // submit 하면 input의 value가 paintGreeting에 의해 프린트 될 뿐만 아니라 savename 에 의해 세팅/저장된다. 그래서 새로고침해도 더이상 없어지지 않음//요약: 입력값을 paint 하는 함수로 보내줌//로직 순서: 2번function askForName() { form.classList.add(SHOWING_CN); // input 창이 나타남 form.addEventListener(&quot;submit&quot;, handSubmit); // 그리고 값을 입력하고 엔터를 누르면 입력된 값이 handsubmit으로 이동.}//요약: 이름을 지정하지 않은 초기에 나타나게 하는 함수. --&amp;gt; 이름을 입력하는 창이 나타남. 그리고 그걸 입력하면 submit 하는 함수로 보내줌//로직 순서: 1번function paintGreeting(text) { form.classList.remove(SHOWING_CN); // input 창이 사라짐 greeting.classList.add(SHOWING_CN); // &amp;lt;h4 . js-greeting&amp;gt; 태그가 나타남 greeting.innerText = `Hello ${text}`; // handsubmit 에 의해 input value가 나타남}//요약: handsubmit 에 저장된 이름값이 나타나게 됨.//로직 순서: 3번function loadName() { const currentUser = localStorage.getItem(USER_LS); if (currentUser === null) { askForName(); //초기에 user의 key가 저장되어있지 않았을때 작동되는 코드. } else { paintGreeting(currentUser); // handsubmit에 의해 저장된 key:currentuser에 해당되는 value값이 paintGreeting의 argument 로 입력됨. }}// 요약: 이름값이 없으면 이름값을 입력하도록 하고 이름값이 있으면 그 값을 띄움. 로직을 시작하고 관리하는 지휘관.function init() { loadName();}init();// 로직이 진짜 얽히고 섥혀있다. 아마 3일만지나도 모든 코드를 다시 읽는데 애먹을듯. 그래서 네이밍, 코드주석이 진짜 중요하겠구나를 느낀다. 이러한 로직을 짜는 니콜라스도 대단타진짜.key, value 입력 됨, class 추가 됨그렇게 input에 이름을 입력하면 아래의 그림과 같이 key,value가 저장된것을 확인 할 수 있다.또한 paintgreeting 함수에 의해 js-greetings 클래스 옆에 showing 클래스가 추가되면서 h4태그가 줄바꿈된 것이 확인 가능하다." }, { "title": "그 유명한 to do list 시작! - 시계만들기", "url": "/posts/vanila1/", "categories": "Javascript, todo-list", "tags": "new Date, setInterval", "date": "2020-09-03 00:00:00 +0900", "snippet": "시계 만들기html 파일 수정이제 모멘텀 extension을 만들기위해 알아야할 문법은 다 배웠으니 실전에 들어가보도록 하자. 우선 html 파일에서 시계가 오는 위치를 정하자.&amp;lt;body&amp;gt; &amp;lt;div class=&quot;js-clock&quot;&amp;gt; &amp;lt;!-- 시계가 들어갈 클래스를 생성하였다. --&amp;gt; &amp;lt;h1&amp;gt;00:00&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script src=&quot;clock.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- 시계를 구현하는 자바스크립트 파일을 새로이 또 추가한다. 항상 나누어서 작업하면 깔끔하고 충돌도 덜 일어난다. 이러한 작업태도를 &#39;divde and concour&#39; 라고 한다. --&amp;gt;&amp;lt;/body&amp;gt;Clock.js 파일 생성(분업화)그리고 clock.js 란 파일을 만들어준다.const clockContainer = document.querySelector(&quot;.js-clock&quot;); // 앞서 생성한 시계 클래스를 선택하고const clockTitle = clockContainer.querySelector(&quot;h1&quot;); //시계 클래스의 child인 h1태그를 세부선택한다. 이렇게 따로따로 지정해놓으면 선별 작업하기 편리해진다.function getTime() { const date = new Date(); // 시간을 나타내주는 객체이다. 큰 틀을 만들었다. const minutes = date.getMinutes(); //분 const hours = date.getHours(); // 시 const seconds = date.getSeconds(); clockTitle.innerText = `${hours &amp;lt; 10 ? `0${hours}` : hours}:${ minutes &amp;lt; 10 ? `0${minutes}` : minutes }:${seconds &amp;lt; 10 ? `0${seconds}` : seconds}`; // ternary operator(삼항연산자) 라고 하고 미니if 라고 읽는다. seconds,minutes,hours 가 10미만이면 0%{seconds} 이고 아니면 그대로 출력한다. --0이 숫자 앞에 붙어서 나오게 하는 과정.}function init() { getTime(); setInterval(getTime, 1000); // 괄호안에 있는 함수를 1초마다 업데이터하는 함수.(1000이라 적은 이유는 백만분의 1이기 때문에) 이 함수가 없으면 그냥 새로고침할때의 시간이 그대로 박제되어있게 된다.}init();//always divide and conquer!" }, { "title": "prototype-중급자로 가기 위한 여정", "url": "/posts/jsBasic5/", "categories": "Javascript, basics(js)", "tags": "blogging", "date": "2020-08-30 00:00:00 +0900", "snippet": "5. proto vs prototype우선 설명하기에 앞서 생성자 함수를 2개 만들자function Person(name, first, second) { this.name = name; this.first = first; this.second = second;}function PersonPlus(name, first, second, third) { Person(name, first, second); this.third = third;}var go = new PersonPlus(&quot;go&quot;, 50, 60, 90);그리고 person을 personplus에 상속한다고 할때 위의 코드처럼하면 상속이 안된다. person이 아직 new를 통해서 객체화되지 않았기 때문에다. 그냥 일반 함수를 호출한것일뿐.여기서 중요한것은 this를 어떻게 실현시킬것인가이다. 바로 call 함수를 사용하는것! “이미 객체인” PersonPlus 함수의 this를 person안에다가 호출하여 Person에 대입하는것이다.function PersonPlus(name, first, second, third) { Person.call(this, name, first, second); this.third = third;}그리고 person생성자에 sum을, personplus 생성자에 avg를 함수를 추가하고 싶다고 하자. 또한 new를 통해서 Personplus 함수를 모체로 하는 kim이라는 새로운 객체를 만들고 싶다.Person.prototype.sum = function () { return this.first + this.second;};PersonPlus.prototype.avg = function () { return (this.first + this.second + this.thrid) / 3;};var kim = new PersonPlus(&quot;kim&quot;, 10, 20, 30);그리고 PersonPlus 생성자 함수에다가 person의 sum 함수를 상속하고 싶다. 여기서 복잡해진다. 먼저 각 객체안에 default로 담겨진 property가 있다. 바로 __proto__ 이다. 그 __proto__의 관계와 , 특히 proto와 prototype의 관계를 잘 이해해야한다. 근데..이게 무슨 개소리야 할것이다.이고잉님이 정말 친절하게 그림으로 잘 설명해주셨다. 아래 그림을 살펴보자.우선 kim.avg()를 입력해보자. 그럼 컴퓨터는 우선 kim 안에서 avg()를 찾으려고 할 것이다. 없으면 kim안에 있는 __proto__ 함수에서 찾으려고 할 것이다. 거기도 없으면 오류가 발생한다. proto 링크의 방향은 이런식으로 형성된다. avg() 함수같은 경우 kim의 __proto__안에 있으므로 문제없다. 문제는 kim.sum() 을 호줄하려고 할때이다. __proto__에도 없으므로 오류가 발생한다.그럼 proto링크를 생각해봤을때 PersonPlus.prototype.__proto__ = Person.prototype 라는 로직을 짜면 문제가 없을것이다.PersonPlus.prototype.__proto__ = Person.prototype;//또는PersonPlus.prototype.sum = Person.prototype.sum;console.log(kim.sum());// 110근데 __proto__는 비공식적인 방법이고 좀더 안전하고 효율적인 Object.create()를 사용해주자.PersonPlus.prototype = Object.create(Person.prototype);console.log(kim.avg());// avg() is not a function근데 요렇게 바꾸면 personplus의 prototype이 person의 prototype으로 상속된다. 그러면 기존에 personplus.prototype에 추가한 avg() 함수가 덮어씌어지면서 avg() 함수가 없어진다. 따라서PersonPlus.prototype.__proto__ = Object.create(Person.prototype);console.log(kim.avg());// 66.66666//또는PersonPlus.prototype = Object.create(Person.prototype);PersonPlus.prototype.avg = function () { return (this.first + this.second + this.third) / 3;};console.log(kim.avg());// PersonPlus.prototype를 교체한다음 avg()를 다시 추가하면 사용가능하다.이렇게 해야 avg() 함수도 살아남으면서 person.prototype 안에 있는 sum 함수도 사용할 수 있게 된다.P.S: 참고로 객체의 모체를 알고 싶다하면.(너의 정체, 원래 클래스가 뭐냐..?) 객체.constructor 라고 하면 된다. 다시 위의 그림을 보자. constructor 함수는 다시 모체 객체를 가리키고 있기 때문이다. 여기서 더 나아가 생각해보면PersonPlus.prototype = Object.create(Person.prototype);라고 한다면 PersonPlus.prototype은 Person.prototype 로 교체되었기 때문에 PersonPlus.prototype.constructor = Person 이 될것이다.사실 함수객체끼리 상속하기 보다 클래스를 만들어서 super()를 사용해 상속하는게 훨씬 깔끔하고 쉽다. 근데 proto 링크를 알아두는 것은 자바스크립트 중급자로 가기위한 필수 관문이므로 자바스크립트를 주 언어로 한다면 꼭 알아두어야 할것이다." }, { "title": "런타임 환경", "url": "/posts/jsBasic15/", "categories": "Javascript, basics(js)", "tags": "runtime", "date": "2020-08-29 00:00:00 +0900", "snippet": "1. runtime 환경에 대해서자 그럼 자바스크립트가 실제로 브라우저에서 어떻게 동작하는지 알아보자. 동작하는 환경을 일단은 runtime environment라고 한다(이하 runtime). 그리고 그곳에서 자바스크립트 엔진과 브라우저는 서로 소통을하면서 협동한다. 이때 협동할 수 있게 소통을 돕는 아이가 바로 event loop이다. event loop는 while(true)의 형태로 되어있어서 항상 작동하는 아이다. 그림으로 표현하면 아래와 같다.우선 각각의 용어를 먼저 살펴보자.콜스택은 자바스크립트 엔진안에 있는 실행순서다. 그리고 web browser에는 큐스택, 마이크로스택, 랜더가 있다.(상황마다 더 추가될 수 있지만 크게 요렇게 3가지가 있다)이벤트loop는 콜스택, 큐스택, 마이크로스택, 랜더를 순회하면서(한번 순회할때 걸리는 시간이 1ms정도 밖에 걸리지 않을 정도로 매우 빠르다) 각각의 스택에 쌓인 일들을 수행한다. 또한 어떤 스택을 먼저 실행하는지는 브라우저마다 다르다.우선 콜스택에 있는 애들을 처리한다. 큐스택은 한번에 하나만 처리한다. 그리고 순회하고 나서 큐스택에 다음 작업을 처리한다. 마이크로스택은 큐스택과는 다르게 한번 방문하면 마이크로스택안에 있는 모든 작업을 순서대로 처리하고 나서 순회를 시작한다.또한순회하다가 16.7ms가 지나면 랜더안에서 처리해야할 애니메이션이 있는지 확인하고 있으면 한번 뿌려주고 다시 순회한다. 여기서 뿌려준다는 건 render tree -&amp;gt; layout(크기 위치 계산) -&amp;gt; paint를 말한다. (16.7ms마다 한번씩 뿌려주어야 60프레임이 되고 그래야 우리눈에 자연스럽게 보임)만약 콜스택에 많은 작업을 해야하는 함수가 쌓여있다면 그 외에 랜더 스택이나(애니메이션) 큐스택(클릭이벤트 같은거) 에 있는 아이들이 콜스택안에 있는 모든 작업이 끝나기 전까지 실행되지 않는다. 따라서 콜스택안에서는 가벼운 기능을 수행하는 함수를 쌓아놓는게 좋다.예를 들어 아래와 같은 코드가 있다고 해보자.const button = document.querySelector(&quot;button&quot;);button.addEventListener(&quot;click&quot;, add);function add() { const head = document.createElement(&quot;h1&quot;); document.body.appendChild(head); head.style.color = &quot;red&quot;; head.innerText = &quot;hello&quot;;}자바스크립트 엔진은 클릭함수를 browser web api에 저장한다음 클릭하면 add가 큐스택에 저장되어있다가 이벤트루프가 순회하면 그제서야 add가 콜스택으로 옮겨져 실행이 되고 다시 이벤트루프가 순회하면서 준비된 head가 render 되어 browser에 hello가 표시되는 것이다.비유를 하자면 “다음 무대에 올라갈 사람은 너야!” 라고 지목된(appendChild) A 배우(element)가 백 스테이지에서 메이크업(style, innerText)을 받고 순서가 되자 무대에 올라간(Render)다.그래서 사실상 append를 하고 스타일을 입히나 스타일을 입히고 append를 하나 차이가 없다. 메이크업을 하고 지목하나 지목하고 메이크업을 하나 똑같기 때문.loupe라는 웹사이트에서 벡엔드에서 일어나는 이러한 과정을 시각화시켰다." }, { "title": "프로세스와 쓰레드", "url": "/posts/jsBasic14/", "categories": "Javascript, basics(js)", "tags": "process, thread", "date": "2020-08-29 00:00:00 +0900", "snippet": "1. 프로세스와 쓰레드이번엔 자바스크립트가 브라우저라는 공간에서 작동할때 어떤 일이 실제로 ‘뒤’ 에서 발생하는지 알아보고자 한다. 따라서 자바스크립트라는 언어의 동작원리를 좀더 구체적으로 이해함으로써 효율적인 코드작성이 가능할것이다. 그전에 프로세스와 쓰레드 부터 알아보자. 그림으로 나타내면 이렇게 나타낼 수 있다.운영체제(윈도우) 안에서 여러가지 프로세스(vs code, chrome, itunes..) 가 작동한다. 이 프로세스는 각각 독립적으로 활동하기에 하나가 죽어도 다른 프로세스는 여전히 동작한다. 그리고 프로세스안에 기능을 구현하기 위한 여러가지 것들이 들어있다. heap 안에는 동적변수 data에는 전역변수, static 변수가 저장되어있다. 누가 쉽게 비유를 들어서 나도 그 비유를 가지고 설명하려고 한다.Operation system &amp;gt; 공장Process &amp;gt; 생산라인Thread &amp;gt; 일꾼한 공장 내에서 다양한 것들을 생산하는 라인이 작동한다.일꾼이 1명뿐인 라인은 그 일꾼이 A라는 일도 하고, B라는 일도 해야할 때 A를 끝내고 나서야 B를 할 수 있다.일꾼이 2명이 되면, 한 일꾼은 A를 하고 다른 일꾼은 B를 동시에 할 수 있다.각 일꾼은 자기가 해야 하는 일의 순서를 기억하고 있다.단, 일꾼이 같은 공구(공유 리소스)를 사용할 때 한 사람이 쓰고 제자리에 가져다 놓지 않는다거나 하는 문제가 발생할 수 있다.(멀티쓰레딩 - 한 프로세스안에서 여러가지 쓰레드가 동시다발적으로 일어나는 현상)자바스크립트는 싱글쓰레드 언어이다.자바스크립트가 실제 실행되는 런타임 환경에서 콜스택을 보면 코드상에서 실행된 순서대로 콜스택에 쌓이게 된다. 만약 재귀함수(자기 자신을 불러오는 함수) 콜스택에서는 먼저들어온 아이가 나중에 끝나가 됨(LIFO - Last In Last Out)태스크 큐라는 것도 있다. 바로 web api에서 실행한 task가 저장되는 곳, 자료구조이다. 예를 들어, setTimeout web api를 실행할때 setTimeout에 있는 콜백함수는 태스크 큐에 저장되고, 콜스택에 있는 작업이 모두 끝나면 테스크 큐에 있는setTimeout콜백이콜스택으로 옮겨지면서 한번에 하나씩 실행이 된다.이렇게 콜스택과 테스크 큐를 서로 왔다갔다 하면서 관찰하고 순서대로 일이 진행되도록 하는 아이가 event loop이라는 것이다.더 자세한 내용은 runtime loupe 영상을 보면 된다. event loop라는 것은 다음글에서 설명하도록 하겠다." }, { "title": "이벤트 위임", "url": "/posts/jsBasic13/", "categories": "Javascript, basics(js)", "tags": "delegation, bubbling", "date": "2020-08-29 00:00:00 +0900", "snippet": "1. bubblingbubbling은 이름 그대로 방울이 겹쳐서 연속적으로 무엇인가가 올라가는 그림을 그리면 된다. 부모태그와 자식태그에 설정된 이벤트가 같다고 했을때 자식태그에 있는 이벤트가 실행되면 상위에 있는 부모태그 모두가 다같이 실행되는 현상이 bubbling이다. 설정된 이벤트가 방울처럼 부모쪽으로 퍼져나간다고 생각하면 더 이해하기 쉬울 것 같다. 예시를 통해 살펴보자.outer &amp;gt; middle &amp;gt; button 순으로 위계질서가 형성되어있고 각각의 태그에 click 이벤트가 설정되어있으며 클릭했을때 현재 위치해있는 태그, 이벤트가 실행된 위치 가 출력되도록 했다. 이때 button을 클릭하니 middle / outer 의 이벤트 까지 실행된것을 볼 수 있다.만약 button에다가 두개의 이벤트를 등록한다면 어떻게 될까? 화면상에서 먼저 설정된것이 실행될 것이다.그럼 부모태그에 있는 이벤트가 실행되지 않게 하려면 어떻게 해야할까?로직을 생각해보면, event.target !== currentTarget 이라는 명령을 추가해주면 된다.outer.addEventListener(&#39;click&#39;, event =&amp;gt; { if (event.target !== event.currentTarget) { return; } // 그게 아니면 console.log(~~~)})2. 이벤트 delegation(위임)따라서, 이벤트를 등록해야할 대상이 너무 많다면은 그 대상을 다른 부모태그로 감싼 다음 부모 태그에 이벤트를 설정해주면 bubbling 현상으로 인해서 부모안에 있는 모든 자식태그들에 부모와 동일한 이벤트가 등록된다. 아주 깔끔해진다. 일일이 이벤트를 등록하지 않아도 되서. 그리고나서 자식태그를 클릭하면 부모태그에 등록된 이벤트 콜백함수가 실행된다. 그렇기 때문에 mini_shopping_game 에서 section 부모태그에만 이벤트를 등록한것이다." }, { "title": "재밌는 디버깅방법", "url": "/posts/jsBasic12/", "categories": "Javascript, basics(js)", "tags": "debugging", "date": "2020-08-29 00:00:00 +0900", "snippet": "1. 개발자 도구를 통해 디버깅 하는 법진짜 신기한 기능을 알았다. 클릭 할때 마다 모든 과정이 순차적으로 실행되고 과정마다 어떤 일이 일어나는지 상세히 설명해주는 기능이다. 우선 개발자 도구에서 sources 에 들어간다. 그리고 왼쪽에 자바스크립트를 클릭한다음 오른쪽 상단에 pause를 클릭한다. 그리고 watch를 통해서 내가 특정 영역의 변화상황을 자세히 관찰할 수 있다.예를들어 submit 했을때 event의 target이 무엇인지 확인하고 싶다고 한다면 console.log(event)라고 하고 콘솔창을 봐도 되지만, watch를 통해 곧바로 확인 가능하다. watch에 + 버튼을 클릭한다음 event를 등록하자. 지금은 undefined라고 되어있지만 나중에 monitoring이 실행되면 event가 활성화 되면서 안에 있는 정보가 나타날 것이다.그럼 이제 monitoring할 준비가 끝났다. 웹페이지에서 어떤 기능을 실행한다. 이번 경우에는 shopping_list 프로젝트를 실행해보았다. submit을 하자마자 submit event가 실행이 되고 오른쪽에 watch에 특정 event가 출력이 된다.그리고 JS 파일안에서 현재 어떤 단계에 위치해있는지 초록색으로 표시가 된다. 그러고 나서 오른쪽 상단에 아래쪽으로 향하는 화살표를 클릭하면 로직이 차례대로 실행이 된다. 더 신기한것은 로직 옆에 그 로직이 실행될때 PASS 되거나 생성되야하거나 하는 등등의 결과들이 작게 빨간색으로 표시가 된다.그와 동시에 scope를 보면 지금 해당 단계에서 작동하는 함수라던가 parameter같은 정보들을 상세히 설명하고 있다.모든 로직이 처리가 되면 마침내 input에 입력되었던 값이 list에 출력이 되면서 monitoring은 끝난다.이 얼마나 친절하고 편리한 기능인가!! 일일이 로그를 통해 확인하지 않아도 되고 어디서 어떤일이 일어나는지 차근차근 선택하며 확인할 수 있기에 디버깅을 하는데 매우 유용하게 쓰일 것 같다.2. 콘솔로그에서 queryselector(‘선택자’) 를 통해서 원하는 노드를 찾아내는 방법이건 콘솔 로그에서 이런 기능이 있다는게 신기해서 포스팅한다. 디버깅할때 어느정도 도움이 될 수 도 있을 거 같다. 만약에 사과 라는 class를 찾고 싶다고 할때 콘솔창에 document.querySelector(&#39;.사과&#39;) 라고 입력하면 아래와 같은 결과가 나온다.&amp;lt;li class=&quot;사과 list&quot;&amp;gt; &amp;lt;span&amp;gt;사과&amp;lt;/span&amp;gt; &amp;lt;button class=&quot;delete_btn&quot;&amp;gt;🗑&amp;lt;/button&amp;gt;&amp;lt;/li&amp;gt;JS에서 입력할때 처럼 똑같이 입력하면 된다. 그럼 다음 포스팅에서는 미니쇼핑 프로젝트 진행할때 이벤트 위임을 통해 모든 자식 태그에 click이벤트를 위임할 수 있었다. 그 원리가 무엇이었는지 알아보겠다." }, { "title": "간단한 과제(toggle로 커서유지)", "url": "/posts/jsBasic11/", "categories": "Javascript, basics(js)", "tags": "toggle", "date": "2020-08-29 00:00:00 +0900", "snippet": "커서 유지하기.우선 글자를 클릭할때마다 색깔이 바뀌게 했다. css 파일안에 몇가지 변화를 추가했다. 첫번째로, pointer클래스를 추가하고 그안에 커서를 올릴때 커서모양으로 바뀌는 효과를 추가했다. 또한 컬러가 바뀔때 서서히 바뀌게 하는 효과도 추가하고 , clicked 라는 클래스를 만들고 (일종의 변수를 지정) 그 안에 새로운 컬러를 추가하였다. 그다음 html파일안에 title태그에 class = &quot;pointer&quot; 라고 추가했다..pointer { cursor: pointer; /* 커서를 위에 올려놓을때 포인터가 생기게 함 */}h1 { color: #34495e; transition: color 0.5s ease-in-out; /* 컬러가 바뀔때 0.5초정도 시간을 두고 자연스럽게 바뀌게 하는 효과 */}.clicked { color: #7f8c8d;}&amp;lt;body&amp;gt; &amp;lt;h1 id=&quot;title&quot; class=&quot;pointer&quot;&amp;gt;This will work. so Don&#39;t worry&amp;lt;/h1&amp;gt; &amp;lt;script src=&quot;index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;그래서 clicked 라는 클래스를 검사를 통해 임시로 추가해보면 title 글자가 바뀌는 것을 알 수 있다. 근데 문제는 아래의 함수를 실행 했을때 글자색깔이 바뀌고 나서 커서가 사라져버린다…ㅠㅠㅠconst CLICLKED_CLASS = &quot;clicked&quot;;function handleClick() { const currentClass = title.className; //클래스의 이름을 title에 추가하는 것이다. if (currentClass !== CLICLKED_CLASS) { //클래스 이름이 clicked 가 &#39;아니면&#39; title.className = CLICLKED_CLASS; } else { title.className = &quot;&quot;; // 클래스가 없으면 다시 본래의 색깔로 돌아옴 }}function init() { title.addEventListener(&quot;click&quot;, handleClick);}init();// 문제는 class = &quot;pointer&quot; 를 html 안에 h1 태그에 추가 했는데 클릭하고 나서 handleClick 함수때문에 class = &quot;&quot; 가 되면서 포인터가 없어진다.// 그럼 아래 처럼 바꾸면 된다.(참고로 MDN 에서 검색했다. 로직을 심플하고 강력하게 짜는것도 중요하지만, 제대로 검색하고 찾아내는것도 매우 중요하다.)const CLICLKED_CLASS = &quot;clicked&quot;;function handleClick() { const hasclass = title.classList.contains(CLICLKED_CLASS); //CLICKED_CLASS가 있느냐 없느냐? 이 자체가 BOOLEAN 이다. if (hasclass) { title.classList.remove(CLICLKED_CLASS); // CLICKED_CLASS 있으면 지우고 } else { title.classList.add(CLICLKED_CLASS); // 없으면 추가해라. }} // 단순히 clicked 클래스만 도려내는 것이기 떄문에 class = &quot;pointer&quot;에는 영향을 주지 않는다. 그래도 유지된다.function init() { title.addEventListener(&quot;click&quot;, handleClick);}init();// 근데 더 리팩토링 할 수 있음. toggle 메소드를 사용하면 된다. FUCKING AWESOME LOLconst CLICLKED_CLASS = &quot;clicked&quot;;function handleClick() { title.classList.toggle(CLICLKED_CLASS); // CLIKCKED 클래스가 있으면 끄고 없으면 켜라는 뜻이다. 진짜 한방에 정리해준다.}function init() { title.addEventListener(&quot;click&quot;, handleClick);}init();" }, { "title": "DOM 을 정복해보자", "url": "/posts/jsBasic10/", "categories": "Javascript, basics(js)", "tags": "DOM", "date": "2020-08-29 00:00:00 +0900", "snippet": "DOMDOM은 Document Object Model 의 약자로 객체를 이용해 html 이나 xml 을 수정, 보완, 생성, 삭제 등 modify 할 수 있는 기능을 말한다.//자바스크립트 document 객체로 html 상의 정보를 변경할 수 있다.console.log(document); // html 안에 있는 모든 라인을 뽑아냄.const title = document.querySelector(&quot;#title&quot;); // id = &quot;title&quot; 이라는 라인을 뽑아냄console.log(title);title.innerHTML = &quot;Haloo, changed.&quot;; // id = &quot;title&quot; 이라는 라인안에 있는 내용을 변경함.console.dir(title); // title id 의 기능을 보여줌.title.style.color = &quot;#9e63d9&quot;; // 위코드의 결과로 나온 기능중에 하나 써보자. 글자 색깔 변경console.dir(document);document.title = &quot;yoyoyo&quot;; //이걸로 홈페이지 제목 변경가능이제 title.~~~~라고 하면 index.html 파일안에 있는 id = title 의 영향을 받고 있는 This will work. so Don&#39;t worry 글자(이하 title 글자)를 modify 할 수 있게 된다. 이게 DOM 의 힘이다.EVENT이벤트는 말그대로 어떤 변화가 발생 했을때, 무언가가 바뀌는 것을 의미한다.function handleResize() { console.log(&quot;I have been resized yo&quot;);}window.addEventListener(&quot;resize&quot;, handleResize);// eventlistener는 지금 resize(웹창의 크기 바뀜)이벤트를 기다리고 있으며 크기가 바뀔때 마다, handleresize 함수를 불러온다.function changeColor() { title.style.color = &quot;blue&quot;;}window.addEventListener(&quot;click&quot;, changeColor); // title 글자를 클릭 했을때 changeCOlor 함수 작동함." }, { "title": "getter와 setter와 call함수", "url": "/posts/jsBasic4/", "categories": "Javascript, basics(js)", "tags": "blogging", "date": "2020-08-28 00:00:00 +0900", "snippet": "3-3. 클래스의 getter(획득자) 와 setter(설정자)또한 획득자와 설정자라는 method 가 있다. 함수처럼 생긴 mothod 이지만 함수가 아니다. 가상의 함수이다. constructor에서 설정한 property(_carname)를 가져와서 set 할때 쓰이는 method들이다. 그리고 get 의 이름은 property랑 달라야한다. 예를 들어 사용자가 잘못 정보를 기입할 경우 그것을 컴퓨터가 알아들을 수 있게 설정하기 위함이다. 사용자가 잘못 설정한 정보를 get해서 가져온다음 set으로 올바르게 설정하는 것이다. 이때 get/set 함수의 이름은 다룰 property의 이름과 달라야한다.(보통 _를 통해 구분한다.) 안그럼 set 함수에서 끊임없이 호출되기 때문에 오류가 뜬다. property를 다르게 해도 내부적으로 set함수에서 설정한 _age를 다시 age에 할당하므로 호출할때는 User.age라고 해도 된다.만약 사용자가 user 나이를 실수로 0보다 아래로 설정했을 경우가 있으므로 아래와 같이 get/set을 이용해서 그 경우를 막아준다. 그래서 0보다 아래의 나이를 입력했을 경우 경고창을 뜨게 하거나 0으로 age가 설정되게끔 세팅할 수 있다.class User { constructor(firstName, secondName, age) { this.firstName = firstName; this.secondName = secondName; this.age = age; } get age() { return this._age; } set age(value) { // 요건 공격적인 방법 // if(value &amp;lt; 0) { // throw Error(&#39;age can&#39;t be negative&#39;) // } // 아래건 좀 젠틀한 방법 this._age = value &amp;lt; 0 ? 0 : value; }}let User1 = new User(&quot;영훈&quot;, &quot;고&quot;, &quot;-1&quot;);console.log(User1.age);//04. 일반 함수를 객체안에 집어넣는 방법??여기서 자바스크립트가 특이한 이유가 하나 더 있다. 바로 독립적으로 존재하는 함수를 객체 안에다가 메소드로서 넣을 수 있다는 것이다 바로 call 메소드를 통해서 말이다.앞에서 bind설명할때 잠깐 설명했지만, 객체안에 함수가 존재하므로 함수의 스코프는 객체의 스코프 안에 존재한다. 따라서 sum 함수의 this는 sum을 감싸고 있는 객체가 되므로 sum 안에 있는 this.first가 실행되는 것이다.var kim = { first: 10, second: 20 };var lee = { first: 20, second: 50 };function sum(para) { return para + (this.first + this.second);}// sum 함수와 객체 연계시키기. 문법: call(연계시키고 싶은 함수, 그 함수안에 들어갈 parameter..)console.log(sum.call(kim, &quot;kimpara: &quot;));console.log(sum.call(lee, &quot;leepara: &quot;));// kimpara: 30// leepara: 50//그럼 kim 객체에 sum 함수가 추가된것일까?console.log(kim.sum());// kim.sum is not a function// 객체의 속성을 바꾸는 것이 아닌 일시적으로 kim의 property를 불러내서 사용하는것인것 같다.call 과 비슷한 기능이 있는데 바로 bind 라는 메소드이다. call 과 차이점은 call같은 경우 만드는 즉시 사용되는데 반해 bind는 함수를 나중에 호출 하게 한다. 다시말해 변수에 할당한다음 사용가능하다.(bind는 새로운 함수를 다시 만들어서 호출하기 때문)extends 위의 코딩 ㅋㅋㅋvar kimBind = sum.bind(kim, &quot;bindKim: &quot;);console.log(sum.call(kim, &quot;call: &quot;));console.log(kimBind);console.log(kimBind());// call: 30// ƒ sum(para) {// return para + (this.first + this.second);// }// bindKim: 30다음글에선 생성자 함수끼리 proto 링크를 지정하고 그리하여 생성자함수를 상속를 상속하는 방법을 알아보자. 이때까지 배웠던 내용이 심화되기 때문에 이해하기 어려울것이다.그리고 이 어려운 개념을 쉽고 의미있게 알려주신 이고잉님께 정말 감사한 마음이 든다." }, { "title": "콜백지옥에서 구원받기2(async/await)", "url": "/posts/jsBasic9/", "categories": "Javascript, basics(js)", "tags": "async/await", "date": "2020-08-27 00:00:00 +0900", "snippet": "9. async/await 배우기promise 를 통해 구현하게 되면 then을 통해서 계속해서 앞의 return값을 받아와야하기 때문에 명령이 길어지게 된다. async를 이용하면 함수안에 깔끔하게 담아서 정리가능하다. 우선 과일을 따는 함수를 만들어 보겠다.// resolve 를 선언하기만 함.function delay(ms) { return new Promise((resolve) =&amp;gt; setTimeout(resolve, ms));}// 위의 코드는 아래의 코드와 같다. async 키워드는 자동으로 promise를 만들어준다.async function delay(ms) { return setTimeout(resolve, ms);}// async는 뭐든지 prmomise를 return 하게한다.//await는 async안에서만 쓸수 있으며 promise를 기다린다.async function getApple() { // delay를 통해 resolve가 성립이 되면 return 하도록 하는게 await키워드이다. then이랑 같은 역할을 한다고 보면 됨. await delay(1000); return &quot;🍎&quot;;}async function getBanana() { await delay(1000); return &quot;🍌&quot;;}9-1. 바나나와 사과를 모두 따는 함수그럼 이제 바나나와 사과 모두를 따는 함수를 만들어보자.// 다시 콜백지옥이 떠오름. nesting이 중복되지 않도록 하는게 좋다 항상.function pickFruits() { return getApple().then((apple) =&amp;gt; { return getBanana.then((banana) =&amp;gt; `${apple} + ${banana}`); });}// async랑 await를 사용하면 앞서 then을 체이닝 한것과 같은 효과가 나타난다.// 그래서 await하고 apple promise가 성공하면 banana로 넘어가는 것이다.async function pickFruits() { const apple = await getApple(); const banana = await getBanana(); return `${apple} + ${banana}`;}근데 사실상 apple과 banana는 서로 연계되어있는 작업이 아니라서 기다릴 필요없다. 그래서 동시에 실행되도록 하는게 더 빠르다.async function pickFruitsFast() { // promise 가 만들어지자 마자 실행되는 특성을 이용해서 병렬적으로 동시에 실행하도록 할 수 있다. // 그래서 사과와 바나나를 동시에 딴다음 기다렸다가 출력하면 된다. const applePromise = getApple(); const bananPromise = getBanana(); const apple = await applePromise; const banana = await bananPromise; return `${apple} + ${banana}`;}pickFruitsFast().then(console.log);9-3. 더 간단하게!근데 이것 마저도 간단하게 만들수 있는 API가 있다. 바로 all 이라는 거다.async function pickAllFruits() { return Promise.all([getApple(), getBanana()]).then((fruits) =&amp;gt; fruits.join(&quot; + &quot;) );}pickAllFruits().then(console.log);// 또는 둘중에 먼저 완료되는 것을 먼저 return 하는 API도 있다.// 바로 race 라는 거다async function pickFirstOne() { return Promise.race([getApple(), getBanana()]);}pickFirstOne().then(console.log);그럼. callback_to_promise 를 async와 await를 이용해서 refacotring 해보자" }, { "title": "콜백지옥에서 구원받기1(Promise배우기)", "url": "/posts/jsBasic8/", "categories": "Javascript, basics(js)", "tags": "blogging", "date": "2020-08-27 00:00:00 +0900", "snippet": "7. Promise 배우기말 그대로 약속하는 함수이다. promise안에 있는 어떤 조건이 완료가 되면 그 안에 있는 데이터를 return하겠다고 약속하는 것이다. Promise 함수안에는 resolve,reject를 인자로 하는 execute함수가 반드시 들어가야한다. 그래서 resolve함수에 문제가 없으면 resolve 안에 들어간 인자를 return 한다. 인간의 성장을 표현하는 과정을 promise로 나타내 보았다.const baby = () =&amp;gt; new Promise((resolve, reject) =&amp;gt; { // 서버에서 데이터를 받아오는데 시간이 걸리므로 setTimeout을 통해 흉내내보았다. setTimeout(() =&amp;gt; resolve(&quot;👶&quot;), 1000); });const child = (baby) =&amp;gt; new Promise((resolve, reject) =&amp;gt; { setTimeout(() =&amp;gt; reject(new Error(`error: ${baby} =&amp;gt; 👦`)), 1000); });const adult = (child) =&amp;gt; new Promise((resolve, reject) =&amp;gt; { setTimeout(() =&amp;gt; resolve(`${child} =&amp;gt; 👨`), 1000); });baby() .then(baby =&amp;gt; child(baby)) .then(child =&amp;gt; adult(child)) .then(adult =&amp;gt; console.log(adult)); .finally(() =&amp;gt; console.log(&#39;we all growing. so dont forget to eat kimchi&#39;));// 근데 then에 들어가는 함수의 parameter와 함수안에 들어가는 인자가 같을때는 생략하고 코드를 작성해도 문제없다.baby() // .then(child) .catch((error) =&amp;gt; { return `🎅`; }) .then(adult) .then(console.log) .finally(() =&amp;gt; console.log(&quot;we all growing. so dont forget to eat kimchi&quot;));//🎅 =&amp;gt; 👨// we all growing. so dont forget to eat kimchiPromise 함수를 만들고 then을 통해 return값을 받은다음 그 값을 다른 함수에다가 pass할 수 있다. 그러나 child 에서 일부러 reject되도록 해보았다. 그때는 .catch 라는 메소드를 통해 에러를 말그대로 잡아서 처리할 수 있다. 그래서 에러가 생기면 산타할아버지를 return하도록 했다. 그리고 .finally 메소드를 통해 코드 마지막에 무조건 발생하는 기능을 추가해보았다.이런식으로 promise함수안에서 문제가 없으면 resolve안에 있는걸 넘겨주도록 약속한다. 만약 문제가 있으면 reject안에 있는걸 넘겨주도록 하는것이다. 그리고 then을 통해 계속해서 앞의 promise를 넘겨받고 갱신한다. 이어달리기 처럼 말이다. 그럼 promise를 통해 콜백지옥을 선사했던 코드를 구해주자." }, { "title": "콜백지옥..", "url": "/posts/jsBasic7/", "categories": "Javascript, basics(js)", "tags": "blogging", "date": "2020-08-27 00:00:00 +0900", "snippet": "6. 콜백지옥콜백함수에 대해서 어느정도 알았다. 그런데 콜백 지옥이라는 것이 있다. 콜백함수안에 콜백함수가 있고 그 콜백함수 안에 또 다시 콜백함수가 있는 식이다. 끊임없이 nesting되어진 함수들인데 가독성이 무지하게 떨어져서 디버깅할때 상당히 힘들다. 예제를 한 번 보자.class UserStorage { loginUser(id, password, onSuccess, onError) { setTimeout(() =&amp;gt; { if ( (id === &quot;yeong&quot; &amp;amp;&amp;amp; password === &quot;5493&quot;) || (id === &quot;zzak&quot; &amp;amp;&amp;amp; password == &quot;3927&quot;) ) { onSuccess(id); } else { onError(new Error(&quot;notd found&quot;)); } }, 2000); } getRoles(user, onSuccess, onError) { setTimeout(() =&amp;gt; { if (user === &quot;yeong&quot;) { onSuccess({ name: &quot;yeong&quot;, role: &quot;admin&quot; }); // console.log(onSuccess); } else { onError(new Error(&quot;no acess&quot;)); // console.log(onError); } }, 1000); }}const userStorage = new UserStorage();// input과 비슷한게 prompt이다. alert 창 같은게 뜨면서 값을 입력하라고 한다.const id = prompt(&quot;enter your id&quot;);const password = prompt(&quot;enter your password&quot;);userStorage.loginUser( id, password, (user) =&amp;gt; { userStorage.getRoles( // 여기서 user 는 loginUser 함수안에 있는 onSuccsess(id) 함수에 인자로 들어가는 id이다. user, (userWithRole) =&amp;gt; { alert( `Hello ${userWithRole.name}, you have a ${userWithRole.role} role` ); }, // 요 함수는 요렇게 나타낼 수 있다. getRoles함수 에서 함수의 인자로서 객체를 넣었다는 것을 잘 한번 생각해보자. // function blabla(userWithRole={ name: &#39;yeong&#39;, role: &#39;admin&#39; }) { // alert( // `Hello ${userWithRole.name}, you have a ${userWithRole.role} role` // ); // } (error) =&amp;gt; { console.log(error); } ); }, (error) =&amp;gt; { console.log(error); });// userstoage &amp;gt; onsuccess &amp;gt; getroles &amp;gt;userwithRole식으로 함수가 계속해서 nesting되는것을 callbak hell이라고 함. 가독성이 매우 떨어져 디버깅할때 애를 먹음UserStorage란 클래스 객체를 만들고 안에 loginUser / getRoles 라는 메소드를 만들었다. 그래서 id=yeong / password=5493을 입력하면 adimn 이라는 문구가 뜨면서 잘 로그인 되었다는 로직을 만든다고 하자. loginUser 안에서 id/password를 잘 입력하면 성공했다는 함수를 콜백한다. 그리고 성공했다는 함수안에서 admin이라고 alert되는 함수를 또다시 콜백한다. 잘 동작은 한다.(참고로 여기서는 arrow 함수가 많이 쓰였다.) 근데, 이렇게 함수가 nesting되면 얼핏봐도 몇번째 인자가 어떤 인자인지 헷갈린다. 그래서 이런 코딩은 지양하는게 좋다.그럼 어떻게 해결할 수 있을까? 바로 promise를 사용하면 된다. 다음 글로 넘어가서 해결해보자" }, { "title": "비동기 함수", "url": "/posts/jsBasic6/", "categories": "Javascript, basics(js)", "tags": "blogging", "date": "2020-08-27 00:00:00 +0900", "snippet": "6. async 콜백함수콜백함수는 다른 함수의 인자로 들어가는 함수를 말한다. 흔히 비동기적(asynchoronous, 동시에 일어나지 않는, 다른걸 하고 있는 중에 일어나는, 순서대로 일어나지 않는)인 명령을 내리고 싶을때 사용한다.예를 들어 a = func / b = func이라고 할때. a(b) 라는 명령이 있다고 하자. 그럼 a 함수안에 있는 내용이 실행되고 나서 b 함수가 실행된다. 정확히 말하면 a 함수가 실행되는 상태에서 독립적으로 b 함수가 실행되는 상태라고 할까? “우리가 전달해준 함수를 나중에 너가 불러와” 라고도 할까? 우선 코드를 보자//function print() { console.log(&quot;hello&quot;);}console.log(&quot;1&quot;);setTimeout(print, 1000);console.log(&quot;2&quot;);// 1// 2// hello//todoForm.addEventListener(&quot;submit&quot;, handleFormSubmit);//setTimeout 함수는 함수인자와 시간인자를 받는다. 위의 코드는 “브라우저야 1초 지나고 나서 print 함수를 다시 불러줘(콜백)” 라고 말하는 것이다. 그럼 위의 순서대로 출력된다.eventlistner 메소드도 마찬가지다. “submit을 했을때 인자로 넣은 handleFormSubmit 함수를 다시 불러와줘” 라고 말하는 것이다. 이런식으로 동기적으로 실행되는게 아니라 언제 그 함수가 실행될지 예측할 수 없는 상태이다.예를들어서 다음과 같은 함수가 있다고 보자.shoppingWeb().then(shoppingData).then(shoppingDataDisplay);관리자가 원하는 것은, shoppingWeb에서 사용자가 쇼핑을 하고 물건을 클릭하면 그 클릭한 물건을 data로 저장한다음 관련된 물건을 web에 띄워서 사용자가 관련된 물건까지 사게하고 싶은거다. 이때 동기적으로 처리한다면 클릭하는 순간 data형태로 저장 -&amp;gt; 웹에 표시의 과정을 거칠것이다. 그럼 사용자는 매번 클릭할때마다 기다려야한다. 이때 비동기적 방법을 사용해야한다. promise를 하는거다.따라서 일단 shoppingWeb에서 사용자가 하고싶은거 다하게 하고 data가 다 수집되어 저장되면 then을 통해 그제서야 display 하게 하는게 훨씬 효율적이다. 비유를 하자면 then은 shoppingWeb을 향해서 손을 뻗어서 data가 오기를 기다리고 있는거다.또한, 콜백은 사용자에게 어떠한 처리방법을 위임하기도 한다. 그리고 이러한 콜백함수를 이용해서 AJAX(Asynchronous Javascript And Xml) 가 가능하기도하다. 예를 들어, 아래와 같은 순서대로 동작해야한다고 생각해보자.1. 사용자가 댓글을 단다.2. 댓글단 사용자에게 서버가 메일을 보낸다.3. 댓글이 표시된다.순서대로 일어나는것을 동기적으로 일어난다고 말한다. 만약 만명이 댓글을 달고 메일을 보내는데 1초가 걸린다고 하면 10000초가 걸린다.(동기적으로 처리한다고 할 경우). 그리고 3번이 실행된다. 그럼 댓글이 표시될때까지 3시간이나 기다려야한다. 그래서 2번을 예약하고 바로 3번으로 가도록한다. 그리고 2번을 서버가 backend에서 조용히 실행하게 한다. 댓글이 달리게 하고 따로 서버는 웹상에서 댓글러의 정보를 불러와 확인한후에 메일을 보내는 것이다. 이러한 경우 AJAX가 있기 때문에 우리는 웹상에서 정보를 확인하면서 다양한 기능을 선택적으로 사용할 수 있게 되는 것이다.7. sync 콜백함수그러나 동기적인 콜백함수도 있다. 순서대로 실행되고 실행되자마자 콜백함수를 호출하는 것이다var array = [1, 30, 20, 400, 500, 2, 3, 5, 12, 33];console.log(array.sort(sortFunc));function sortFunc(a, b) { return a - b;}function myDisplayer(sum) { console.log(&quot;mydis&quot; + sum);}function myCalculator(num1, num2, myCallback) { let sum = num1 + num2; myCallback(sum);}myCalculator(5, 5, myDisplayer);// [1, 2, 3, 5, 12, 20, 30, 33, 400, 500]// mydis10sort 메소드 같은 경우 compare 함수를 인자로 받는다. 그리고 compare 함수에서 array의 원소를 하나하나 compare 함수에 대입한다. a - b의 값이 + 인지 - 인지 0 인지에 따라 배열을 달리한다. 그래서 compare 함수안에서 배열이 다 끝나면 sort 함수가 끝난다. sort 함수가 실행되는 도중에 따로 compare 함수가 실행된다. myCalculator 함수도 마찬가지다." }, { "title": "클래스다 클래스!", "url": "/posts/jsBasic3/", "categories": "Javascript, basics(js)", "tags": "class, extends", "date": "2020-08-27 00:00:00 +0900", "snippet": "3. 클래스클래스는 ES6 부터 제공되는 기능이다. 클래스는 객체가 아니고 객체를 담는 template 라고 생각하면 된다.(근데 typeof 클래스 라고 하면 fucntion이 나온다.) 참고로 클래스의 첫번째 method이름은 반드시 ‘constructor’ 이어야 한다. ‘constructor’를 통해 만들어진 property가 뒤에 사용된다. 마찬가지로 new를 통해 생성자 함수로 만들고 그 뒤에 계속 복제 가능하다. 비유를 하자면 붕어빵 찍는 틀이 class이고 틀로 인해 만들어진 붕어빵이 object(instnace of class)가 된다. 사실 클래스는 기존에 자바스크립트에서 존재하던 function에 또 다른 기능을 추가한것이다. 이렇게 원형이 존재하고 그 원형에 몇가지 기능을 추가해서 문법을 새로 만드는 것을 syntatical suger라고도 한다. 그럼 예시로 배워보자.class Car { constructor(name, year) { // constructor method this.name = name; //property. 어떻게 보면 클래스 안에서 변수를 설정한다고 보면 될 것 같다. this.year = year; } age() { let date = new Date(); return date.getFullYear() - this.year; } thirdMethod() { return; }}let myCar = new Car(&quot;Ford&quot;, 2014); // 클래스를 사용하기 전에 선언해주자.console.log(myCar);// name : Ford// year : 2014console.log(myCar.age());// 7클래스를 사용할 때 는 변수처럼 선언해야한다. 그리고 클래스는 호이스팅이 되지 않는다.(여기서 말하는 호이스팅이란 선언하는 순간 선언된 대상이 유효범위(스코프)의 최상단까지 ‘끌어올려져서’(hoisted) 선언되는 것을 의미한다. 함수안에서 호이스팅되면 함수 최상단에, 그게 아니면 전역 최상단에 선언되어서 ‘어느 줄에서나 사용가능한 상태’를 의미한다.)이처럼 호이스팅 되지 않는것은 선언하고 나서 사용가능하다.또한 그 전에 글에서 함수를 객체로 만든다음 메소드를 추가할때는 prototype을 통해서 메소드를 따로 빼서 추가한다음 공유하게 했다. 클래스에선 그럴필요 없다. 클래스 안에 메소드를 추가하면 자동으로 공유가능하게 따로 빼논것 처럼 되어버린다.P.S: 참고로 var,let,const는 hoisting 된다. 다만 let,const는 선언하고나서 할당하기 전에 사용하면 cannot access before initialization 이라고 뜬다.(여기서 initialization은 선언과 할당이 모두 이루어진 상태를 의미한다. 에러 없이 완벽하게 사용가능한 상태를 말한다) 일단 hositing 되긴 되었는데 할당이 안되었다는 뜻이다. 그래서 hoisiting이 일단은 된다는 것을 알 수 있다.var 같은 경우는 선언만 할경우 hoisting 되면서 default 로 undefined 가 할당된다.그리고 function은 hositing도 되면서 동시에 initialized도 되기 때문에 reference 에러나 TDZ 에러도 발생하지 않고 사용가능하다.그리고 선언은 과 할당사이 또는 선언 전의 공간을 Temporal Dead Zone(TDZ) 라고 한다. 변수가 사용불가능한 영역인것이다.// TDZ// TDZ// TDZconsole.log(greeting); // cannot access &#39;greeting&#39; before initialization// TDZ// TDZlet greeting;// TDZ// TDZgreeting = &quot;Hello&quot;; // TDZ for &#39;let greeting&#39; ends here3-2. 클래스의 상속(확장)파이썬에서 처럼 인자형태로 PASS 되서 확장되는게 아니라 extends 라는 키워드로 확장된다. 또한 부모 클래스의 method를 사용하고 싶을때 super() 함수를 사용한다. sass css 의 extend랑 거의 같은 개념이라고 봐도 된다. super가 없다면 부모 클래스의 코드를 자식 클래스안에서 다시 작성해줘야한다. 그럼 상속의 의미가 없어짐. super를 사용해서 부모클래스의 속성을 가져다 쓰고 추가적인 부분은 자식 클래스에 작성한다.class Person { constructor(name, first, second) { this.name = name; this.first = first; this.second = second; } sum() { return this.first + this.second; }}class PersonPlus extends Person { //Person 클래스를 Personplus에 확장시켰다 constructor(name, first, second, third) { // super()는 생성자 클래스를 의미 super(name, first, second); this.third = third; } sum() { //super.property ==&amp;gt; 부모클래스의 property를 불러올때 점을 찍는다 return super.sum() + this.third; } avg() { return (this.first + this.second) / 2; }}var kim = new PersonPlus(&quot;kim&quot;, 10, 20, 30);console.log(&quot;kim.sum()&quot;, kim.sum());console.log(&quot;kim.avg()&quot;, kim.avg());// kim.sum() 60// kim.avg() 153-2-1. 객체의 상속(proto)클래스가 아닌 일반 객체끼리도 상속기능을 쓸 수 있다. 자바스크립트만이 가진 특징이라고도 할 수 있다(보통 클래스끼리 상속하기 때문) __proto__ 라는 키워드를 사용하는 것이다.(다만 이 방법은 비표준화된 방법이다)var superObj = { superVal: &quot;super&quot; };var subObj = { subVal: &quot;sub&quot; };//subObj에 superObj를 상속하자subObj.__proto__ = superObj;console.log(&quot;subObj.subVal =&amp;gt;&quot;, subObj.subVal);console.log(&quot;subObj.superVal =&amp;gt;&quot;, subObj.superVal);// subObj.subVal =&amp;gt; sub// subObj.superVal =&amp;gt; super// 만약 superObj에서 상속받은 속성을 subObj에서 변경하면 superObj 도 바뀔까?subObj.superVal = &quot;sub&quot;;console.log(&quot;superObj.superVal =&amp;gt;&quot;, superObj.superVal);// superObj.superVal =&amp;gt; super// 아니다 subObj의 proto 만 바뀔뿐 부모 객체의 속성은 바뀌지 않는다.3-2-2. Object.creat()그러나 proto를 써서 바꿀 수 도 있지만 이름도 헷갈리기 때문에 더 괜찮은 방법으로 상속하는 방법이 있다. 바로 object.create() 메소드를 사용하는거다.(표준화된 방법이다)var superObj = { superVal: &quot;super&quot; };//superObj를 prototype으로 하는 객체를 subObj 에 상속함. 그리고 새로운 객체(subOjb)를 만들어 냄var subObj = Object.create(superObj);// subVal property를 지정하자.subObj.subVal = &quot;sub&quot;;// proto와의 차이점은 상속한 부모 객체의 속성을 바꿀 수 있다는 것이다.subObj.superVal = &quot;changedSuperVal&quot;;console.log(&quot;subObj.subVal =&amp;gt;&quot;, subObj.subVal);console.log(&quot;subObj.superVal =&amp;gt;&quot;, subObj.superVal);// subObj.subVal =&amp;gt; sub// subObj.superVal =&amp;gt; changedSuperValconsole.log(&quot;superObj.superVal =&amp;gt;&quot;, superObj.superVal);// superObj.superVal =&amp;gt; superdebugger;그리고 debugger 라는 키워드가 있는데 실행시키면 웹을 잠시 멈추고 코드와 코드의 속성을 볼 수 있다.watch에서 subObj를 검색하면 proto링크가 superObj로 향한다는 것을 알 수 있다." }, { "title": "자바스크립트 함수, 그리고 this의 등장", "url": "/posts/jsBasic2/", "categories": "Javascript, basics(js)", "tags": "function, this, bind", "date": "2020-08-27 00:00:00 +0900", "snippet": "1. 객체나름대로 자신의 코드를 가진 독립적인 아이들이다. 객체안에 있는 함수를 메소드 라고 한다.// 2. objectconst yeongInfo = { name: &quot;Yeonghun&quot;, gender: &quot;male&quot;, awsomeness: true, favMovies: [&quot;Peppermind&quot;, &quot;Harry potter&quot;], favFood: [ { Foodone: &quot;kimchi&quot;, calories: 20, }, { Foodtwo: &quot;Fried rice&quot;, calories: 190, }, ],};// 이런식으로 yeongInfo(객체,독립적 정체성, 자기나름의 세계가 있음) 안에 array와 변수를 추가할 수 있다. 그리고 object안에 원소를 불러내려면 . 을 사용하자 아래처럼 말이다. 그런 의미에서 console.log 도 함수이다.console.log(yeongInfo.favFood[0].Foodone) &amp;gt;&amp;gt;&amp;gt; kimchi;2. 함수와 객체화// 3. functionfunction ho(name, name2) { console.log(&quot;Hello&quot;, name, &quot;Nice to meet you I&#39;m&quot;, name2);}ho(&quot;척&quot;, &quot;씨베리아&quot;);함수를 정의 할 때 먼저 앞에 fuction 을 쓰고 그 뒤에 함수이름을 정해준다. 그리고 함수안에 코드를 작성한다. 함수이름 옆에 ()가 있다.여기에 들어가는 값을 argument(인자)라고 한다. 그리고 임시로 정한 인자 이름을 함수안에서 사용하면 나중에 외부에서 input 된 데이터가 함수 안에 있는 인자 값으로 대입이 된다. 그리고 함수를 실행 할때 함수이름을 쓰고 괄호안에 인자를 대입하자. 그리고 함수는 console.log 없이 사용가능하다.근데 greetings 객체를 더 깔끔하게 만들 수 있다.function greetings(name, name2){ return `Hello ${name} Nice to meet you I&#39;m ${name2}`;}const hey = greetings(&quot;척&quot;, 112)console.log(hey)&amp;gt;&amp;gt;&amp;gt; Hello 척 Nice to meet you I&#39;m 112//라고 하면 됨. return 값을 주고 앞뒤로 ``(백틱)를 붙여줌.// 계산 함수const calculator = { plus: function(a,b){ return a + b }, multiply: function(a,b){ return a * b }, divide: function(a,b){ return a / b }, minus: function(a,b){ return a - b }, square: function(a,b){ return a ** b }}console.log(calculator.divide(4,6))&amp;gt;&amp;gt;&amp;gt;0.66// 상수이지만 사실 상수안에 여러가지 코드가 들어있어 함수같은 느낌이 난다.P.S: 참고로 calcaulator 를 객체 divide를 method라고 한다2-1. 함수의 다양한 사용법함수를 리턴값으로도 사용가능하고 배열값으로도 사용가능하다.//리턴값function cal(mode) { var funcs = { plus: function (left, right) { return left + right; }, minus: function (left, right) { return left - right; }, }; return funcs[mode];}alert(cal(&quot;plus&quot;)(2, 1));alert(cal(&quot;minus&quot;)(2, 1));// 배열값var process = [ function (input) { return input + 10; }, function (input) { return input * input; }, function (input) { return input / 2; },];var input = 1;for (var i = 0; i &amp;lt; process.length; i++) { input = process[i](input);}alert(input);이렇게 다양한 용도로 사용가능한 함수를 first-class citizen 이라고도 한다.그리고 new 라는 키워드가 있다.만약에 선언할때는 객체 앞에 new 라는 키워드를 붙이게 되면 어떤일이 벌어질까? new는 대상을 생성자 객체로 만들어준다. 객체안에 있는 내용을 재생산하는 생성자가 되는 것이다. 그럼 앞으로 호출할 때마다 객체안에 있는 내용들이 생산되고 이를 사용할 수 있다. 그리고 객체안에 property(변수같은거)와 메소드(함수같은거)를 추가할 수 있다.(객체안에 함수처럼 사용되는게 있는데 method 라고 부르고 method 말고 변수처럼 사용되는게 있는데 그걸 property(또는 field, 변수랑 비슷한 기능) 라고 부른다.)때문에 var 무엇 = new 대상 으로 선언하고나서 대상을 constructor(생성자) 함수 라고도 한다. 무엇을 호출함으로서 객체 안에 있는 기능을 자유자재로 사용할 수 있게된다.(참고로 생성자함수의 이름은 대문자로 시작하는게 좋다. 구분하기 위해)마치 var d = new Date(&#39;2021-01-02&#39;) 처럼 말이다.무슨말인지 도통 감이 잡히질 않으니 코드로 살펴보자.function Person(in_name) { // this는 아래글에서 설명되어있다 this.name = in_name; //property this.age; this.calAge = function () { //method return document.write(&quot;my name is &quot; + this.name + &quot;&amp;lt;br&amp;gt;&quot;); };}var p1 = new person(&quot;yeong&quot;);p1.calAge();p1.age = 22;person이라는 함수에 “yeong” 이라는 인자를 대입했다. 그리고 이 함수를 객체로 만들고 p1이라는 변수에 포장하였다. 이제부터는 Person이 생성자 함수가 되고 이 함수안에 있는 name property/age property(아직 정의되지 않음)/calAge함수를 사용할 수 있게 된다.그리고 p1을 콘솔로그 해보면 이렇게 결과값이 나올 것이다.person {name: &quot;yeong&quot;, age: 22, calAge: ƒ}person함수를 객체화 시켰다. 만약 new라는 키워드를 사용하지 않고 person(&quot;yeong&quot;) 이라고 선언하고 로그해보면 뭐라고 나올까? undefined라고 뜬다. return 값이 없기때문이다.new를 사용하지 않고 그냥 함수로서 사용하면 함수안에 있는 수식을 통해 최종 리턴되는 값이 있을건데 그 리턴값만을 출력하게 될뿐이다. 그 함수에 여러가지 다른 함수,또는 property를 골라서 쓰고 또 심지어는 또 다른 함수나 property를 추가할 수 있는 객체와는 다르다. 그리고 그냥 함수에는 this라는 키워드를 사용하지 않고 일반 변수를 설정하듯 해야한다.그리고 this 라는 키워드가 있는데 아래 챕터에서 살펴보자.2-2. this생활코딩에서 방금 this에 대한 개념을 완벽하게 정리하고 왔다. this 는 객체가 설정한 property를 유연하게 manage하기 위함이다. 간단하게 예를 들어보자var kim = { first: 10, second: 20, sum() { return kim.first + kim.second; },};요렇게 kim 과 관련된 property 와 method 가 저장된 kim이라는 객체가 있다고 했을때 sum이라는 method를 사용하려면 kim.sum()을 입력하면 된다. 근데 var 의 이름이 바뀌는 순간 에러가 난다. sum() method 안에 있는 kim.first 가 undefined 인 상태가 되기 때문. 그래서 유연하지 못하다. 이때 this 라는 keyword를 사용해준다. this 는 ‘this가 속한’ 객체를 의미하기 때문에 유연하게 형태를 바꿀 수 있는 특성을 부여한다.따라서 아래와 같이 코드를 바꾸면 훨씬 깔끔하고 효율적으로 객체를 구성하게 되는 것이다. var의 이름이 바뀜에 따라 this가 가리키는 대상도 바뀌기 때문.var kim = { first: 10, second: 20, sum() { return this.first + this.second; },};this는 다시 말해서 this를 호출했을때 this의 스코프 위치에 따라서 this(호출한 주체)가 바뀐다. 다른예제를 살펴보자.p.s: 코드가 적용되는 범위를 스코프라고 하는데 그 범위가 상위방향으로 엮여있는걸 스코프체인이라고 말한다. 다시말해 inner func에서 a 라는 변수를 못찾으면 그 위 상위 outer func에서 a라는 변수를 자동으로 찾기 시작한다는거.var someone = { name: &quot;yeong&quot;, whoAmI: function () { console.log(this); },};someone.whoAmI();var myWhoAmI = someone.whoAmI;myWhoAmI();// Object{}// Window{}var btn = document.getElementById(&quot;btn&quot;);btn.addeventListener(&quot;click&quot;, myWhoAmI);// &amp;lt;button id = &#39;btn&#39;&amp;gt;...&amp;lt;/button&amp;gt;자 보면은 someone.whoAmI(); 에서 whoAmI() 안에 있는 this는 someone 객체이다. someone이 whoAmI()를 호출했기 때문에.myWhoAmI(); 는 window가 호출했기 때문에 이때 this는 window가 된다. 앞에 window가 생략되어있다고 봐도 된다.그리고 btn을 클릭했을때는 this가 button이 된다. button이 호출했기 때문에. 그럼 더 신기한기능을 설명하겠다. 뒤에서도 설명하겠지만, 호출자, 즉 this를 다른놈으로 변경할 수 있다. 바로 bind를 이용하면 된다. bind는 호출한 대상을 바꿔버린다. 따라서 this의 주체를 바꿔버릴 수 있다.const bindWhoAmI = myWhoAmI.bind(someone);bindWhoAmI();요롷게 하면 myWhoAmI의 this는 원래는 window인데 someone으로 바꾸어 주었다.근데 또 질문거리가 생겼다. 우연히 someone.whoAmI 를 arrow func으로 표현해보았다. 그리고 나서 someone.whoAmI()를 출력했는데 this가 window라고 알려준다.var someone = { name: &quot;yeong&quot;, whoAmI: () =&amp;gt; { console.log(this); },};//window{}그 이유는 arrow function 에는 일반함수에는 없는게 3가지가 있기 때문이다 바로 함수이름, this, arguments 가 없다.2-2-1. arrow function 에는 없는 것들우선 함수이름이 없다는거는 따로 설명하지 않아도 self-evident 니깐 넘어가겠다.1. this가 없다우선 아래 코드를 보자const btn = document.querySelector(&quot;.btn&quot;);var myObj = { count: 0, setCount: function () { console.log(this.count); btn.addEventListener(&quot;click&quot;, () =&amp;gt; { console.log(this.count++); }); },};myObj.setCount();//0//1//2이때 btn이 불러온 콜백함수가 arrow function 이다. 근데 arrow function 에 this가 없기 때문에 그 밖의 스코프를 참조하게 된다. 바로 setCount의 스코프이다. setCount의 스코프에서 this는 myObj 이기 때문에 this.count는 myObj의 count:0 가 된다. 또한 arrow function으로 new 생성자를 만들수 없다. new는 this 오브젝트를 불러와야하는데 arrow에는 이게 없어서2. arguments가 없다여기서 arguments란 인자를 받지않는 함수에 인자를 parameter로 pass하게 될때 arguments를 쓰면 배열같은 형태로 받아서 사용 할 수 있게 하는 키워드이다const myFun = function () { console.log(arguments);};myFun(1, 2, 3, 4);//Arguments(4) [1, 2, 3, 4]이렇게 사용가능. 근데 arrow function으로 접근해보자const myFun = () =&amp;gt; { console.log(arguments);};myFun(1, 2, 3, 4);//arguments is not defined그럼 이렇게 사용가능하게 할 수 있다.function outter() { const myFun = () =&amp;gt; { console.log(arguments); };}outter(1, 2, 3, 4);//Arguments(4) [1, 2, 3, 4]const myFun = function (...args) { console.log(args);};myFun(1, 2, 3, 4);//(4) [1, 2, 3, 4]myFun에 arguments가 없으니 outter의 스코프를 참조하기 시작함. 또는 …args라고 spread syntax를 사용하면 된다. 그럼 인자를 받아서 사용가능하다. 그리고 …args를 사용하면 실제 배열이 return된다. 이건 python에서도 배웠다. 이로서 this에 대한 개념은 거의다 잡힌것 같다.근데 한가지 질문이 있다. class안에서 property를 만들때 const,let,var를 사용하는대신에 왜 꼭 this를 사용해야하는가? this가 무슨뜻인지는 아는데 굳이 this를 사용해야하는 이유는 무엇인가? 아직 그이유를 정확히 알아내지는 못했지만 나름 추측을 해보자면.car 클래스는 new를 통해 생성자 함수가 되고 그이후에 인자를 다르게 받음으로써 생성자 함수가 담긴 변수가 여러번 바뀔 수 있다. 이떄 this가 아니라면 변화할때 마다 property를 변경해줘야 하기 때문이라고 생각된다. 나중에 정확히 알게되면 다시 포스팅!2-3. 함수의 prototype만약에 생성자 함수를 원형으로해서 뒤에 그 함수를 쉴새없이 찍어낸다고 했을때 생성자 함수안에 또 다른 함수가 들어있다면 찍어낼때마다 함수가 만들어지고 그렇게 되면 메모리 손실이 어마어마하게 커지면서 문제가 발생할 수 있다. 그래서 복제된 객체들이 하나씩 그 함수를 가지고 있는게 아니라 함수를 생성자 함수에서 따로 빼내어 공유하게끔 하면 메모리 손실을 획기적으로 줄일 수 있다.그때 사용하는 키워드가 prototype이다.function Person(first, second, third) { this.first = first; this.second = second; this.third = third;}Person.prototype.sum = function () { return `prototype :` + (this.first + this.second + this.third);};Person.prototype.fourth = &quot;pro fourth&quot;;var kim = new Person(10, 20, 40);kim.sum = function () { return `kim&#39;s sum :` + (this.first + this.second + this.third);};var lee = new Person(20, 30, 10);var gang = new Person(20, 20, 60);console.log(kim.sum());console.log(lee.sum());console.log(gang.sum());console.log(kim.fourth);// kim&#39;s sum70// prototype :60// prototype :100// pro fourth또한 kim에 해당하는 sum만 따로 설정가능하다. 그리고 property를 추가할 수 도 있다." }, { "title": "자바스크립트 기본 문법 (변수)", "url": "/posts/jsBasic1/", "categories": "Javascript, basics(js)", "tags": "variables", "date": "2020-08-25 00:00:00 +0900", "snippet": "1. 바닐라 JS 란?노마드 코더에서 바닐라 JS를 배우기 시작했다. 자바스크립트의 원형이라고 생각하면 된다고 한다. 라이브러리나 프레임워크가 없기 때문에 더 기초적인 코드를 짜야하지만 기본기를 배울 수 있다고 한다. 사실 노마드코더에서 파이썬 데이터 사이언스 수업을 들으려고 했는데 바닐라JS 랑 파이썬2주 완성을 들어야 한다길래 수강했다. 바닐라 JS로 TO-DO LIST 를 만들고 관리하는 웹페이지를 만드는게 프로젝트의 목적이다.자바스크립트는 사용자와의 상호작용이 가능한 동적인 웹사이트를 만드는데 꼭 필요한 언어이다. 그리고 진짜 오래된 언어이다. 그래서 , 뭔가 기대가 된다. 그럼 우선 자바스크립트의 기본 문법에 대해서 배워보자.html 뼈대 설정먼저 기본적인 웹의 뼈대를 만들고 index.html 이란 이름으로 저장하자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;무모&amp;lt;/title&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot; /&amp;gt; &amp;lt;!--index.css 파일안에 css언어로 디자인을 집약할 생각--&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1 id=&quot;title&quot;&amp;gt;This will work. so Don&#39;t worry&amp;lt;/h1&amp;gt; &amp;lt;script src=&quot;index.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!--자바스트립트 코드는 index.js 파일에 모아놀 생각--&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;css 뼈대 설정그러고는 index.css 파일을 만들어 아래코드를 추가한다.body { background-color: #ecf0f1; /* 배경색 설정 */}h1 { color: #34495e; /* h1 태그에 해당하는 색 설정 */}자바스크립트 기본문법 1그리고 마지막으로 index.js 파일을 만들어 실습의 장을 연다. 처음엔 간단하게 var,array,const 에 대해 배워보도록 하겠다. 아래 코드를 보자.let a = 24; // 변수를 처음 정의 할 때 let을 쓴다. 그리고 진짜 필요할 때만. 대부분은 const 변수를 사용하자.let b = a - 12; // 그리고 문장이 끝나면 세미콜론을 붙이자const c = 111; // 변수를 변경할 수 없게 하려면 const(constant) 코드를 사용한다.(중요)const name = &quot;yeong&quot;;const daysOfweek = [&quot;mon&quot;,&quot;tue&quot;,&quot;wed&quot;]; // array. 파이썬에서 list() 객체와 같다고 보면 될 것 같다. // 2번째 원소만 불러오고 싶다 하면 [1] 만 붙여주면 된다.console.log(daysOfweek) // 파이썬과 다르게(print()) 자바스크립트에서는 console.log() 라는 함수를 써서&amp;gt;&amp;gt;&amp;gt;[&quot;mon&quot;,&quot;tue&quot;,&quot;wed&quot;]결과값을 프린트한다console.log(b)&amp;gt;&amp;gt;&amp;gt;12" }, { "title": "자바스크립트 시작!", "url": "/posts/apple3/", "categories": "Javascript, apple", "tags": "pageYOffSet, IIFE, DOMContentLoaded, load", "date": "2020-07-25 00:00:00 +0900", "snippet": "1. 스크롤에 따른 글자 효과 구현(기본원리)드디어 static한 구조는 다 짰고 동적인 기능을 구현하려고 한다. 기본원리는 아래와 같다. pageYOffSet을 이용해서 현재 스크롤의 위치를 구함. 각 scroll-section의 크기 내에서 현재 스크롤한 위치가 어느정도 비율을 차지하는지 구함. 그 비율이 예를 들어, scroll-section-0 안에서 이 section의 길이의 0.1 ~ 0.2 구간을 지나고 있으면 sticky-elem .main-message.a 을 표시함. 2. 새로배운 접근법관건은 스크롤이 얼마나 되었는지 그 비율을 정확히 구하는것이다.그리고 캔버스의 크기도 줄어든 크기에 맞추어서 정확히 계산하는 것이다. 전역변수가 다른곳에 쓰여 혼란이 일어나는것을 방지하기 위해 익명함수 안에다가 변수를 선언함. 이러한 표현을 즉시실행함수(Immediately Invoked Function Expression) 라고 함.(() =&amp;gt; { const a = 0; function blahblah() {}})(); 각 scroll-section-숫자 에 관련된 정보를 array(sceneInfo)에 담은다음 활용 함(json형태로)const sceneInfo = [ { // 0 type: &quot;sticky&quot;, heightNum: 5, // view port의 5배의 높이로 스크롤 설정 scrollHeight: 0, objs: { // 작업할 DOM 객체를 따로 보관 // 그리고 .a를 .main-message와 붙여서 표기해야 인식함 container: document.querySelector(&quot;#scroll-section-0&quot;), }, // 각 sticky message에 따른 css값을 values에서 설정 }, { // 1 type: &quot;normal&quot;, // heightNum: 5, // type normal 에서는 필요없음. 스크롤 효과가 없는 section이니깐. scrollHeight: 0, objs: { container: document.querySelector(&quot;#scroll-section-1&quot;), }, }, { // 2 type: &quot;sticky&quot;, heightNum: 5, // 브라우저의 5배의 높이로 스크롤 설정 scrollHeight: 0, objs: { container: document.querySelector(&quot;#scroll-section-2&quot;), }, }, { // 3 type: &quot;sticky&quot;, heightNum: 5, // 브라우저의 5배의 높이로 스크롤 설정 scrollHeight: 0, objs: { container: document.querySelector(&quot;#scroll-section-3&quot;), }, },]; 각각의 콘텐츠의(사진,글귀 등등) 크기가 나타나기 전에 사이즈를 조절하는 함수를 만듬(setLayOut). 그리고 이 함수가 browser로드하기 전에, 그리고 창의 크기를 조절할때마다 실행되도록 함으로써 반응형으로 만듬.(load,resize) 지금 현재 스크롤하고 있는 위치가 어느 section인지 판별하는 법: 예를들어, scroll-section-2에 도달했다는 것은 scroll-section-0높이 + scroll-section-1높이 &amp;lt; Yoffset(스크롤한 전체 px)라는 뜻이다. 이런식으로 계산하면 됨. function scrollLoop() { // currentScene을 설정한다. // 0으로 초기화 시켜주지 않으면 끊임없이 누적된다. enterNewScene = false; prevScrollHeight = 0; for (let i = 0; i &amp;lt; currentScene; i++) { prevScrollHeight += sceneInfo[i].scrollHeight; } // 버그 // prevScrollHeight += 를 해주지 않아서 prevScrollHeight의 크기가 맨 마지막 section의 크기만 계산됨. // 그럼 마지막 currentScene의 크기(대략 3000px) + 그 이전의 scene의 크기(3000px) 이니깐 // 이것보다 스크롤된 y축이 더 커지는 순간 currentScene이 계속 늘어남. // 그럼 sceneInfo에서 out of bound가 되면서 scrollHeight 가 not defined라는 에러가 뜨는 것임. if (yOffSet &amp;gt; prevScrollHeight + sceneInfo[currentScene].scrollHeight) { enterNewScene = true; currentScene++; document.body.setAttribute(&quot;id&quot;, `show-scene-${currentScene}`); } if (yOffSet &amp;lt; prevScrollHeight) { // 브라우저 바운스 효과로 인해 currentScene이 마이너스가 되는것을 방지 if (currentScene === 0) return; enterNewScene = true; currentScene--; document.body.setAttribute(&quot;id&quot;, `show-scene-${currentScene}`); } // 이렇게 하면 새로운 씬으로 접근할때 순간적으로 playAnimation이 실행되기 전에 return함으로써 // opacity가 마이너스가 되기 전에 종료해버림 if (enterNewScene) return; playAnimation();} 이벤트리스너에서 DOMContentLoaded 랑 load랑 차이는 DOM은 말그대로 HTML구조만 다 rendering하면 실행되는거고 load는 안에 이미지, 영상파일까지 다 setting한 후에 실행되는거다. 그래서 여기선 load가 더 적합하다. 코드가 길어지는 걸 방지하기 위해 길어진 코드중에 자주 사용되는것은 변수에 저장해둠 특정 범위 내에서 스크롤의 비율에 따라 값이 출력되도록 계산(calcValues()-rv) – 크… 예술 // 현재 scene에서 얼마나 스크롤 되었는지 비율을 계산function calcValues(values, currentYOffset) { let rv; const scrollHeight = sceneInfo[currentScene].scrollHeight; const scrollRatio = currentYOffset / scrollHeight; if (values.length === 3) { const partScrollStart = values[2].start * scrollHeight; const partScrollEnd = values[2].end * scrollHeight; const partScrollHeight = partScrollEnd - partScrollStart; // 현재 스크롤의 위치를 비율로 나타냄. // 여기도 후속사용의 용의성을 위해서 따로 변수화 시켜줬음. 크... // 특정 범위 내에서 스크롤이 움직였을 때(messageA같은경우 첫번째 씬의 0.1%~0.2% 사이) opacity의 값을 구함(keyFrame) if (currentYOffset &amp;gt;= partScrollStart &amp;amp;&amp;amp; currentYOffset &amp;lt;= partScrollEnd) { rv = ((currentYOffset - partScrollStart) / partScrollHeight) * (values[1] - values[0]) + values[0]; } else if (currentYOffset &amp;lt; partScrollStart) { rv = values[0]; } else if (currentYOffset &amp;gt; partScrollEnd) { rv = values[1]; } } else { // 이건 조금 이해하기 힘들 수 도 있는데, 예를 들어 scrollRatio가 0 ~ 1사이를 움직인다고 했을때 // scrollRatio * 300이라고 하면 1 ~ 300사이의 숫자가 출력 // 그럼 values의 첫번째 값 ~ values의 마지막 값 까지 스크롤값에 따라 출력하게 하려면 // 아래와 같이 rv를 설정해야함. rv = scrollRatio * (values[1] - values[0]) + values[0]; } // console.log(rv); return rv;} 그리고 playAnimation에서 scrollRatio의 값에 따라 메세지가 출력되는 특정 위치범위를 선정하고(switch/currentScene을 이용해서) 그 범위안에 scroll이 들어오면 calcValues를 이용해 각각의 메세지의 투명도와 y축의 수치에 변화를 줌function playAnimation() { // 이렇게 변수를 설정해주면 훨씬 깔끔하게 후속 사용가능. const objs = sceneInfo[currentScene].objs; const values = sceneInfo[currentScene].values; // currentYOffset이 마이너스가 되는 이유는 prev &amp;gt; yOffSet 이기 때문. // 페이지가 넘어갈 때 이렇게 된다는 것인데 그 이유는? const currentYOffset = yOffSet - prevScrollHeight; const scrollHeight = sceneInfo[currentScene].scrollHeight; const scrollRatio = currentYOffset / scrollHeight; switch (currentScene) { case 0: // messageA if (scrollRatio &amp;lt; 0.22) { // IN objs.messageA.style.opacity = calcValues( values.messageA_opacity_in, currentYOffset ); objs.messageA.style.transform = `translate3d(0,${calcValues( values.messageA_translateY_in, currentYOffset )}%,0)`; } else { // OUT objs.messageA.style.opacity = calcValues( values.messageA_opacity_out, currentYOffset ); objs.messageA.style.transform = `translate3d(0,${calcValues( values.messageA_translateY_out, currentYOffset )}%,0)`; } // messageB if (scrollRatio &amp;lt; 0.42) { // IN objs.messageB.style.opacity = calcValues( values.messageB_opacity_in, currentYOffset ); objs.messageB.style.transform = `translate3d(0,${calcValues( values.messageB_translateY_in, currentYOffset )}%,0)`; } else { // OUT objs.messageB.style.opacity = calcValues( values.messageB_opacity_out, currentYOffset ); objs.messageB.style.transform = `translate3d(0,${calcValues( values.messageB_translateY_out, currentYOffset )}%,0)`; } // messageC if (scrollRatio &amp;lt; 0.62) { // IN objs.messageC.style.opacity = calcValues( values.messageC_opacity_in, currentYOffset ); objs.messageC.style.transform = `translate3d(0,${calcValues( values.messageC_translateY_in, currentYOffset )}%,0)`; } else { // OUT objs.messageC.style.opacity = calcValues( values.messageC_opacity_out, currentYOffset ); objs.messageC.style.transform = `translate3d(0,${calcValues( values.messageC_translateY_out, currentYOffset )}%,0)`; } // messageD if (scrollRatio &amp;lt; 0.82) { // IN objs.messageD.style.opacity = calcValues( values.messageD_opacity_in, currentYOffset ); objs.messageD.style.transform = `translate3d(0,${calcValues( values.messageD_translateY_in, currentYOffset )}%,0)`; } else { // OUT objs.messageD.style.opacity = calcValues( values.messageD_opacity_out, currentYOffset ); objs.messageD.style.transform = `translate3d(0,${calcValues( values.messageD_translateY_out, currentYOffset )}%,0)`; } break; case 1: break; case 2: break; case 3: break; }} 첫번째 canvas 크기를 조절할 때 css에서 일단 맨위 맨왼쪽에서 시작점을 잡아줌. canvas크기의 50%씩 위치를 세팅. 그리고 다시 javascript의 translate3d를 이용해서 x,y를 50%씩 옮겨주니 가운데 정렬이 되었다.그럼 아래와 같이 효과가 나타남.끝!" }, { "title": "CSS 시작!", "url": "/posts/apple2/", "categories": "Javascript, apple", "tags": "not selector, border-box, margin으로 가운데 정렬, rem, translate3d, relative", "date": "2020-07-25 00:00:00 +0900", "snippet": "1. CSS 정리글자 크기, 여백의 크기, 높이, 예외사항 등등 ‘사소해 보이는 것’을 잘 맞추자. 아님 이런것들로 인해 나중에 버그가 발생했을 때 어디서 버그가 발생했는지 알기 힘들기 때문box-sizing:border-box 안 해주면 padding-top:50vh로 인해서 scroll-section-숫자의 박스 사이즈가 변경이 되어버린다. 그래서 box-size를 고정시켜주기 위해서 border-box를 한다. 이 모든것은 default.css에 포함되어있다. 아래는 w3school에서 border-box에 대한 정의이다.The CSS box-sizing property allows us to include the padding and border in an element&#39;s total width and height. 자식 height:100%로 해주면 부모 높이에 맞춰진다. margin-right:auto 로 해두면 오른쪽에 있는 nav가 오른쪽으로 쏠리게 되면서 자동적으로 가운데 정렬이 된다. 그 이유는 auto로 하면서 오른쪽에 있는 여백을 모두 쓰게 되기 때문이다. 참고로 margin: 0 auto 라고 하면 좌우 여백이 균일하게 맞춰지면서 자동으로 가운데 정렬됨. a:not(.product-name) 이라고 하면 product-name빼고 모든 a에 적용한다는 뜻. .local-nav-links a:not(.product-name) { margin-left: 2em; /* .product-name 클래스만 빼고 margin-left 2em 만큼 적용 */} 우선순위를 앞에 두고 싶다고 하면 부모클래스 &amp;gt; 자식클래스를 명확하게 지정할것! (.local-nav-links .product-name 보다 local-nav-links a 가 덜 중요) 숫자 rem: html 폰트 사이즈 곱하기 숫자(html의 px에 따라 달라짐, 창이 크든 작든 고정되었으면 할때 사용) 숫자 em : 현재 속해 있는 font-size 곱하기 숫자. 즉 root가 아닌 font-size에 맞춰서 알아서 높이나 넓이가 변환이 되므로 더 유연하게 크기가 변경됨. 그럼 굳이 계산하지 않아도 알아서 font-size에 맞게 높이, 넓이 , 여백이 결정됨. 50vh: 뷰포트(화면)의 높이의 반을 의미(창의 크기에 따라 달라짐) float: 그림이나 글자가 어느 방향으로 자연스레 흐르게 할거냐를 결정할 수 있음. #show-scene-‘숫자’(body의 id로써) #scroll-section-숫자 .sticky-elem {display:block}이라고 설정해주고, ‘숫자’ 만 바꾸어주면 해당 숫자에 속해있는 sticky-elem이 나타나게 만들었다.(body에 show-scene-숫자 클래스를 추가함.) #show-scene-0 #scroll-section-0 .sticky-elem,#show-scene-1 #scroll-section-1 .sticky-elem,#show-scene-2 #scroll-section-2 .sticky-elem,#show-scene-3 #scroll-section-3 .sticky-elem { display: block;} position:sticky를 이용해서 스크롤이 특정 위치에 도달하면 글이 고정되어 나타나게 하려고 했으나 지원하는 브라우저가 적어서 일단 fixed로 하고 자바스크립트로 조정하기로 결정. 아주 미세한 버그도 그냥 넘기지 말고 디버깅하는게 좋다. 미세한 버그로 인한 문제는 찾기가 매우 힘들 수 있기 때문이다. transform:translateY(20%) 이라고 하면 움직이고자 하는 객체 크기의 20% 길이만큼 아래로 내려보낸다. 따라서 %를 쓰면 유연하게 사용가능 근데 사실 하드웨어 퍼포먼스는 translate3d가 더 좋아서 translateY를 구현한다하더라도 3d를 쓰는 추세이다. section-0 h1 의 위치 변경할때 position:relative와 top:-10vh를 쓰는 이유는? relative는 absolute와 다르게 주변 element의 위치를 그대로 유지한채 바뀌는 것이다. 다른 element와의 위치관계를 그대로 유지한채 h1의 위치가 옮겨가야하므로 relative를 쓴다. 그리고 vh를 쓰는 이유는 scroll-section의 padding이 vh를 썼기 때문이다. " } ]
